# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, Optional, TypeVar, Union, overload
import urllib.parse
import uuid

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer
from .._validation import api_version_validation
from .._vendor import (
    ConversationAdministrationClientMixinABC,
    ConversationThreadClientMixinABC,
    MessageTemplateClientMixinABC,
    NotificationMessagesClientMixinABC,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
_Unset: Any = object()

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_notification_messages_send_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/notifications:send"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_notification_messages_download_media_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/octet-stream")

    # Construct URL
    _url = "/messages/streams/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_message_template_list_templates_request(  # pylint: disable=name-too-long
    channel_id: str, *, max_page_size: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/channels/{channelId}/templates"
    path_format_arguments = {
        "channelId": _SERIALIZER.url("channel_id", channel_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_create_conversation_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_get_conversation_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_delete_conversation_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_terminate_conversation_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}:terminate"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_list_conversations_request(  # pylint: disable=name-too-long
    *,
    max_page_size: Optional[int] = None,
    participant_id: Optional[str] = None,
    channel_id: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if participant_id is not None:
        _params["participantId"] = _SERIALIZER.query("participant_id", participant_id, "str")
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_list_messages_request(  # pylint: disable=name-too-long
    conversation_id: str, *, max_page_size: Optional[int] = None, participant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/messages"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if participant_id is not None:
        _params["participantId"] = _SERIALIZER.query("participant_id", participant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_add_participants_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/participants:add"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_remove_participants_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/participants:remove"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_administration_analyze_conversation_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}:analyze"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_add_participants_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/participants:add"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_remove_participants_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/participants:remove"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_list_conversations_request(  # pylint: disable=name-too-long
    *,
    max_page_size: Optional[int] = None,
    participant_id: Optional[str] = None,
    channel_id: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if participant_id is not None:
        _params["participantId"] = _SERIALIZER.query("participant_id", participant_id, "str")
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_list_messages_request(  # pylint: disable=name-too-long
    conversation_id: str, *, max_page_size: Optional[int] = None, participant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/messages"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if participant_id is not None:
        _params["participantId"] = _SERIALIZER.query("participant_id", participant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_send_message_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}/messages:send"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_conversation_thread_analyze_conversation_request(  # pylint: disable=name-too-long
    conversation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/messages/conversations/{conversationId}:analyze"
    path_format_arguments = {
        "conversationId": _SERIALIZER.url("conversation_id", conversation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if "Repeatability-Request-ID" not in _headers:
        _headers["Repeatability-Request-ID"] = str(uuid.uuid4())
    if "Repeatability-First-Sent" not in _headers:
        _headers["Repeatability-First-Sent"] = _SERIALIZER.serialize_data(
            datetime.datetime.now(datetime.timezone.utc), "rfc-1123"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class NotificationMessagesClientOperationsMixin(NotificationMessagesClientMixinABC):  # pylint: disable=name-too-long

    @overload
    def send(
        self, body: _models.NotificationContent, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SendMessageResult:
        """Sends a notification message from Business to User.

        :param body: Details of the message to send. Required.
        :type body: ~azure.communication.messages.models.NotificationContent
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendMessageResult. The SendMessageResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.SendMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def send(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.SendMessageResult:
        """Sends a notification message from Business to User.

        :param body: Details of the message to send. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendMessageResult. The SendMessageResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.SendMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def send(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SendMessageResult:
        """Sends a notification message from Business to User.

        :param body: Details of the message to send. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendMessageResult. The SendMessageResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.SendMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def send(
        self, body: Union[_models.NotificationContent, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SendMessageResult:
        """Sends a notification message from Business to User.

        :param body: Details of the message to send. Is one of the following types:
         NotificationContent, JSON, IO[bytes] Required.
        :type body: ~azure.communication.messages.models.NotificationContent or JSON or IO[bytes]
        :return: SendMessageResult. The SendMessageResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.SendMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SendMessageResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_notification_messages_send_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SendMessageResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def download_media(self, id: str, **kwargs: Any) -> Iterator[bytes]:
        """Download the Media payload from a User to Business message.

        :param id: The stream ID. Required.
        :type id: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_notification_messages_download_media_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MessageTemplateClientOperationsMixin(MessageTemplateClientMixinABC):

    @distributed_trace
    def list_templates(
        self, channel_id: str, *, max_page_size: Optional[int] = None, **kwargs: Any
    ) -> Iterable["_models.MessageTemplateItem"]:
        """List all templates for given Azure Communication Services channel.

        :param channel_id: The registration ID of the channel. Required.
        :type channel_id: str
        :keyword max_page_size: Number of objects to return per page. Default value is None.
        :paramtype max_page_size: int
        :return: An iterator like instance of MessageTemplateItem
        :rtype: ~azure.core.paging.ItemPaged[~azure.communication.messages.models.MessageTemplateItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MessageTemplateItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_message_template_list_templates_request(
                    channel_id=channel_id,
                    max_page_size=max_page_size,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.MessageTemplateItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class ConversationAdministrationClientOperationsMixin(  # pylint: disable=name-too-long
    ConversationAdministrationClientMixinABC
):

    @overload
    def create_conversation(
        self,
        *,
        conversation: _models.CommunicationConversation,
        content_type: str = "application/json",
        initial_message: Optional[_models.Message] = None,
        **kwargs: Any,
    ) -> _models.CommunicationConversation:
        """Creates a new conversation. This is only for create operation.

        :keyword conversation: The conversation details. Required.
        :paramtype conversation: ~azure.communication.messages.models.CommunicationConversation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword initial_message: An initial message within the conversation. Default value is None.
        :paramtype initial_message: ~azure.communication.messages.models.Message
        :return: CommunicationConversation. The CommunicationConversation is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.CommunicationConversation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_conversation(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommunicationConversation:
        """Creates a new conversation. This is only for create operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommunicationConversation. The CommunicationConversation is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.CommunicationConversation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_conversation(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommunicationConversation:
        """Creates a new conversation. This is only for create operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommunicationConversation. The CommunicationConversation is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.CommunicationConversation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={"2025-04-01-preview": ["endpoint", "api_version", "content_type", "accept"]},
    )
    def create_conversation(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        conversation: _models.CommunicationConversation = _Unset,
        initial_message: Optional[_models.Message] = None,
        **kwargs: Any,
    ) -> _models.CommunicationConversation:
        """Creates a new conversation. This is only for create operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword conversation: The conversation details. Required.
        :paramtype conversation: ~azure.communication.messages.models.CommunicationConversation
        :keyword initial_message: An initial message within the conversation. Default value is None.
        :paramtype initial_message: ~azure.communication.messages.models.Message
        :return: CommunicationConversation. The CommunicationConversation is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.CommunicationConversation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommunicationConversation] = kwargs.pop("cls", None)

        if body is _Unset:
            if conversation is _Unset:
                raise TypeError("missing required argument: conversation")
            body = {"conversation": conversation, "initialMessage": initial_message}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_administration_create_conversation_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommunicationConversation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": ["endpoint", "api_version", "conversation_id", "client_request_id", "accept"]
        },
    )
    def get_conversation(self, conversation_id: str, **kwargs: Any) -> _models.CommunicationConversation:
        """Gets the details of a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :return: CommunicationConversation. The CommunicationConversation is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.CommunicationConversation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CommunicationConversation] = kwargs.pop("cls", None)

        _request = build_conversation_administration_get_conversation_request(
            conversation_id=conversation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommunicationConversation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "accept",
            ]
        },
    )
    def delete_conversation(  # pylint: disable=inconsistent-return-statements
        self, conversation_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_conversation_administration_delete_conversation_request(
            conversation_id=conversation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "accept",
            ]
        },
    )
    def terminate_conversation(  # pylint: disable=inconsistent-return-statements
        self, conversation_id: str, **kwargs: Any
    ) -> None:
        """Terminates a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_conversation_administration_terminate_conversation_request(
            conversation_id=conversation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "max_page_size",
                "participant_id",
                "channel_id",
                "client_request_id",
                "accept",
            ]
        },
    )
    def list_conversations(
        self,
        *,
        max_page_size: Optional[int] = None,
        participant_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.CommunicationConversation"]:
        """Retrieves list of conversations.

        :keyword max_page_size: Number of objects to return per page. Default value is None.
        :paramtype max_page_size: int
        :keyword participant_id: The participant user ID. Default value is None.
        :paramtype participant_id: str
        :keyword channel_id: The id of channel. Default value is None.
        :paramtype channel_id: str
        :return: An iterator like instance of CommunicationConversation
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.communication.messages.models.CommunicationConversation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CommunicationConversation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_conversation_administration_list_conversations_request(
                    max_page_size=max_page_size,
                    participant_id=participant_id,
                    channel_id=channel_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CommunicationConversation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "max_page_size",
                "participant_id",
                "client_request_id",
                "accept",
            ]
        },
    )
    def list_messages(
        self,
        conversation_id: str,
        *,
        max_page_size: Optional[int] = None,
        participant_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.ConversationMessageItem"]:
        """Retrieves list of conversation messages.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :keyword max_page_size: Number of objects to return per page. Default value is None.
        :paramtype max_page_size: int
        :keyword participant_id: The participant user ID. Default value is None.
        :paramtype participant_id: str
        :return: An iterator like instance of ConversationMessageItem
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.communication.messages.models.ConversationMessageItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ConversationMessageItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_conversation_administration_list_messages_request(
                    conversation_id=conversation_id,
                    max_page_size=max_page_size,
                    participant_id=participant_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ConversationMessageItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_participants(
        self,
        conversation_id: str,
        options: _models.AddParticipantsOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: ~azure.communication.messages.models.AddParticipantsOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_participants(
        self, conversation_id: str, options: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_participants(
        self, conversation_id: str, options: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "content_type",
                "accept",
            ]
        },
    )
    def add_participants(
        self, conversation_id: str, options: Union[_models.AddParticipantsOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Is one of the
         following types: AddParticipantsOptions, JSON, IO[bytes] Required.
        :type options: ~azure.communication.messages.models.AddParticipantsOptions or JSON or IO[bytes]
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddParticipantsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_administration_add_participants_request(
            conversation_id=conversation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [207]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddParticipantsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def remove_participants(
        self,
        conversation_id: str,
        options: _models.RemoveParticipantsOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: ~azure.communication.messages.models.RemoveParticipantsOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def remove_participants(
        self, conversation_id: str, options: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def remove_participants(
        self, conversation_id: str, options: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "content_type",
                "accept",
            ]
        },
    )
    def remove_participants(
        self, conversation_id: str, options: Union[_models.RemoveParticipantsOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation. Is
         one of the following types: RemoveParticipantsOptions, JSON, IO[bytes] Required.
        :type options: ~azure.communication.messages.models.RemoveParticipantsOptions or JSON or
         IO[bytes]
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemoveParticipantsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_administration_remove_participants_request(
            conversation_id=conversation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [207]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemoveParticipantsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "accept",
            ]
        },
    )
    def analyze_conversation(self, conversation_id: str, **kwargs: Any) -> _models.GetConversationThreadAnalysisResult:
        """Get AI Analysis of a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :return: GetConversationThreadAnalysisResult. The GetConversationThreadAnalysisResult is
         compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.GetConversationThreadAnalysisResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetConversationThreadAnalysisResult] = kwargs.pop("cls", None)

        _request = build_conversation_administration_analyze_conversation_request(
            conversation_id=conversation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetConversationThreadAnalysisResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ConversationThreadClientOperationsMixin(ConversationThreadClientMixinABC):

    @overload
    def add_participants(
        self,
        conversation_id: str,
        options: _models.AddParticipantsOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: ~azure.communication.messages.models.AddParticipantsOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_participants(
        self, conversation_id: str, options: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_participants(
        self, conversation_id: str, options: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Required.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "content_type",
                "accept",
            ]
        },
    )
    def add_participants(
        self, conversation_id: str, options: Union[_models.AddParticipantsOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AddParticipantsResult:
        """Adds participants to a specific conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the payload for adding participants to a conversation. Is one of the
         following types: AddParticipantsOptions, JSON, IO[bytes] Required.
        :type options: ~azure.communication.messages.models.AddParticipantsOptions or JSON or IO[bytes]
        :return: AddParticipantsResult. The AddParticipantsResult is compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.AddParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddParticipantsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_thread_add_participants_request(
            conversation_id=conversation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [207]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddParticipantsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def remove_participants(
        self,
        conversation_id: str,
        options: _models.RemoveParticipantsOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: ~azure.communication.messages.models.RemoveParticipantsOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def remove_participants(
        self, conversation_id: str, options: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def remove_participants(
        self, conversation_id: str, options: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation.
         Required.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "content_type",
                "accept",
            ]
        },
    )
    def remove_participants(
        self, conversation_id: str, options: Union[_models.RemoveParticipantsOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RemoveParticipantsResult:
        """remove a participant from a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the request body for removing participants from a conversation. Is
         one of the following types: RemoveParticipantsOptions, JSON, IO[bytes] Required.
        :type options: ~azure.communication.messages.models.RemoveParticipantsOptions or JSON or
         IO[bytes]
        :return: RemoveParticipantsResult. The RemoveParticipantsResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.RemoveParticipantsResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RemoveParticipantsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_thread_remove_participants_request(
            conversation_id=conversation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [207]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RemoveParticipantsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "max_page_size",
                "participant_id",
                "channel_id",
                "client_request_id",
                "accept",
            ]
        },
    )
    def list_conversations(
        self,
        *,
        max_page_size: Optional[int] = None,
        participant_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.CommunicationConversation"]:
        """Retrieves list of conversations.

        :keyword max_page_size: Number of objects to return per page. Default value is None.
        :paramtype max_page_size: int
        :keyword participant_id: The participant user ID. Default value is None.
        :paramtype participant_id: str
        :keyword channel_id: The id of channel. Default value is None.
        :paramtype channel_id: str
        :return: An iterator like instance of CommunicationConversation
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.communication.messages.models.CommunicationConversation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CommunicationConversation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_conversation_thread_list_conversations_request(
                    max_page_size=max_page_size,
                    participant_id=participant_id,
                    channel_id=channel_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CommunicationConversation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "max_page_size",
                "participant_id",
                "client_request_id",
                "accept",
            ]
        },
    )
    def list_messages(
        self,
        conversation_id: str,
        *,
        max_page_size: Optional[int] = None,
        participant_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.ConversationMessageItem"]:
        """Retrieves list of conversation messages.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :keyword max_page_size: Number of objects to return per page. Default value is None.
        :paramtype max_page_size: int
        :keyword participant_id: The participant user ID. Default value is None.
        :paramtype participant_id: str
        :return: An iterator like instance of ConversationMessageItem
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.communication.messages.models.ConversationMessageItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ConversationMessageItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_conversation_thread_list_messages_request(
                    conversation_id=conversation_id,
                    max_page_size=max_page_size,
                    participant_id=participant_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ConversationMessageItem], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def send_message(
        self,
        conversation_id: str,
        options: _models.SendConversationMessageOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.SendConversationMessageResult:
        """Sends a conversation message from Business to User.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the conversation message to send. Required.
        :type options: ~azure.communication.messages.models.SendConversationMessageOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendConversationMessageResult. The SendConversationMessageResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.SendConversationMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def send_message(
        self, conversation_id: str, options: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SendConversationMessageResult:
        """Sends a conversation message from Business to User.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the conversation message to send. Required.
        :type options: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendConversationMessageResult. The SendConversationMessageResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.SendConversationMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def send_message(
        self, conversation_id: str, options: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SendConversationMessageResult:
        """Sends a conversation message from Business to User.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the conversation message to send. Required.
        :type options: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SendConversationMessageResult. The SendConversationMessageResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.SendConversationMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "content_type",
                "accept",
            ]
        },
    )
    def send_message(
        self,
        conversation_id: str,
        options: Union[_models.SendConversationMessageOptions, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.SendConversationMessageResult:
        """Sends a conversation message from Business to User.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :param options: Details of the conversation message to send. Is one of the following types:
         SendConversationMessageOptions, JSON, IO[bytes] Required.
        :type options: ~azure.communication.messages.models.SendConversationMessageOptions or JSON or
         IO[bytes]
        :return: SendConversationMessageResult. The SendConversationMessageResult is compatible with
         MutableMapping
        :rtype: ~azure.communication.messages.models.SendConversationMessageResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SendConversationMessageResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(options, (IOBase, bytes)):
            _content = options
        else:
            _content = json.dumps(options, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_conversation_thread_send_message_request(
            conversation_id=conversation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SendConversationMessageResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        method_added_on="2025-04-01-preview",
        params_added_on={
            "2025-04-01-preview": [
                "endpoint",
                "api_version",
                "conversation_id",
                "repeatability_request_id",
                "repeatability_first_sent",
                "client_request_id",
                "accept",
            ]
        },
    )
    def analyze_conversation(self, conversation_id: str, **kwargs: Any) -> _models.GetConversationThreadAnalysisResult:
        """Get AI Analysis of a conversation.

        :param conversation_id: The conversation ID. Required.
        :type conversation_id: str
        :return: GetConversationThreadAnalysisResult. The GetConversationThreadAnalysisResult is
         compatible with MutableMapping
        :rtype: ~azure.communication.messages.models.GetConversationThreadAnalysisResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetConversationThreadAnalysisResult] = kwargs.pop("cls", None)

        _request = build_conversation_thread_analyze_conversation_request(
            conversation_id=conversation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Repeatability-Result"] = self._deserialize(
            "str", response.headers.get("Repeatability-Result")
        )
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetConversationThreadAnalysisResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
