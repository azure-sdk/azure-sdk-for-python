# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .. import models as _models
from .._serialization import Serializer
from .._vendor import _convert_request

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_create_operation_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01"))
    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport")
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_get_operation_results_request(scope: str, operation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop(
        "template_url", "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
    )  # pylint: disable=line-too-long
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class GenerateCostDetailsReportOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`generate_cost_details_report` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_operation_initial(
        self,
        scope: str,
        parameters: Union[_models.GenerateCostDetailsReportRequestDefinition, IO[bytes]],
        **kwargs: Any
    ) -> Optional[_models.CostDetailsOperationResults]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = self._serialize.body(parameters, "GenerateCostDetailsReportRequestDefinition")

        _request = build_create_operation_request(
            scope=scope,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request = _convert_request(_request)
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(
                _models.GenerateCostDetailsReportErrorResponse, pipeline_response
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_operation(
        self,
        scope: str,
        parameters: _models.GenerateCostDetailsReportRequestDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.CostDetailsOperationResults]:
        """This API is the replacement for all previously release Usage Details APIs. Request to generate
        a cost details report for the provided date range, billing period (Only enterprise customers)
        or Invoice Id asynchronously at a certain scope. The initial call to request a report will
        return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
        endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
        duration to wait before polling for the generated report. A call to poll the report operation
        will provide a 202 response with a 'Location' header if the operation is still in progress.
        Once the report generation operation completes, the polling endpoint will provide a 200
        response along with details on the report blob(s) that are available for download. The details
        on the file(s) available for download will be available in the polling response body. To
        Understand cost details (formerly known as usage details) fields found in files ,see
        https://learn.microsoft.com/en-us/azure/cost-management-billing/automate/understand-usage-details-fields.

        .. seealso::
           - https://docs.microsoft.com/en-us/rest/api/costmanagement/

        :param scope: The ARM Resource ID for subscription, billing account, or other billing
         scopes.Currently Resource Group and Management Group are not supported. For details, see
         https://aka.ms/costmgmt/scopes. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create cost details operation. Required.
        :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns either CostDetailsOperationResults or the result
         of cls(response)
        :rtype:
         ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_operation(
        self, scope: str, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.CostDetailsOperationResults]:
        """This API is the replacement for all previously release Usage Details APIs. Request to generate
        a cost details report for the provided date range, billing period (Only enterprise customers)
        or Invoice Id asynchronously at a certain scope. The initial call to request a report will
        return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
        endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
        duration to wait before polling for the generated report. A call to poll the report operation
        will provide a 202 response with a 'Location' header if the operation is still in progress.
        Once the report generation operation completes, the polling endpoint will provide a 200
        response along with details on the report blob(s) that are available for download. The details
        on the file(s) available for download will be available in the polling response body. To
        Understand cost details (formerly known as usage details) fields found in files ,see
        https://learn.microsoft.com/en-us/azure/cost-management-billing/automate/understand-usage-details-fields.

        .. seealso::
           - https://docs.microsoft.com/en-us/rest/api/costmanagement/

        :param scope: The ARM Resource ID for subscription, billing account, or other billing
         scopes.Currently Resource Group and Management Group are not supported. For details, see
         https://aka.ms/costmgmt/scopes. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create cost details operation. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns either CostDetailsOperationResults or the result
         of cls(response)
        :rtype:
         ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_operation(
        self,
        scope: str,
        parameters: Union[_models.GenerateCostDetailsReportRequestDefinition, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.CostDetailsOperationResults]:
        """This API is the replacement for all previously release Usage Details APIs. Request to generate
        a cost details report for the provided date range, billing period (Only enterprise customers)
        or Invoice Id asynchronously at a certain scope. The initial call to request a report will
        return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
        endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
        duration to wait before polling for the generated report. A call to poll the report operation
        will provide a 202 response with a 'Location' header if the operation is still in progress.
        Once the report generation operation completes, the polling endpoint will provide a 200
        response along with details on the report blob(s) that are available for download. The details
        on the file(s) available for download will be available in the polling response body. To
        Understand cost details (formerly known as usage details) fields found in files ,see
        https://learn.microsoft.com/en-us/azure/cost-management-billing/automate/understand-usage-details-fields.

        .. seealso::
           - https://docs.microsoft.com/en-us/rest/api/costmanagement/

        :param scope: The ARM Resource ID for subscription, billing account, or other billing
         scopes.Currently Resource Group and Management Group are not supported. For details, see
         https://aka.ms/costmgmt/scopes. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create cost details operation. Is either a
         GenerateCostDetailsReportRequestDefinition type or a IO[bytes] type. Required.
        :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
         or IO[bytes]
        :return: An instance of LROPoller that returns either CostDetailsOperationResults or the result
         of cls(response)
        :rtype:
         ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_operation_initial(
                scope=scope,
                parameters=parameters,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.CostDetailsOperationResults].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.CostDetailsOperationResults](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _get_operation_results_initial(
        self, scope: str, operation_id: str, **kwargs: Any
    ) -> Optional[_models.CostDetailsOperationResults]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)

        _request = build_get_operation_results_request(
            scope=scope,
            operation_id=operation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        _request = _convert_request(_request)
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_operation_results(
        self, scope: str, operation_id: str, **kwargs: Any
    ) -> LROPoller[_models.CostDetailsOperationResults]:
        """Get the result of the specified operation. This link is provided in the CostDetails creation
        request response Location header.

        :param scope: The ARM Resource ID for subscription, billing account, or other billing
         scopes.Currently Resource Group and Management Group are not supported. For details, see
         https://aka.ms/costmgmt/scopes. Required.
        :type scope: str
        :param operation_id: The target operation Id. Required.
        :type operation_id: str
        :return: An instance of LROPoller that returns either CostDetailsOperationResults or the result
         of cls(response)
        :rtype:
         ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_operation_results_initial(
                scope=scope,
                operation_id=operation_id,
                api_version=api_version,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.CostDetailsOperationResults].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.CostDetailsOperationResults](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )
