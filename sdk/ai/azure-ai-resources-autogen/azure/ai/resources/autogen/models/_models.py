# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
from typing import Any, Dict, List, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .. import _model_base
from .._model_base import rest_discriminator, rest_field
from ._enums import (
    CredentialType,
    DataType,
    ReferenceType,
    RunStepType,
    VectorStoreChunkingStrategyRequestType,
    VectorStoreChunkingStrategyResponseType,
)

if TYPE_CHECKING:
    from .. import _types, models as _models


class BaseCredential(_model_base.Model):
    """Base Credential definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AadCredential, ApiKeyCredential, SasCredential

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: Credential name. Required.
    :vartype name: str
    :ivar type: Required. Known values are: "ApiKey", "AAD", and "SAS".
    :vartype type: str or ~azure.ai.resources.autogen.models.CredentialType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    name: str = rest_field(visibility=["read"])
    """Credential name. Required."""
    type: str = rest_discriminator(name="type")
    """Required. Known values are: \"ApiKey\", \"AAD\", and \"SAS\"."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AadCredential(BaseCredential, discriminator="AAD"):
    """AAD Credential definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: Credential name. Required.
    :vartype name: str
    :ivar type: Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.AAD
    """

    type: Literal[CredentialType.AAD] = rest_discriminator(name="type")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=CredentialType.AAD, **kwargs)


class ApiKeyCredential(BaseCredential, discriminator="ApiKey"):
    """ApiKey Credential definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: Credential name. Required.
    :vartype name: str
    :ivar api_key: API Key. Required.
    :vartype api_key: str
    :ivar type: Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.API_KEY
    """

    api_key: str = rest_field(name="apiKey", visibility=["read"])
    """API Key. Required."""
    type: Literal[CredentialType.API_KEY] = rest_discriminator(name="type")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=CredentialType.API_KEY, **kwargs)


class InputData(_model_base.Model):
    """Abstract data class.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AppInsightsConfiguration, Dataset


    :ivar type: Discriminator property for InputData. Required. Default value is None.
    :vartype type: str
    :ivar id: Evaluation input data. Required.
    :vartype id: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """Discriminator property for InputData. Required. Default value is None."""
    id: str = rest_field()
    """Evaluation input data. Required."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AppInsightsConfiguration(InputData, discriminator="app_insights"):
    """Data Source for Application Insight.


    :ivar id: Evaluation input data. Required.
    :vartype id: str
    :ivar type: Required. Default value is "app_insights".
    :vartype type: str
    :ivar connection_string: Application Insight connection string. Required.
    :vartype connection_string: str
    :ivar query: Query to fetch data. Required.
    :vartype query: str
    """

    type: Literal["app_insights"] = rest_discriminator(name="type")  # type: ignore
    """Required. Default value is \"app_insights\"."""
    connection_string: str = rest_field(name="connectionString")
    """Application Insight connection string. Required."""
    query: str = rest_field()
    """Query to fetch data. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        connection_string: str,
        query: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="app_insights", **kwargs)


class ResourceBase(_model_base.Model):
    """ResourceBase definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    """

    description: Optional[str] = rest_field()
    """The asset description text."""
    properties: Optional[Dict[str, str]] = rest_field()
    """The asset property dictionary."""
    tags: Optional[Dict[str, str]] = rest_field()
    """Tag dictionary. Tags can be added, removed, and updated."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetBase(ResourceBase):
    """Base definition for an asset.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    """

    is_anonymous: Optional[bool] = rest_field(name="isAnonymous", visibility=["read", "create"])
    """If the name version are system generated (anonymous registration)."""
    is_archived: Optional[bool] = rest_field(name="isArchived", visibility=["read", "create", "update"])
    """Is the asset archived?."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetContainer(ResourceBase):
    """AssetContainer definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    """

    is_archived: Optional[bool] = rest_field(name="isArchived", visibility=["read", "create", "update"])
    """Is the asset archived?."""
    latest_version: Optional[str] = rest_field(name="latestVersion", visibility=["read"])
    """The latest version inside this container."""
    next_version: Optional[str] = rest_field(name="nextVersion", visibility=["read"])
    """The next auto incremental version."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetReferenceBase(_model_base.Model):
    """Base definition for asset references.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DataPathAssetReference, IdAssetReference, OutputPathAssetReference


    :ivar reference_type: Asset reference type. Required. Known values are: "Id", "DataPath", and
     "OutputPath".
    :vartype reference_type: str or ~azure.ai.resources.autogen.models.ReferenceType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    reference_type: str = rest_discriminator(name="referenceType")
    """Asset reference type. Required. Known values are: \"Id\", \"DataPath\", and \"OutputPath\"."""

    @overload
    def __init__(
        self,
        *,
        reference_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Assistant(_model_base.Model):
    """Represents an assistant that can call the model and use tools.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always assistant. Required. Default value is
     "assistant".
    :vartype object: str
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar name: The name of the assistant. Required.
    :vartype name: str
    :ivar description: The description of the assistant. Required.
    :vartype description: str
    :ivar model: The ID of the model to use. Required.
    :vartype model: str
    :ivar instructions: The system instructions for the assistant to use. Required.
    :vartype instructions: str
    :ivar tools: The collection of tools enabled for the assistant. Required.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar tool_resources: A set of resources that are used by the assistant's tools. The resources
     are specific to the type of tool. For example, the ``code_interpreter`` tool requires a list of
     file IDs, while the ``file_search`` tool requires a list of vector store IDs. Required.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.ToolResources
    :ivar temperature: What sampling temperature to use, between 0 and 2. Higher values like 0.8
     will make the output more random, while lower values like 0.2 will make it more focused and
     deterministic. Required.
    :vartype temperature: float
    :ivar top_p: An alternative to sampling with temperature, called nucleus sampling, where the
     model considers the results of the tokens with top_p probability mass. So 0.1 means only the
     tokens comprising the top 10% probability mass are considered. We generally recommend altering
     this or temperature but not both. Required.
    :vartype top_p: float
    :ivar response_format: The response format of the tool calls used by this assistant. Is one of
     the following types: str, Union[str, "_models.AssistantsApiResponseFormatMode"],
     AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["assistant"] = rest_field()
    """The object type, which is always assistant. Required. Default value is \"assistant\"."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    name: str = rest_field()
    """The name of the assistant. Required."""
    description: str = rest_field()
    """The description of the assistant. Required."""
    model: str = rest_field()
    """The ID of the model to use. Required."""
    instructions: str = rest_field()
    """The system instructions for the assistant to use. Required."""
    tools: List["_models.ToolDefinition"] = rest_field()
    """The collection of tools enabled for the assistant. Required."""
    tool_resources: "_models.ToolResources" = rest_field()
    """A set of resources that are used by the assistant's tools. The resources are specific to the
     type of tool. For example, the ``code_interpreter`` tool requires a list of file IDs, while the
     ``file_search`` tool requires a list of vector store IDs. Required."""
    temperature: float = rest_field()
    """What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic. Required."""
    top_p: float = rest_field()
    """An alternative to sampling with temperature, called nucleus sampling, where the model considers
     the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
     the top 10% probability mass are considered. We generally recommend altering this or
     temperature but not both. Required."""
    response_format: Optional["_types.AssistantsApiResponseFormatOption"] = rest_field()
    """The response format of the tool calls used by this assistant. Is one of the following types:
     str, Union[str, \"_models.AssistantsApiResponseFormatMode\"], AssistantsApiResponseFormat"""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        created_at: datetime.datetime,
        name: str,
        description: str,
        model: str,
        instructions: str,
        tools: List["_models.ToolDefinition"],
        tool_resources: "_models.ToolResources",
        temperature: float,
        top_p: float,
        metadata: Dict[str, str],
        response_format: Optional["_types.AssistantsApiResponseFormatOption"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["assistant"] = "assistant"


class AssistantCreationOptions(_model_base.Model):
    """The request details to use when creating a new assistant.

    All required parameters must be populated in order to send to server.

    :ivar model: The ID of the model to use. Required.
    :vartype model: str
    :ivar name: The name of the new assistant.
    :vartype name: str
    :ivar description: The description of the new assistant.
    :vartype description: str
    :ivar instructions: The system instructions for the new assistant to use.
    :vartype instructions: str
    :ivar tools: The collection of tools to enable for the new assistant.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar tool_resources: A set of resources that are used by the assistant's tools. The resources
     are specific to the type of tool. For example, the ``code_interpreter`` tool requires a list of
     file IDs, while the ``file_search`` tool requires a list of vector store IDs.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.CreateToolResourcesOptions
    :ivar temperature: What sampling temperature to use, between 0 and 2. Higher values like 0.8
     will make the output more random, while lower values like 0.2 will make it more focused and
     deterministic.
    :vartype temperature: float
    :ivar top_p: An alternative to sampling with temperature, called nucleus sampling, where the
     model considers the results of the tokens with top_p probability mass. So 0.1 means only the
     tokens comprising the top 10% probability mass are considered. We generally recommend altering
     this or temperature but not both.
    :vartype top_p: float
    :ivar response_format: The response format of the tool calls used by this assistant. Is one of
     the following types: str, Union[str, "_models.AssistantsApiResponseFormatMode"],
     AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    model: str = rest_field()
    """The ID of the model to use. Required."""
    name: Optional[str] = rest_field()
    """The name of the new assistant."""
    description: Optional[str] = rest_field()
    """The description of the new assistant."""
    instructions: Optional[str] = rest_field()
    """The system instructions for the new assistant to use."""
    tools: Optional[List["_models.ToolDefinition"]] = rest_field()
    """The collection of tools to enable for the new assistant."""
    tool_resources: Optional["_models.CreateToolResourcesOptions"] = rest_field()
    """A set of resources that are used by the assistant's tools. The resources are specific to the
     type of tool. For example, the ``code_interpreter`` tool requires a list of file IDs, while the
     ``file_search`` tool requires a list of vector store IDs."""
    temperature: Optional[float] = rest_field()
    """What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic."""
    top_p: Optional[float] = rest_field()
    """An alternative to sampling with temperature, called nucleus sampling, where the model considers
     the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
     the top 10% probability mass are considered. We generally recommend altering this or
     temperature but not both."""
    response_format: Optional["_types.AssistantsApiResponseFormatOption"] = rest_field()
    """The response format of the tool calls used by this assistant. Is one of the following types:
     str, Union[str, \"_models.AssistantsApiResponseFormatMode\"], AssistantsApiResponseFormat"""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        model: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        instructions: Optional[str] = None,
        tools: Optional[List["_models.ToolDefinition"]] = None,
        tool_resources: Optional["_models.CreateToolResourcesOptions"] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        response_format: Optional["_types.AssistantsApiResponseFormatOption"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssistantDeletionStatus(_model_base.Model):
    """The status of an assistant deletion operation.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The ID of the resource specified for deletion. Required.
    :vartype id: str
    :ivar deleted: A value indicating whether deletion was successful. Required.
    :vartype deleted: bool
    :ivar object: The object type, which is always 'assistant.deleted'. Required. Default value is
     "assistant.deleted".
    :vartype object: str
    """

    id: str = rest_field()
    """The ID of the resource specified for deletion. Required."""
    deleted: bool = rest_field()
    """A value indicating whether deletion was successful. Required."""
    object: Literal["assistant.deleted"] = rest_field()
    """The object type, which is always 'assistant.deleted'. Required. Default value is
     \"assistant.deleted\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        deleted: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["assistant.deleted"] = "assistant.deleted"


class AssistantsApiResponseFormat(_model_base.Model):
    """An object describing the expected output of the model. If ``json_object`` only ``function``
    type ``tools`` are allowed to be passed to the Run. If ``text`` the model can return text or
    any value needed.

    :ivar type: Must be one of ``text`` or ``json_object``. Known values are: "text" and
     "json_object".
    :vartype type: str or ~azure.ai.resources.autogen.models.ApiResponseFormat
    """

    type: Optional[Union[str, "_models.ApiResponseFormat"]] = rest_field()
    """Must be one of ``text`` or ``json_object``. Known values are: \"text\" and \"json_object\"."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.ApiResponseFormat"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssistantsNamedToolChoice(_model_base.Model):
    """Specifies a tool the model should use. Use to force the model to call a specific tool.


    :ivar type: the type of tool. If type is ``function``\\ , the function name must be set.
     Required. Known values are: "function", "code_interpreter", and "file_search".
    :vartype type: str or ~azure.ai.resources.autogen.models.AssistantsNamedToolChoiceType
    :ivar function: The name of the function to call.
    :vartype function: ~azure.ai.resources.autogen.models.FunctionName
    """

    type: Union[str, "_models.AssistantsNamedToolChoiceType"] = rest_field()
    """the type of tool. If type is ``function``\ , the function name must be set. Required. Known
     values are: \"function\", \"code_interpreter\", and \"file_search\"."""
    function: Optional["_models.FunctionName"] = rest_field()
    """The name of the function to call."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.AssistantsNamedToolChoiceType"],
        function: Optional["_models.FunctionName"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssistantThread(_model_base.Model):
    """Information about a single thread associated with an assistant.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always 'thread'. Required. Default value is "thread".
    :vartype object: str
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar tool_resources: A set of resources that are made available to the assistant's tools in
     this thread. The resources are specific to the type of tool. For example, the
     ``code_interpreter`` tool requires a list of file IDs, while the ``file_search`` tool requires
     a list of vector store IDs. Required.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.ToolResources
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["thread"] = rest_field()
    """The object type, which is always 'thread'. Required. Default value is \"thread\"."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    tool_resources: "_models.ToolResources" = rest_field()
    """A set of resources that are made available to the assistant's tools in this thread. The
     resources are specific to the type of tool. For example, the ``code_interpreter`` tool requires
     a list of file IDs, while the ``file_search`` tool requires a list of vector store IDs.
     Required."""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        created_at: datetime.datetime,
        tool_resources: "_models.ToolResources",
        metadata: Dict[str, str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["thread"] = "thread"


class AssistantThreadCreationOptions(_model_base.Model):
    """The details used to create a new assistant thread.

    :ivar messages: The initial messages to associate with the new thread.
    :vartype messages: list[~azure.ai.resources.autogen.models.ThreadMessageOptions]
    :ivar tool_resources: A set of resources that are made available to the assistant's tools in
     this thread. The resources are specific to the type of tool. For example, the
     ``code_interpreter`` tool requires a list of file IDs, while the ``file_search`` tool requires
     a list of vector store IDs.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.CreateToolResourcesOptions
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    messages: Optional[List["_models.ThreadMessageOptions"]] = rest_field()
    """The initial messages to associate with the new thread."""
    tool_resources: Optional["_models.CreateToolResourcesOptions"] = rest_field()
    """A set of resources that are made available to the assistant's tools in this thread. The
     resources are specific to the type of tool. For example, the ``code_interpreter`` tool requires
     a list of file IDs, while the ``file_search`` tool requires a list of vector store IDs."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        messages: Optional[List["_models.ThreadMessageOptions"]] = None,
        tool_resources: Optional["_models.CreateToolResourcesOptions"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EvaluationTarget(_model_base.Model):
    """Evaluation Target.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BaseModel


    :ivar type: Discriminator property for EvaluationTarget. Required. Default value is None.
    :vartype type: str
    :ivar name: Name of the evaluation target.
    :vartype name: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """Discriminator property for EvaluationTarget. Required. Default value is None."""
    name: Optional[str] = rest_field()
    """Name of the evaluation target."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BaseModel(EvaluationTarget, discriminator="base_model"):
    """Base Model and prompt for evaluation.


    :ivar name: Name of the evaluation target.
    :vartype name: str
    :ivar model_config: Base model for evaluation. Required.
    :vartype model_config: dict[str, dict[str, any]]
    :ivar prompt: System prompt to be used with base model. This property will hold prompt asset
     id. Required.
    :vartype prompt: str
    :ivar parameters: parameters for evaluation. Required.
    :vartype parameters: dict[str, str]
    :ivar type: Required. Default value is "base_model".
    :vartype type: str
    """

    model_config: Dict[str, Dict[str, Any]] = rest_field()
    """Base model for evaluation. Required."""
    prompt: str = rest_field()
    """System prompt to be used with base model. This property will hold prompt asset id. Required."""
    parameters: Dict[str, str] = rest_field()
    """parameters for evaluation. Required."""
    type: Literal["base_model"] = rest_discriminator(name="type")  # type: ignore
    """Required. Default value is \"base_model\"."""

    @overload
    def __init__(
        self,
        *,
        model_config: Dict[str, Dict[str, Any]],
        prompt: str,
        parameters: Dict[str, str],
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="base_model", **kwargs)


class EndpointDeploymentBase(_model_base.Model):
    """Base definition for endpoint deployment.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.ai.resources.autogen.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    """

    code_configuration: Optional["_models.CodeConfiguration"] = rest_field(name="codeConfiguration")
    """Code configuration for the endpoint deployment."""
    description: Optional[str] = rest_field()
    """Description of the endpoint deployment."""
    environment_id: Optional[str] = rest_field(name="environmentId")
    """ARM resource ID or AssetId of the environment specification for the endpoint deployment."""
    environment_variables: Optional[Dict[str, str]] = rest_field(name="environmentVariables")
    """Environment variables configuration for the deployment."""
    properties: Optional[Dict[str, str]] = rest_field()
    """Property dictionary. Properties can be added, but not removed or altered."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchDeployment(EndpointDeploymentBase):
    """Batch inference settings per deployment.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.ai.resources.autogen.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar compute: Compute target for batch inference operation.
    :vartype compute: str
    :ivar deployment_configuration: Properties relevant to different deployment types.
    :vartype deployment_configuration:
     ~azure.ai.resources.autogen.models.BatchDeploymentConfiguration
    :ivar error_threshold: Error threshold, if the error count for the entire input goes above this
     value, the batch inference will be aborted. Range is [-1, int.MaxValue]. For FileDataset, this
     value is the count of file failures. For TabularDataset, this value is the count of record
     failures. If set to -1 (the lower bound), all failures during batch inference will be ignored.
    :vartype error_threshold: int
    :ivar logging_level: Logging level for batch inference operation. Known values are: "Info",
     "Warning", and "Debug".
    :vartype logging_level: str or ~azure.ai.resources.autogen.models.BatchLoggingLevel
    :ivar max_concurrency_per_instance: Indicates maximum number of parallelism per instance.
    :vartype max_concurrency_per_instance: int
    :ivar mini_batch_size: Size of the mini-batch passed to each batch invocation. For FileDataset,
     this is the number of files per mini-batch. For TabularDataset, this is the size of the records
     in bytes, per mini-batch.
    :vartype mini_batch_size: int
    :ivar model: Reference to the model asset for the endpoint deployment.
    :vartype model: ~azure.ai.resources.autogen.models.AssetReferenceBase
    :ivar output_action: Indicates how the output will be organized. Known values are:
     "SummaryOnly" and "AppendRow".
    :vartype output_action: str or ~azure.ai.resources.autogen.models.BatchOutputAction
    :ivar output_file_name: Customized output file name for append_row output action.
    :vartype output_file_name: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.ai.resources.autogen.models.DeploymentProvisioningState
    :ivar resources: Indicates compute configuration for the job. If not provided, will default to
     the defaults defined in ResourceConfiguration.
    :vartype resources: ~azure.ai.resources.autogen.models.DeploymentResourceConfiguration
    :ivar retry_settings: Retry Settings for the batch inference operation. If not provided, will
     default to the defaults defined in BatchRetrySettings.
    :vartype retry_settings: ~azure.ai.resources.autogen.models.BatchRetrySettings
    """

    compute: Optional[str] = rest_field()
    """Compute target for batch inference operation."""
    deployment_configuration: Optional["_models.BatchDeploymentConfiguration"] = rest_field(
        name="deploymentConfiguration"
    )
    """Properties relevant to different deployment types."""
    error_threshold: Optional[int] = rest_field(name="errorThreshold")
    """Error threshold, if the error count for the entire input goes above this value, the batch
     inference will be aborted. Range is [-1, int.MaxValue]. For FileDataset, this value is the
     count of file failures. For TabularDataset, this value is the count of record failures. If set
     to -1 (the lower bound), all failures during batch inference will be ignored."""
    logging_level: Optional[Union[str, "_models.BatchLoggingLevel"]] = rest_field(name="loggingLevel")
    """Logging level for batch inference operation. Known values are: \"Info\", \"Warning\", and
     \"Debug\"."""
    max_concurrency_per_instance: Optional[int] = rest_field(name="maxConcurrencyPerInstance")
    """Indicates maximum number of parallelism per instance."""
    mini_batch_size: Optional[int] = rest_field(name="miniBatchSize")
    """Size of the mini-batch passed to each batch invocation. For FileDataset, this is the number of
     files per mini-batch. For TabularDataset, this is the size of the records in bytes, per
     mini-batch."""
    model: Optional["_models.AssetReferenceBase"] = rest_field()
    """Reference to the model asset for the endpoint deployment."""
    output_action: Optional[Union[str, "_models.BatchOutputAction"]] = rest_field(name="outputAction")
    """Indicates how the output will be organized. Known values are: \"SummaryOnly\" and
     \"AppendRow\"."""
    output_file_name: Optional[str] = rest_field(name="outputFileName")
    """Customized output file name for append_row output action."""
    provisioning_state: Optional[Union[str, "_models.DeploymentProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint deployment. Known values are: \"Creating\", \"Deleting\",
     \"Scaling\", \"Updating\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    resources: Optional["_models.DeploymentResourceConfiguration"] = rest_field()
    """Indicates compute configuration for the job. If not provided, will default to the defaults
     defined in ResourceConfiguration."""
    retry_settings: Optional["_models.BatchRetrySettings"] = rest_field(name="retrySettings")
    """Retry Settings for the batch inference operation. If not provided, will default to the defaults
     defined in BatchRetrySettings."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        compute: Optional[str] = None,
        deployment_configuration: Optional["_models.BatchDeploymentConfiguration"] = None,
        error_threshold: Optional[int] = None,
        logging_level: Optional[Union[str, "_models.BatchLoggingLevel"]] = None,
        max_concurrency_per_instance: Optional[int] = None,
        mini_batch_size: Optional[int] = None,
        model: Optional["_models.AssetReferenceBase"] = None,
        output_action: Optional[Union[str, "_models.BatchOutputAction"]] = None,
        output_file_name: Optional[str] = None,
        resources: Optional["_models.DeploymentResourceConfiguration"] = None,
        retry_settings: Optional["_models.BatchRetrySettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchDeploymentConfiguration(_model_base.Model):
    """Properties relevant to different deployment types.


    :ivar deployment_configuration_type: The batch deployment configuration type. Required. Known
     values are: "Model" and "PipelineComponent".
    :vartype deployment_configuration_type: str or
     ~azure.ai.resources.autogen.models.BatchDeploymentConfigurationType
    """

    deployment_configuration_type: Union[str, "_models.BatchDeploymentConfigurationType"] = rest_discriminator(
        name="deploymentConfigurationType"
    )
    """The batch deployment configuration type. Required. Known values are: \"Model\" and
     \"PipelineComponent\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointBase(_model_base.Model):
    """Inference Endpoint base definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar auth_mode: [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure
     Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.ai.resources.autogen.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint. This property will
     always be returned as null. AuthKey values must be retrieved using the ListKeys API.
    :vartype keys_property: ~azure.ai.resources.autogen.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    """

    auth_mode: Union[str, "_models.EndpointAuthMode"] = rest_field(name="authMode")
    """[Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning
     token-based authentication. 'Key' doesn't expire but 'AMLToken' does. Required. Known values
     are: \"AMLToken\", \"Key\", and \"AADToken\"."""
    description: Optional[str] = rest_field()
    """Description of the inference endpoint."""
    keys_property: Optional["_models.EndpointAuthKeys"] = rest_field(name="keys", visibility=["create"])
    """EndpointAuthKeys to set initially on an Endpoint. This property will always be returned as
     null. AuthKey values must be retrieved using the ListKeys API."""
    properties: Optional[Dict[str, str]] = rest_field()
    """Property dictionary. Properties can be added, but not removed or altered."""
    scoring_uri: Optional[str] = rest_field(name="scoringUri", visibility=["read"])
    """Endpoint URI."""
    swagger_uri: Optional[str] = rest_field(name="swaggerUri", visibility=["read"])
    """Endpoint Swagger URI."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchEndpoint(EndpointBase):
    """Batch endpoint configuration.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar auth_mode: [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure
     Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.ai.resources.autogen.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint. This property will
     always be returned as null. AuthKey values must be retrieved using the ListKeys API.
    :vartype keys_property: ~azure.ai.resources.autogen.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    :ivar defaults: Default values for Batch Endpoint.
    :vartype defaults: ~azure.ai.resources.autogen.models.BatchEndpointDefaults
    :ivar provisioning_state: Provisioning state for the endpoint. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.ai.resources.autogen.models.EndpointProvisioningState
    """

    defaults: Optional["_models.BatchEndpointDefaults"] = rest_field()
    """Default values for Batch Endpoint."""
    provisioning_state: Optional[Union[str, "_models.EndpointProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[Dict[str, str]] = None,
        defaults: Optional["_models.BatchEndpointDefaults"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchEndpointDefaults(_model_base.Model):
    """Batch endpoint default values.

    :ivar deployment_name: Name of the deployment that will be default for the endpoint. This
     deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
    :vartype deployment_name: str
    """

    deployment_name: Optional[str] = rest_field(name="deploymentName")
    """Name of the deployment that will be default for the endpoint. This deployment will end up
     getting 100% traffic when the endpoint scoring URL is invoked."""

    @overload
    def __init__(
        self,
        *,
        deployment_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchRetrySettings(_model_base.Model):
    """Retry settings for a batch inference operation.

    :ivar max_retries: Maximum retry count for a mini-batch.
    :vartype max_retries: int
    :ivar timeout: Invocation timeout for a mini-batch, in ISO 8601 format.
    :vartype timeout: ~datetime.timedelta
    """

    max_retries: Optional[int] = rest_field(name="maxRetries")
    """Maximum retry count for a mini-batch."""
    timeout: Optional[datetime.timedelta] = rest_field()
    """Invocation timeout for a mini-batch, in ISO 8601 format."""

    @overload
    def __init__(
        self,
        *,
        max_retries: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeConfiguration(_model_base.Model):
    """Configuration for a scoring code asset.


    :ivar code_id: ARM resource ID of the code asset.
    :vartype code_id: str
    :ivar scoring_script: [Required] The script to execute on startup. eg. 'score.py'. Required.
    :vartype scoring_script: str
    """

    code_id: Optional[str] = rest_field(name="codeId", visibility=["read", "create"])
    """ARM resource ID of the code asset."""
    scoring_script: str = rest_field(name="scoringScript", visibility=["read", "create"])
    """[Required] The script to execute on startup. eg. 'score.py'. Required."""

    @overload
    def __init__(
        self,
        *,
        scoring_script: str,
        code_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ToolDefinition(_model_base.Model):
    """An abstract representation of an input tool definition that an assistant can use.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CodeInterpreterToolDefinition, FileSearchToolDefinition, FunctionToolDefinition


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeInterpreterToolDefinition(ToolDefinition, discriminator="code_interpreter"):
    """The input definition information for a code interpreter tool as used to configure an assistant.


    :ivar type: The object type, which is always 'code_interpreter'. Required. Default value is
     "code_interpreter".
    :vartype type: str
    """

    type: Literal["code_interpreter"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'code_interpreter'. Required. Default value is
     \"code_interpreter\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="code_interpreter", **kwargs)


class CodeInterpreterToolResource(_model_base.Model):
    """A set of resources that are used by the ``code_interpreter`` tool.


    :ivar file_ids: A list of file IDs made available to the ``code_interpreter`` tool. There can
     be a maximum of 20 files associated with the tool. Required.
    :vartype file_ids: list[str]
    """

    file_ids: List[str] = rest_field()
    """A list of file IDs made available to the ``code_interpreter`` tool. There can be a maximum of
     20 files associated with the tool. Required."""

    @overload
    def __init__(
        self,
        *,
        file_ids: List[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Collection(_model_base.Model):
    """Collection definition.

    :ivar client_id: The msi client id used to collect logging to blob storage. If it's
     null,backend will pick a registered endpoint identity to auth.
    :vartype client_id: str
    :ivar data_collection_mode: Enable or disable data collection. Known values are: "Enabled" and
     "Disabled".
    :vartype data_collection_mode: str or ~azure.ai.resources.autogen.models.DataCollectionMode
    :ivar data_id: The data asset arm resource id. Client side will ensure data asset is pointing
     to the blob storage, and backend will collect data to the blob storage.
    :vartype data_id: str
    :ivar sampling_rate: The sampling rate for collection. Sampling rate 1.0 means we collect 100%
     of data by default.
    :vartype sampling_rate: float
    """

    client_id: Optional[str] = rest_field(name="clientId")
    """The msi client id used to collect logging to blob storage. If it's null,backend will pick a
     registered endpoint identity to auth."""
    data_collection_mode: Optional[Union[str, "_models.DataCollectionMode"]] = rest_field(name="dataCollectionMode")
    """Enable or disable data collection. Known values are: \"Enabled\" and \"Disabled\"."""
    data_id: Optional[str] = rest_field(name="dataId")
    """The data asset arm resource id. Client side will ensure data asset is pointing to the blob
     storage, and backend will collect data to the blob storage."""
    sampling_rate: Optional[float] = rest_field(name="samplingRate")
    """The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default."""

    @overload
    def __init__(
        self,
        *,
        client_id: Optional[str] = None,
        data_collection_mode: Optional[Union[str, "_models.DataCollectionMode"]] = None,
        data_id: Optional[str] = None,
        sampling_rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Connection(_model_base.Model):
    """Connection Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: Name of the connection. Required.
    :vartype name: str
    :ivar type: The type of connection, such as AzureOpenAI, AIServices, AISearch, etc. Required.
    :vartype type: str
    :ivar target: The URL endpoint of the external resource being connected to. Required.
    :vartype target: str
    :ivar credentials: Credential used to connect to the external resource. Required.
    :vartype credentials: ~azure.ai.resources.autogen.models.BaseCredential
    :ivar system_data: Metadata containing createdBy and modifiedBy information.
    :vartype system_data: ~azure.ai.resources.autogen.models.SystemData
    """

    name: str = rest_field(visibility=["read"])
    """Name of the connection. Required."""
    type: str = rest_field(visibility=["read"])
    """The type of connection, such as AzureOpenAI, AIServices, AISearch, etc. Required."""
    target: str = rest_field()
    """The URL endpoint of the external resource being connected to. Required."""
    credentials: "_models.BaseCredential" = rest_field()
    """Credential used to connect to the external resource. Required."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Metadata containing createdBy and modifiedBy information."""

    @overload
    def __init__(
        self,
        *,
        target: str,
        credentials: "_models.BaseCredential",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateAndRunThreadOptions(_model_base.Model):
    """The details used when creating and immediately running a new assistant thread.

    All required parameters must be populated in order to send to server.

    :ivar assistant_id: The ID of the assistant for which the thread should be created. Required.
    :vartype assistant_id: str
    :ivar thread: The details used to create the new thread. If no thread is provided, an empty one
     will be created.
    :vartype thread: ~azure.ai.resources.autogen.models.AssistantThreadCreationOptions
    :ivar model: The overridden model that the assistant should use to run the thread.
    :vartype model: str
    :ivar instructions: The overridden system instructions the assistant should use to run the
     thread.
    :vartype instructions: str
    :ivar tools: The overridden list of enabled tools the assistant should use to run the thread.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar tool_resources: Override the tools the assistant can use for this run. This is useful for
     modifying the behavior on a per-run basis.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.UpdateToolResourcesOptions
    :ivar stream: If ``true``\\ , returns a stream of events that happen during the Run as
     server-sent events,
     terminating when the Run enters a terminal state with a ``data: [DONE]`` message.
    :vartype stream: bool
    :ivar temperature: What sampling temperature to use, between 0 and 2. Higher values like 0.8
     will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic.
    :vartype temperature: float
    :ivar top_p: An alternative to sampling with temperature, called nucleus sampling, where the
     model
     considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens
     comprising the top 10% probability mass are considered.

     We generally recommend altering this or temperature but not both.
    :vartype top_p: float
    :ivar max_prompt_tokens: The maximum number of prompt tokens that may be used over the course
     of the run. The run will make a best effort to use only
     the number of prompt tokens specified, across multiple turns of the run. If the run exceeds
     the number of prompt tokens specified,
     the run will end with status ``incomplete``. See ``incomplete_details`` for more info.
    :vartype max_prompt_tokens: int
    :ivar max_completion_tokens: The maximum number of completion tokens that may be used over the
     course of the run. The run will make a best effort to use only
     the number of completion tokens specified, across multiple turns of the run. If the run
     exceeds the number of completion tokens
     specified, the run will end with status ``incomplete``. See ``incomplete_details`` for more
     info.
    :vartype max_completion_tokens: int
    :ivar truncation_strategy: The strategy to use for dropping messages as the context windows
     moves forward.
    :vartype truncation_strategy: ~azure.ai.resources.autogen.models.TruncationObject
    :ivar tool_choice: Controls whether or not and which tool is called by the model. Is one of the
     following types: str, Union[str, "_models.AssistantsApiToolChoiceOptionMode"],
     AssistantsNamedToolChoice
    :vartype tool_choice: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiToolChoiceOptionMode or
     ~azure.ai.resources.autogen.models.AssistantsNamedToolChoice
    :ivar response_format: Specifies the format that the model must output. Is one of the following
     types: str, Union[str, "_models.AssistantsApiResponseFormatMode"], AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    assistant_id: str = rest_field()
    """The ID of the assistant for which the thread should be created. Required."""
    thread: Optional["_models.AssistantThreadCreationOptions"] = rest_field()
    """The details used to create the new thread. If no thread is provided, an empty one will be
     created."""
    model: Optional[str] = rest_field()
    """The overridden model that the assistant should use to run the thread."""
    instructions: Optional[str] = rest_field()
    """The overridden system instructions the assistant should use to run the thread."""
    tools: Optional[List["_models.ToolDefinition"]] = rest_field()
    """The overridden list of enabled tools the assistant should use to run the thread."""
    tool_resources: Optional["_models.UpdateToolResourcesOptions"] = rest_field()
    """Override the tools the assistant can use for this run. This is useful for modifying the
     behavior on a per-run basis."""
    stream: Optional[bool] = rest_field()
    """If ``true``\ , returns a stream of events that happen during the Run as server-sent events,
     terminating when the Run enters a terminal state with a ``data: [DONE]`` message."""
    temperature: Optional[float] = rest_field()
    """What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic."""
    top_p: Optional[float] = rest_field()
    """An alternative to sampling with temperature, called nucleus sampling, where the model
     considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens
     comprising the top 10% probability mass are considered.
     
     We generally recommend altering this or temperature but not both."""
    max_prompt_tokens: Optional[int] = rest_field()
    """The maximum number of prompt tokens that may be used over the course of the run. The run will
     make a best effort to use only
     the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the
     number of prompt tokens specified,
     the run will end with status ``incomplete``. See ``incomplete_details`` for more info."""
    max_completion_tokens: Optional[int] = rest_field()
    """The maximum number of completion tokens that may be used over the course of the run. The run
     will make a best effort to use only
     the number of completion tokens specified, across multiple turns of the run. If the run exceeds
     the number of completion tokens
     specified, the run will end with status ``incomplete``. See ``incomplete_details`` for more
     info."""
    truncation_strategy: Optional["_models.TruncationObject"] = rest_field()
    """The strategy to use for dropping messages as the context windows moves forward."""
    tool_choice: Optional["_types.AssistantsApiToolChoiceOption"] = rest_field()
    """Controls whether or not and which tool is called by the model. Is one of the following types:
     str, Union[str, \"_models.AssistantsApiToolChoiceOptionMode\"], AssistantsNamedToolChoice"""
    response_format: Optional["_types.AssistantsApiResponseFormatOption"] = rest_field()
    """Specifies the format that the model must output. Is one of the following types: str, Union[str,
     \"_models.AssistantsApiResponseFormatMode\"], AssistantsApiResponseFormat"""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        assistant_id: str,
        thread: Optional["_models.AssistantThreadCreationOptions"] = None,
        model: Optional[str] = None,
        instructions: Optional[str] = None,
        tools: Optional[List["_models.ToolDefinition"]] = None,
        tool_resources: Optional["_models.UpdateToolResourcesOptions"] = None,
        stream: Optional[bool] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        max_prompt_tokens: Optional[int] = None,
        max_completion_tokens: Optional[int] = None,
        truncation_strategy: Optional["_models.TruncationObject"] = None,
        tool_choice: Optional["_types.AssistantsApiToolChoiceOption"] = None,
        response_format: Optional["_types.AssistantsApiResponseFormatOption"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateCodeInterpreterToolResourceOptions(_model_base.Model):
    """A set of resources that will be used by the ``code_interpreter`` tool. Request object.

    :ivar file_ids: A list of file IDs made available to the ``code_interpreter`` tool.
    :vartype file_ids: list[str]
    """

    file_ids: Optional[List[str]] = rest_field()
    """A list of file IDs made available to the ``code_interpreter`` tool."""

    @overload
    def __init__(
        self,
        *,
        file_ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateFileSearchToolResourceVectorStoreOptions(_model_base.Model):  # pylint: disable=name-too-long
    """File IDs associated to the vector store to be passed to the helper.

    All required parameters must be populated in order to send to server.

    :ivar file_ids: A list of file IDs to add to the vector store. There can be a maximum of 10000
     files in a vector store. Required.
    :vartype file_ids: list[str]
    :ivar chunking_strategy: The chunking strategy used to chunk the file(s). If not set, will use
     the ``auto`` strategy. Required.
    :vartype chunking_strategy:
     ~azure.ai.resources.autogen.models.VectorStoreChunkingStrategyRequest
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    file_ids: List[str] = rest_field()
    """A list of file IDs to add to the vector store. There can be a maximum of 10000 files in a
     vector store. Required."""
    chunking_strategy: "_models.VectorStoreChunkingStrategyRequest" = rest_field()
    """The chunking strategy used to chunk the file(s). If not set, will use the ``auto`` strategy.
     Required."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        file_ids: List[str],
        chunking_strategy: "_models.VectorStoreChunkingStrategyRequest",
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateRunOptions(_model_base.Model):
    """The details used when creating a new run of an assistant thread.

    All required parameters must be populated in order to send to server.

    :ivar assistant_id: The ID of the assistant that should run the thread. Required.
    :vartype assistant_id: str
    :ivar model: The overridden model name that the assistant should use to run the thread.
    :vartype model: str
    :ivar instructions: The overridden system instructions that the assistant should use to run the
     thread.
    :vartype instructions: str
    :ivar additional_instructions: Additional instructions to append at the end of the instructions
     for the run. This is useful for modifying the behavior
     on a per-run basis without overriding other instructions.
    :vartype additional_instructions: str
    :ivar additional_messages: Adds additional messages to the thread before creating the run.
    :vartype additional_messages: list[~azure.ai.resources.autogen.models.ThreadMessage]
    :ivar tools: The overridden list of enabled tools that the assistant should use to run the
     thread.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar stream: If ``true``\\ , returns a stream of events that happen during the Run as
     server-sent events,
     terminating when the Run enters a terminal state with a ``data: [DONE]`` message.
    :vartype stream: bool
    :ivar temperature: What sampling temperature to use, between 0 and 2. Higher values like 0.8
     will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic.
    :vartype temperature: float
    :ivar top_p: An alternative to sampling with temperature, called nucleus sampling, where the
     model
     considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens
     comprising the top 10% probability mass are considered.

     We generally recommend altering this or temperature but not both.
    :vartype top_p: float
    :ivar max_prompt_tokens: The maximum number of prompt tokens that may be used over the course
     of the run. The run will make a best effort to use only
     the number of prompt tokens specified, across multiple turns of the run. If the run exceeds
     the number of prompt tokens specified,
     the run will end with status ``incomplete``. See ``incomplete_details`` for more info.
    :vartype max_prompt_tokens: int
    :ivar max_completion_tokens: The maximum number of completion tokens that may be used over the
     course of the run. The run will make a best effort
     to use only the number of completion tokens specified, across multiple turns of the run. If
     the run exceeds the number of
     completion tokens specified, the run will end with status ``incomplete``. See
     ``incomplete_details`` for more info.
    :vartype max_completion_tokens: int
    :ivar truncation_strategy: The strategy to use for dropping messages as the context windows
     moves forward.
    :vartype truncation_strategy: ~azure.ai.resources.autogen.models.TruncationObject
    :ivar tool_choice: Controls whether or not and which tool is called by the model. Is one of the
     following types: str, Union[str, "_models.AssistantsApiToolChoiceOptionMode"],
     AssistantsNamedToolChoice
    :vartype tool_choice: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiToolChoiceOptionMode or
     ~azure.ai.resources.autogen.models.AssistantsNamedToolChoice
    :ivar response_format: Specifies the format that the model must output. Is one of the following
     types: str, Union[str, "_models.AssistantsApiResponseFormatMode"], AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    assistant_id: str = rest_field()
    """The ID of the assistant that should run the thread. Required."""
    model: Optional[str] = rest_field()
    """The overridden model name that the assistant should use to run the thread."""
    instructions: Optional[str] = rest_field()
    """The overridden system instructions that the assistant should use to run the thread."""
    additional_instructions: Optional[str] = rest_field()
    """Additional instructions to append at the end of the instructions for the run. This is useful
     for modifying the behavior
     on a per-run basis without overriding other instructions."""
    additional_messages: Optional[List["_models.ThreadMessage"]] = rest_field()
    """Adds additional messages to the thread before creating the run."""
    tools: Optional[List["_models.ToolDefinition"]] = rest_field()
    """The overridden list of enabled tools that the assistant should use to run the thread."""
    stream: Optional[bool] = rest_field()
    """If ``true``\ , returns a stream of events that happen during the Run as server-sent events,
     terminating when the Run enters a terminal state with a ``data: [DONE]`` message."""
    temperature: Optional[float] = rest_field()
    """What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic."""
    top_p: Optional[float] = rest_field()
    """An alternative to sampling with temperature, called nucleus sampling, where the model
     considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens
     comprising the top 10% probability mass are considered.
     
     We generally recommend altering this or temperature but not both."""
    max_prompt_tokens: Optional[int] = rest_field()
    """The maximum number of prompt tokens that may be used over the course of the run. The run will
     make a best effort to use only
     the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the
     number of prompt tokens specified,
     the run will end with status ``incomplete``. See ``incomplete_details`` for more info."""
    max_completion_tokens: Optional[int] = rest_field()
    """The maximum number of completion tokens that may be used over the course of the run. The run
     will make a best effort
     to use only the number of completion tokens specified, across multiple turns of the run. If the
     run exceeds the number of
     completion tokens specified, the run will end with status ``incomplete``. See
     ``incomplete_details`` for more info."""
    truncation_strategy: Optional["_models.TruncationObject"] = rest_field()
    """The strategy to use for dropping messages as the context windows moves forward."""
    tool_choice: Optional["_types.AssistantsApiToolChoiceOption"] = rest_field()
    """Controls whether or not and which tool is called by the model. Is one of the following types:
     str, Union[str, \"_models.AssistantsApiToolChoiceOptionMode\"], AssistantsNamedToolChoice"""
    response_format: Optional["_types.AssistantsApiResponseFormatOption"] = rest_field()
    """Specifies the format that the model must output. Is one of the following types: str, Union[str,
     \"_models.AssistantsApiResponseFormatMode\"], AssistantsApiResponseFormat"""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        assistant_id: str,
        model: Optional[str] = None,
        instructions: Optional[str] = None,
        additional_instructions: Optional[str] = None,
        additional_messages: Optional[List["_models.ThreadMessage"]] = None,
        tools: Optional[List["_models.ToolDefinition"]] = None,
        stream: Optional[bool] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        max_prompt_tokens: Optional[int] = None,
        max_completion_tokens: Optional[int] = None,
        truncation_strategy: Optional["_models.TruncationObject"] = None,
        tool_choice: Optional["_types.AssistantsApiToolChoiceOption"] = None,
        response_format: Optional["_types.AssistantsApiResponseFormatOption"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateToolResourcesOptions(_model_base.Model):
    """Request object. A set of resources that are used by the assistant's tools. The resources are
    specific to the type of tool. For example, the ``code_interpreter`` tool requires a list of
    file IDs, while the ``file_search`` tool requires a list of vector store IDs.

    :ivar code_interpreter: A list of file IDs made available to the ``code_interpreter`` tool.
     There can be a maximum of 20 files associated with the tool.
    :vartype code_interpreter:
     ~azure.ai.resources.autogen.models.CreateCodeInterpreterToolResourceOptions
    :ivar file_search: A list of vector stores or their IDs made available to the ``file_search``
     tool. Is either a [str] type or a [CreateFileSearchToolResourceVectorStoreOptions] type.
    :vartype file_search: list[str] or
     list[~azure.ai.resources.autogen.models.CreateFileSearchToolResourceVectorStoreOptions]
    """

    code_interpreter: Optional["_models.CreateCodeInterpreterToolResourceOptions"] = rest_field()
    """A list of file IDs made available to the ``code_interpreter`` tool. There can be a maximum of
     20 files associated with the tool."""
    file_search: Optional["_types.CreateFileSearchToolResourceOptions"] = rest_field()
    """A list of vector stores or their IDs made available to the ``file_search`` tool. Is either a
     [str] type or a [CreateFileSearchToolResourceVectorStoreOptions] type."""

    @overload
    def __init__(
        self,
        *,
        code_interpreter: Optional["_models.CreateCodeInterpreterToolResourceOptions"] = None,
        file_search: Optional["_types.CreateFileSearchToolResourceOptions"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataCollector(_model_base.Model):
    """Data collector definition.


    :ivar collections: [Required] The collection configuration. Each collection has it own
     configuration to collect model data and the name of collection can be arbitrary string. Model
     data collector can be used for either payload logging or custom logging or both of them.
     Collection request and response are reserved for payload logging, others are for custom
     logging. Required.
    :vartype collections: dict[str, ~azure.ai.resources.autogen.models.Collection]
    :ivar request_logging: The request logging configuration for mdc, it includes advanced logging
     settings for all collections. It's optional.
    :vartype request_logging: ~azure.ai.resources.autogen.models.RequestLogging
    :ivar rolling_rate: When model data is collected to blob storage, we need to roll the data to
     different path to avoid logging all of them in a single blob file. If the rolling rate is hour,
     all data will be collected in the blob path /yyyy/MM/dd/HH/. If it's day, all data will be
     collected in blob path /yyyy/MM/dd/. The other benefit of rolling path is that model monitoring
     ui is able to select a time range of data very quickly. Known values are: "Year", "Month",
     "Day", "Hour", and "Minute".
    :vartype rolling_rate: str or ~azure.ai.resources.autogen.models.RollingRateType
    """

    collections: Dict[str, "_models.Collection"] = rest_field()
    """[Required] The collection configuration. Each collection has it own configuration to collect
     model data and the name of collection can be arbitrary string. Model data collector can be used
     for either payload logging or custom logging or both of them. Collection request and response
     are reserved for payload logging, others are for custom logging. Required."""
    request_logging: Optional["_models.RequestLogging"] = rest_field(name="requestLogging")
    """The request logging configuration for mdc, it includes advanced logging settings for all
     collections. It's optional."""
    rolling_rate: Optional[Union[str, "_models.RollingRateType"]] = rest_field(name="rollingRate")
    """When model data is collected to blob storage, we need to roll the data to different path to
     avoid logging all of them in a single blob file. If the rolling rate is hour, all data will be
     collected in the blob path /yyyy/MM/dd/HH/. If it's day, all data will be collected in blob
     path /yyyy/MM/dd/. The other benefit of rolling path is that model monitoring ui is able to
     select a time range of data very quickly. Known values are: \"Year\", \"Month\", \"Day\",
     \"Hour\", and \"Minute\"."""

    @overload
    def __init__(
        self,
        *,
        collections: Dict[str, "_models.Collection"],
        request_logging: Optional["_models.RequestLogging"] = None,
        rolling_rate: Optional[Union[str, "_models.RollingRateType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataContainer(AssetContainer):
    """DataContainer Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar data_type: [Required] Specifies the type of data. Required. Known values are: "uri_file"
     and "uri_folder".
    :vartype data_type: str or ~azure.ai.resources.autogen.models.DataType
    """

    data_type: Union[str, "_models.DataType"] = rest_discriminator(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the type of data. Required. Known values are: \"uri_file\" and
     \"uri_folder\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataPathAssetReference(AssetReferenceBase, discriminator="DataPath"):
    """Reference to an asset via its path in a datastore.


    :ivar datastore_id: ARM resource ID of the datastore where the asset is located.
    :vartype datastore_id: str
    :ivar path: The path of the file/directory in the datastore.
    :vartype path: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required. DataPath
    :vartype reference_type: str or ~azure.ai.resources.autogen.models.DATA_PATH
    """

    datastore_id: Optional[str] = rest_field(name="datastoreId")
    """ARM resource ID of the datastore where the asset is located."""
    path: Optional[str] = rest_field()
    """The path of the file/directory in the datastore."""
    reference_type: Literal[ReferenceType.DATA_PATH] = rest_discriminator(name="referenceType")  # type: ignore
    """[Required] Specifies the type of asset reference. Required. DataPath"""

    @overload
    def __init__(
        self,
        *,
        datastore_id: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, reference_type=ReferenceType.DATA_PATH, **kwargs)


class Dataset(InputData, discriminator="dataset"):
    """Dataset as source for evaluation.


    :ivar id: Evaluation input data. Required.
    :vartype id: str
    :ivar type: Required. Default value is "dataset".
    :vartype type: str
    """

    type: Literal["dataset"] = rest_discriminator(name="type")  # type: ignore
    """Required. Default value is \"dataset\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="dataset", **kwargs)


class DataVersionBase(AssetBase):
    """DataVersionBase Definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    UriFileDataVersion, UriFolderDataVersion


    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     https://go.microsoft.com/fwlink/?linkid=2202330. Required.
    :vartype data_uri: str
    :ivar data_type: Data type. Required. Known values are: "uri_file" and "uri_folder".
    :vartype data_type: str or ~azure.ai.resources.autogen.models.DataType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    data_uri: str = rest_field(name="dataUri", visibility=["read", "create"])
    """[Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330. Required."""
    data_type: str = rest_discriminator(name="dataType")
    """Data type. Required. Known values are: \"uri_file\" and \"uri_folder\"."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        data_type: str,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentLogs(_model_base.Model):
    """Deployment logs.

    :ivar content: The retrieved online deployment logs.
    :vartype content: str
    """

    content: Optional[str] = rest_field()
    """The retrieved online deployment logs."""

    @overload
    def __init__(
        self,
        *,
        content: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentLogsRequest(_model_base.Model):
    """Request to get deployment logs.

    :ivar container_type: The type of container to retrieve logs from. Known values are:
     "StorageInitializer" and "InferenceServer".
    :vartype container_type: str or ~azure.ai.resources.autogen.models.ContainerType
    :ivar tail: The maximum number of lines to tail.
    :vartype tail: int
    """

    container_type: Optional[Union[str, "_models.ContainerType"]] = rest_field(name="containerType")
    """The type of container to retrieve logs from. Known values are: \"StorageInitializer\" and
     \"InferenceServer\"."""
    tail: Optional[int] = rest_field()
    """The maximum number of lines to tail."""

    @overload
    def __init__(
        self,
        *,
        container_type: Optional[Union[str, "_models.ContainerType"]] = None,
        tail: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceConfiguration(_model_base.Model):
    """Resource configuration.

    :ivar instance_count: Optional number of instances or nodes used by the compute target.
    :vartype instance_count: int
    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar properties: Additional properties bag.
    :vartype properties: dict[str, dict[str, any]]
    """

    instance_count: Optional[int] = rest_field(name="instanceCount", visibility=["read", "create"])
    """Optional number of instances or nodes used by the compute target."""
    instance_type: Optional[str] = rest_field(name="instanceType", visibility=["read", "create"])
    """Optional type of VM used as supported by the compute target."""
    properties: Optional[Dict[str, Dict[str, Any]]] = rest_field(visibility=["read", "create"])
    """Additional properties bag."""

    @overload
    def __init__(
        self,
        *,
        instance_count: Optional[int] = None,
        instance_type: Optional[str] = None,
        properties: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentResourceConfiguration(ResourceConfiguration):
    """Deployment resource configuration.

    :ivar instance_count: Optional number of instances or nodes used by the compute target.
    :vartype instance_count: int
    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar properties: Additional properties bag.
    :vartype properties: dict[str, dict[str, any]]
    """

    @overload
    def __init__(
        self,
        *,
        instance_count: Optional[int] = None,
        instance_type: Optional[str] = None,
        properties: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DestinationAsset(_model_base.Model):
    """Publishing destination registry asset information.

    :ivar destination_name: Destination asset name.
    :vartype destination_name: str
    :ivar destination_version: Destination asset version.
    :vartype destination_version: str
    :ivar registry_name: Destination registry name.
    :vartype registry_name: str
    """

    destination_name: Optional[str] = rest_field(name="destinationName")
    """Destination asset name."""
    destination_version: Optional[str] = rest_field(name="destinationVersion")
    """Destination asset version."""
    registry_name: Optional[str] = rest_field(name="registryName")
    """Destination registry name."""

    @overload
    def __init__(
        self,
        *,
        destination_name: Optional[str] = None,
        destination_version: Optional[str] = None,
        registry_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointAuthKeys(_model_base.Model):
    """Keys for endpoint authentication.

    :ivar primary_key: The primary key.
    :vartype primary_key: str
    :ivar secondary_key: The secondary key.
    :vartype secondary_key: str
    """

    primary_key: Optional[str] = rest_field(name="primaryKey", visibility=["read", "create"])
    """The primary key."""
    secondary_key: Optional[str] = rest_field(name="secondaryKey", visibility=["read", "create"])
    """The secondary key."""

    @overload
    def __init__(
        self,
        *,
        primary_key: Optional[str] = None,
        secondary_key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointAuthToken(_model_base.Model):
    """Service Token.

    :ivar access_token: Access token for endpoint authentication.
    :vartype access_token: str
    :ivar expiry_time_utc: Access token expiry time (UTC).
    :vartype expiry_time_utc: int
    :ivar refresh_after_time_utc: Refresh access token after time (UTC).
    :vartype refresh_after_time_utc: int
    :ivar token_type: Access token type.
    :vartype token_type: str
    """

    access_token: Optional[str] = rest_field(name="accessToken")
    """Access token for endpoint authentication."""
    expiry_time_utc: Optional[int] = rest_field(name="expiryTimeUtc")
    """Access token expiry time (UTC)."""
    refresh_after_time_utc: Optional[int] = rest_field(name="refreshAfterTimeUtc")
    """Refresh access token after time (UTC)."""
    token_type: Optional[str] = rest_field(name="tokenType")
    """Access token type."""

    @overload
    def __init__(
        self,
        *,
        access_token: Optional[str] = None,
        expiry_time_utc: Optional[int] = None,
        refresh_after_time_utc: Optional[int] = None,
        token_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Evaluation(_model_base.Model):
    """Evaluation Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: Identifier of the evaluation.
    :vartype id: str
    :ivar data: Data for evaluation. Required.
    :vartype data: ~azure.ai.resources.autogen.models.InputData
    :ivar display_name: Update stage to 'Archive' to archive the asset. Default is Development,
     which means the asset is under development.
    :vartype display_name: str
    :ivar description: Description of the evaluation. It can be used to store additional
     information about the evaluation and is mutable.
    :vartype description: str
    :ivar system_data: Metadata containing createdBy and modifiedBy information.
    :vartype system_data: ~azure.ai.resources.autogen.models.SystemData
    :ivar status: Status of the evaluation. It is set by service and is read-only.
    :vartype status: str
    :ivar tags: Evaluation's tags. Unlike properties, tags are fully mutable.
    :vartype tags: dict[str, str]
    :ivar properties: Evaluation's properties. Unlike tags, properties are add-only. Once added, a
     property cannot be removed.
    :vartype properties: dict[str, str]
    :ivar evaluators: Evaluators to be used for the evaluation. Required.
    :vartype evaluators: dict[str, ~azure.ai.resources.autogen.models.EvaluatorConfiguration]
    :ivar evaluation_target: Evaluation Target.
    :vartype evaluation_target: ~azure.ai.resources.autogen.models.EvaluationTarget
    """

    id: Optional[str] = rest_field()
    """Identifier of the evaluation."""
    data: "_models.InputData" = rest_field()
    """Data for evaluation. Required."""
    display_name: Optional[str] = rest_field(name="displayName")
    """Update stage to 'Archive' to archive the asset. Default is Development, which means the asset
     is under development."""
    description: Optional[str] = rest_field()
    """Description of the evaluation. It can be used to store additional information about the
     evaluation and is mutable."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Metadata containing createdBy and modifiedBy information."""
    status: Optional[str] = rest_field(visibility=["read"])
    """Status of the evaluation. It is set by service and is read-only."""
    tags: Optional[Dict[str, str]] = rest_field()
    """Evaluation's tags. Unlike properties, tags are fully mutable."""
    properties: Optional[Dict[str, str]] = rest_field()
    """Evaluation's properties. Unlike tags, properties are add-only. Once added, a property cannot be
     removed."""
    evaluators: Dict[str, "_models.EvaluatorConfiguration"] = rest_field()
    """Evaluators to be used for the evaluation. Required."""
    evaluation_target: Optional["_models.EvaluationTarget"] = rest_field(name="evaluationTarget")
    """Evaluation Target."""

    @overload
    def __init__(
        self,
        *,
        data: "_models.InputData",
        evaluators: Dict[str, "_models.EvaluatorConfiguration"],
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        evaluation_target: Optional["_models.EvaluationTarget"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EvaluatorConfiguration(_model_base.Model):
    """Evaluator Configuration.


    :ivar id: Identifier of the evaluator. Required.
    :vartype id: str
    :ivar init_params: Initialization parameters of the evaluator.
    :vartype init_params: dict[str, str]
    :ivar data_mapping: Data parameters of the evaluator.
    :vartype data_mapping: dict[str, str]
    """

    id: str = rest_field()
    """Identifier of the evaluator. Required."""
    init_params: Optional[Dict[str, str]] = rest_field(name="initParams")
    """Initialization parameters of the evaluator."""
    data_mapping: Optional[Dict[str, str]] = rest_field(name="dataMapping")
    """Data parameters of the evaluator."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        init_params: Optional[Dict[str, str]] = None,
        data_mapping: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FileDeletionStatus(_model_base.Model):
    """A status response from a file deletion operation.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The ID of the resource specified for deletion. Required.
    :vartype id: str
    :ivar deleted: A value indicating whether deletion was successful. Required.
    :vartype deleted: bool
    :ivar object: The object type, which is always 'file'. Required. Default value is "file".
    :vartype object: str
    """

    id: str = rest_field()
    """The ID of the resource specified for deletion. Required."""
    deleted: bool = rest_field()
    """A value indicating whether deletion was successful. Required."""
    object: Literal["file"] = rest_field()
    """The object type, which is always 'file'. Required. Default value is \"file\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        deleted: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["file"] = "file"


class FileListResponse(_model_base.Model):
    """The response data from a file list operation.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always 'list'. Required. Default value is "list".
    :vartype object: str
    :ivar data: The files returned for the request. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.OpenAIFile]
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always 'list'. Required. Default value is \"list\"."""
    data: List["_models.OpenAIFile"] = rest_field()
    """The files returned for the request. Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.OpenAIFile"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class FileSearchToolDefinition(ToolDefinition, discriminator="file_search"):
    """The input definition information for a file search tool as used to configure an assistant.


    :ivar type: The object type, which is always 'file_search'. Required. Default value is
     "file_search".
    :vartype type: str
    :ivar file_search: Options overrides for the file search tool.
    :vartype file_search: ~azure.ai.resources.autogen.models.FileSearchToolDefinitionDetails
    """

    type: Literal["file_search"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'file_search'. Required. Default value is \"file_search\"."""
    file_search: Optional["_models.FileSearchToolDefinitionDetails"] = rest_field()
    """Options overrides for the file search tool."""

    @overload
    def __init__(
        self,
        *,
        file_search: Optional["_models.FileSearchToolDefinitionDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="file_search", **kwargs)


class FileSearchToolDefinitionDetails(_model_base.Model):
    """Options overrides for the file search tool.

    :ivar max_num_results: The maximum number of results the file search tool should output. The
     default is 20 for gpt-4* models and 5 for gpt-3.5-turbo. This number should be between 1 and 50
     inclusive. Note that the file search tool may output fewer than ``max_num_results`` results.
     See the file search tool documentation for more information.
    :vartype max_num_results: int
    """

    max_num_results: Optional[int] = rest_field()
    """The maximum number of results the file search tool should output. The default is 20 for gpt-4*
     models and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive. Note that the
     file search tool may output fewer than ``max_num_results`` results. See the file search tool
     documentation for more information."""

    @overload
    def __init__(
        self,
        *,
        max_num_results: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FileSearchToolResource(_model_base.Model):
    """A set of resources that are used by the ``file_search`` tool.

    :ivar vector_store_ids: The ID of the vector store attached to this assistant. There can be a
     maximum of 1 vector store attached to the assistant.
    :vartype vector_store_ids: list[str]
    """

    vector_store_ids: Optional[List[str]] = rest_field()
    """The ID of the vector store attached to this assistant. There can be a maximum of 1 vector store
     attached to the assistant."""

    @overload
    def __init__(
        self,
        *,
        vector_store_ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FlavorData(_model_base.Model):
    """Flavor Data Definition.

    :ivar data: Model flavor-specific data.
    :vartype data: dict[str, str]
    """

    data: Optional[Dict[str, str]] = rest_field()
    """Model flavor-specific data."""

    @overload
    def __init__(
        self,
        *,
        data: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FunctionDefinition(_model_base.Model):
    """The input definition information for a function.


    :ivar name: The name of the function to be called. Required.
    :vartype name: str
    :ivar description: A description of what the function does, used by the model to choose when
     and how to call the function.
    :vartype description: str
    :ivar parameters: The parameters the functions accepts, described as a JSON Schema object.
     Required.
    :vartype parameters: any
    """

    name: str = rest_field()
    """The name of the function to be called. Required."""
    description: Optional[str] = rest_field()
    """A description of what the function does, used by the model to choose when and how to call the
     function."""
    parameters: Any = rest_field()
    """The parameters the functions accepts, described as a JSON Schema object. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        parameters: Any,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FunctionName(_model_base.Model):
    """The function name that will be used, if using the ``function`` tool.


    :ivar name: The name of the function to call. Required.
    :vartype name: str
    """

    name: str = rest_field()
    """The name of the function to call. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FunctionToolDefinition(ToolDefinition, discriminator="function"):
    """The input definition information for a function tool as used to configure an assistant.


    :ivar type: The object type, which is always 'function'. Required. Default value is "function".
    :vartype type: str
    :ivar function: The definition of the concrete function that the function tool should call.
     Required.
    :vartype function: ~azure.ai.resources.autogen.models.FunctionDefinition
    """

    type: Literal["function"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'function'. Required. Default value is \"function\"."""
    function: "_models.FunctionDefinition" = rest_field()
    """The definition of the concrete function that the function tool should call. Required."""

    @overload
    def __init__(
        self,
        *,
        function: "_models.FunctionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="function", **kwargs)


class IdAssetReference(AssetReferenceBase, discriminator="Id"):
    """Reference to an asset via its ARM resource ID.


    :ivar asset_id: [Required] ARM resource ID of the asset. Required.
    :vartype asset_id: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required. Id
    :vartype reference_type: str or ~azure.ai.resources.autogen.models.ID
    """

    asset_id: str = rest_field(name="assetId")
    """[Required] ARM resource ID of the asset. Required."""
    reference_type: Literal[ReferenceType.ID] = rest_discriminator(name="referenceType")  # type: ignore
    """[Required] Specifies the type of asset reference. Required. Id"""

    @overload
    def __init__(
        self,
        *,
        asset_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, reference_type=ReferenceType.ID, **kwargs)


class Index(_model_base.Model):
    """Index resource Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: Fully qualified resource Id:
     azureml://workspace/{workspaceName}/indexes/{name}/versions/{version} of the index. Required.
    :vartype id: str
    :ivar stage: Update stage to 'Archive' to archive the asset. Default is Development, which
     means the asset is under development.
    :vartype stage: str
    :ivar description: Description information of the asset.
    :vartype description: str
    :ivar system_data: Metadata containing createdBy and modifiedBy information.
    :vartype system_data: ~azure.ai.resources.autogen.models.SystemData
    :ivar tags: Asset's tags. Unlike properties, tags are fully mutable.
    :vartype tags: dict[str, str]
    :ivar properties: Asset's properties. Unlike tags, properties are add-only. Once added, a
     property cannot be removed.
    :vartype properties: dict[str, str]
    :ivar storage_uri: Default workspace blob storage Uri. Should work across storage types and
     auth scenarios. Required.
    :vartype storage_uri: str
    """

    id: str = rest_field(visibility=["read"])
    """Fully qualified resource Id:
     azureml://workspace/{workspaceName}/indexes/{name}/versions/{version} of the index. Required."""
    stage: Optional[str] = rest_field()
    """Update stage to 'Archive' to archive the asset. Default is Development, which means the asset
     is under development."""
    description: Optional[str] = rest_field()
    """Description information of the asset."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Metadata containing createdBy and modifiedBy information."""
    tags: Optional[Dict[str, str]] = rest_field()
    """Asset's tags. Unlike properties, tags are fully mutable."""
    properties: Optional[Dict[str, str]] = rest_field()
    """Asset's properties. Unlike tags, properties are add-only. Once added, a property cannot be
     removed."""
    storage_uri: str = rest_field(name="storageUri")
    """Default workspace blob storage Uri. Should work across storage types and auth scenarios.
     Required."""

    @overload
    def __init__(
        self,
        *,
        storage_uri: str,
        stage: Optional[str] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageAttachment(_model_base.Model):
    """This describes to which tools a file has been attached.


    :ivar file_id: The ID of the file to attach to the message. Required.
    :vartype file_id: str
    :ivar tools: The tools to add to this file. Required.
    :vartype tools: list[~azure.ai.resources.autogen.models.CodeInterpreterToolDefinition or
     ~azure.ai.resources.autogen.models.FileSearchToolDefinition]
    """

    file_id: str = rest_field()
    """The ID of the file to attach to the message. Required."""
    tools: List["_types.MessageAttachmentToolDefinition"] = rest_field()
    """The tools to add to this file. Required."""

    @overload
    def __init__(
        self,
        *,
        file_id: str,
        tools: List["_types.MessageAttachmentToolDefinition"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageContent(_model_base.Model):
    """An abstract representation of a single item of thread message content.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    MessageImageFileContent, MessageTextContent


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageImageFileContent(MessageContent, discriminator="image_file"):
    """A representation of image file content in a thread message.


    :ivar type: The object type, which is always 'image_file'. Required. Default value is
     "image_file".
    :vartype type: str
    :ivar image_file: The image file for this thread message content item. Required.
    :vartype image_file: ~azure.ai.resources.autogen.models.MessageImageFileDetails
    """

    type: Literal["image_file"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'image_file'. Required. Default value is \"image_file\"."""
    image_file: "_models.MessageImageFileDetails" = rest_field()
    """The image file for this thread message content item. Required."""

    @overload
    def __init__(
        self,
        *,
        image_file: "_models.MessageImageFileDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="image_file", **kwargs)


class MessageImageFileDetails(_model_base.Model):
    """An image reference, as represented in thread message content.


    :ivar file_id: The ID for the file associated with this image. Required.
    :vartype file_id: str
    """

    file_id: str = rest_field()
    """The ID for the file associated with this image. Required."""

    @overload
    def __init__(
        self,
        *,
        file_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageIncompleteDetails(_model_base.Model):
    """Information providing additional detail about a message entering an incomplete status.


    :ivar reason: The provided reason describing why the message was marked as incomplete.
     Required. Known values are: "content_filter", "max_tokens", "run_cancelled", "run_failed", and
     "run_expired".
    :vartype reason: str or ~azure.ai.resources.autogen.models.MessageIncompleteDetailsReason
    """

    reason: Union[str, "_models.MessageIncompleteDetailsReason"] = rest_field()
    """The provided reason describing why the message was marked as incomplete. Required. Known values
     are: \"content_filter\", \"max_tokens\", \"run_cancelled\", \"run_failed\", and
     \"run_expired\"."""

    @overload
    def __init__(
        self,
        *,
        reason: Union[str, "_models.MessageIncompleteDetailsReason"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageTextAnnotation(_model_base.Model):
    """An abstract representation of an annotation to text thread message content.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    MessageTextFileCitationAnnotation, MessageTextFilePathAnnotation


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    :ivar text: The textual content associated with this text annotation item. Required.
    :vartype text: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""
    text: str = rest_field()
    """The textual content associated with this text annotation item. Required."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        text: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageTextContent(MessageContent, discriminator="text"):
    """A representation of a textual item of thread message content.


    :ivar type: The object type, which is always 'text'. Required. Default value is "text".
    :vartype type: str
    :ivar text: The text and associated annotations for this thread message content item. Required.
    :vartype text: ~azure.ai.resources.autogen.models.MessageTextDetails
    """

    type: Literal["text"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'text'. Required. Default value is \"text\"."""
    text: "_models.MessageTextDetails" = rest_field()
    """The text and associated annotations for this thread message content item. Required."""

    @overload
    def __init__(
        self,
        *,
        text: "_models.MessageTextDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="text", **kwargs)


class MessageTextDetails(_model_base.Model):
    """The text and associated annotations for a single item of assistant thread message content.


    :ivar value: The text data. Required.
    :vartype value: str
    :ivar annotations: A list of annotations associated with this text. Required.
    :vartype annotations: list[~azure.ai.resources.autogen.models.MessageTextAnnotation]
    """

    value: str = rest_field()
    """The text data. Required."""
    annotations: List["_models.MessageTextAnnotation"] = rest_field()
    """A list of annotations associated with this text. Required."""

    @overload
    def __init__(
        self,
        *,
        value: str,
        annotations: List["_models.MessageTextAnnotation"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageTextFileCitationAnnotation(MessageTextAnnotation, discriminator="file_citation"):
    """A citation within the message that points to a specific quote from a specific File associated
    with the assistant or the message. Generated when the assistant uses the 'file_search' tool to
    search files.


    :ivar text: The textual content associated with this text annotation item. Required.
    :vartype text: str
    :ivar type: The object type, which is always 'file_citation'. Required. Default value is
     "file_citation".
    :vartype type: str
    :ivar file_citation: A citation within the message that points to a specific quote from a
     specific file.
     Generated when the assistant uses the "file_search" tool to search files. Required.
    :vartype file_citation: ~azure.ai.resources.autogen.models.MessageTextFileCitationDetails
    :ivar start_index: The first text index associated with this text annotation.
    :vartype start_index: int
    :ivar end_index: The last text index associated with this text annotation.
    :vartype end_index: int
    """

    type: Literal["file_citation"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'file_citation'. Required. Default value is \"file_citation\"."""
    file_citation: "_models.MessageTextFileCitationDetails" = rest_field()
    """A citation within the message that points to a specific quote from a specific file.
     Generated when the assistant uses the \"file_search\" tool to search files. Required."""
    start_index: Optional[int] = rest_field()
    """The first text index associated with this text annotation."""
    end_index: Optional[int] = rest_field()
    """The last text index associated with this text annotation."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        file_citation: "_models.MessageTextFileCitationDetails",
        start_index: Optional[int] = None,
        end_index: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="file_citation", **kwargs)


class MessageTextFileCitationDetails(_model_base.Model):
    """A representation of a file-based text citation, as used in a file-based annotation of text
    thread message content.


    :ivar file_id: The ID of the file associated with this citation. Required.
    :vartype file_id: str
    :ivar quote: The specific quote cited in the associated file. Required.
    :vartype quote: str
    """

    file_id: str = rest_field()
    """The ID of the file associated with this citation. Required."""
    quote: str = rest_field()
    """The specific quote cited in the associated file. Required."""

    @overload
    def __init__(
        self,
        *,
        file_id: str,
        quote: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MessageTextFilePathAnnotation(MessageTextAnnotation, discriminator="file_path"):
    """A citation within the message that points to a file located at a specific path.


    :ivar text: The textual content associated with this text annotation item. Required.
    :vartype text: str
    :ivar type: The object type, which is always 'file_path'. Required. Default value is
     "file_path".
    :vartype type: str
    :ivar file_path: A URL for the file that's generated when the assistant used the
     code_interpreter tool to generate a file. Required.
    :vartype file_path: ~azure.ai.resources.autogen.models.MessageTextFilePathDetails
    :ivar start_index: The first text index associated with this text annotation.
    :vartype start_index: int
    :ivar end_index: The last text index associated with this text annotation.
    :vartype end_index: int
    """

    type: Literal["file_path"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'file_path'. Required. Default value is \"file_path\"."""
    file_path: "_models.MessageTextFilePathDetails" = rest_field()
    """A URL for the file that's generated when the assistant used the code_interpreter tool to
     generate a file. Required."""
    start_index: Optional[int] = rest_field()
    """The first text index associated with this text annotation."""
    end_index: Optional[int] = rest_field()
    """The last text index associated with this text annotation."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        file_path: "_models.MessageTextFilePathDetails",
        start_index: Optional[int] = None,
        end_index: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="file_path", **kwargs)


class MessageTextFilePathDetails(_model_base.Model):
    """An encapsulation of an image file ID, as used by message image content.


    :ivar file_id: The ID of the specific file that the citation is from. Required.
    :vartype file_id: str
    """

    file_id: str = rest_field()
    """The ID of the specific file that the citation is from. Required."""

    @overload
    def __init__(
        self,
        *,
        file_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelContainer(AssetContainer):
    """Model Container Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the model container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or ~azure.ai.resources.autogen.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the model container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelVersion(AssetBase):
    """Model Version Definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar flavors: Mapping of model flavors to their properties.
    :vartype flavors: dict[str, ~azure.ai.resources.autogen.models.FlavorData]
    :ivar job_name: Name of the training job which produced this model.
    :vartype job_name: str
    :ivar model_type: The storage format for this entity. Used for NCD.
    :vartype model_type: str
    :ivar model_uri: The URI path to the model contents.
    :vartype model_uri: str
    :ivar provisioning_state: Provisioning state for the model version. Required. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or ~azure.ai.resources.autogen.models.AssetProvisioningState
    :ivar stage: Stage in the model lifecycle assigned to this model.
    :vartype stage: str
    """

    flavors: Optional[Dict[str, "_models.FlavorData"]] = rest_field()
    """Mapping of model flavors to their properties."""
    job_name: Optional[str] = rest_field(name="jobName")
    """Name of the training job which produced this model."""
    model_type: Optional[str] = rest_field(name="modelType")
    """The storage format for this entity. Used for NCD."""
    model_uri: Optional[str] = rest_field(name="modelUri")
    """The URI path to the model contents."""
    provisioning_state: Union[str, "_models.AssetProvisioningState"] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the model version. Required. Known values are: \"Succeeded\",
     \"Failed\", \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    stage: Optional[str] = rest_field()
    """Stage in the model lifecycle assigned to this model."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        flavors: Optional[Dict[str, "_models.FlavorData"]] = None,
        job_name: Optional[str] = None,
        model_type: Optional[str] = None,
        model_uri: Optional[str] = None,
        stage: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineDeployment(EndpointDeploymentBase):
    """Online deployment definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.ai.resources.autogen.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar app_insights_enabled: If true, enables Application Insights logging.
    :vartype app_insights_enabled: bool
    :ivar data_collector: The mdc configuration, we disable mdc when it's null.
    :vartype data_collector: ~azure.ai.resources.autogen.models.DataCollector
    :ivar egress_public_network_access: If Enabled, allow egress public network access. If
     Disabled, this will create secure egress. Default: Enabled. Known values are: "Enabled" and
     "Disabled".
    :vartype egress_public_network_access: str or
     ~azure.ai.resources.autogen.models.EgressPublicNetworkAccessType
    :ivar instance_type: Compute instance type.
    :vartype instance_type: str
    :ivar liveness_probe: Liveness probe monitors the health of the container regularly.
    :vartype liveness_probe: ~azure.ai.resources.autogen.models.ProbeSettings
    :ivar model: The URI path to the model.
    :vartype model: str
    :ivar model_mount_path: The path to mount the model in custom container.
    :vartype model_mount_path: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.ai.resources.autogen.models.DeploymentProvisioningState
    :ivar readiness_probe: Readiness probe validates if the container is ready to serve traffic.
     The properties and defaults are the same as liveness probe.
    :vartype readiness_probe: ~azure.ai.resources.autogen.models.ProbeSettings
    :ivar request_settings: Request settings for the deployment.
    :vartype request_settings: ~azure.ai.resources.autogen.models.OnlineRequestSettings
    :ivar scale_settings: Scale settings for the deployment. If it is null or not provided, it
     defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment and to
     DefaultScaleSettings for ManagedOnlineDeployment.
    :vartype scale_settings: ~azure.ai.resources.autogen.models.OnlineScaleSettings
    """

    app_insights_enabled: Optional[bool] = rest_field(name="appInsightsEnabled")
    """If true, enables Application Insights logging."""
    data_collector: Optional["_models.DataCollector"] = rest_field(name="dataCollector")
    """The mdc configuration, we disable mdc when it's null."""
    egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = rest_field(
        name="egressPublicNetworkAccess"
    )
    """If Enabled, allow egress public network access. If Disabled, this will create secure egress.
     Default: Enabled. Known values are: \"Enabled\" and \"Disabled\"."""
    instance_type: Optional[str] = rest_field(name="instanceType", visibility=["read", "create"])
    """Compute instance type."""
    liveness_probe: Optional["_models.ProbeSettings"] = rest_field(name="livenessProbe")
    """Liveness probe monitors the health of the container regularly."""
    model: Optional[str] = rest_field()
    """The URI path to the model."""
    model_mount_path: Optional[str] = rest_field(name="modelMountPath")
    """The path to mount the model in custom container."""
    provisioning_state: Optional[Union[str, "_models.DeploymentProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint deployment. Known values are: \"Creating\", \"Deleting\",
     \"Scaling\", \"Updating\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    readiness_probe: Optional["_models.ProbeSettings"] = rest_field(name="readinessProbe")
    """Readiness probe validates if the container is ready to serve traffic. The properties and
     defaults are the same as liveness probe."""
    request_settings: Optional["_models.OnlineRequestSettings"] = rest_field(name="requestSettings")
    """Request settings for the deployment."""
    scale_settings: Optional["_models.OnlineScaleSettings"] = rest_field(name="scaleSettings")
    """Scale settings for the deployment. If it is null or not provided, it defaults to
     TargetUtilizationScaleSettings for KubernetesOnlineDeployment and to DefaultScaleSettings for
     ManagedOnlineDeployment."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        app_insights_enabled: Optional[bool] = None,
        data_collector: Optional["_models.DataCollector"] = None,
        egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = None,
        instance_type: Optional[str] = None,
        liveness_probe: Optional["_models.ProbeSettings"] = None,
        model: Optional[str] = None,
        model_mount_path: Optional[str] = None,
        readiness_probe: Optional["_models.ProbeSettings"] = None,
        request_settings: Optional["_models.OnlineRequestSettings"] = None,
        scale_settings: Optional["_models.OnlineScaleSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineEndpoint(EndpointBase):
    """Online endpoint definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar auth_mode: [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure
     Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.ai.resources.autogen.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint. This property will
     always be returned as null. AuthKey values must be retrieved using the ListKeys API.
    :vartype keys_property: ~azure.ai.resources.autogen.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    :ivar compute: ARM resource ID of the compute if it exists. optional.
    :vartype compute: str
    :ivar mirror_traffic: Percentage of traffic to be mirrored to each deployment without using
     returned scoring. Traffic values need to sum to utmost 50.
    :vartype mirror_traffic: dict[str, int]
    :ivar provisioning_state: Provisioning state for the endpoint. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.ai.resources.autogen.models.EndpointProvisioningState
    :ivar public_network_access: Set to 'Enabled' for endpoints that should allow public access
     when Private Link is enabled. Known values are: "Enabled" and "Disabled".
    :vartype public_network_access: str or
     ~azure.ai.resources.autogen.models.PublicNetworkAccessType
    :ivar traffic: Percentage of traffic from endpoint to divert to each deployment. Traffic values
     need to sum to 100.
    :vartype traffic: dict[str, int]
    """

    compute: Optional[str] = rest_field()
    """ARM resource ID of the compute if it exists. optional."""
    mirror_traffic: Optional[Dict[str, int]] = rest_field(name="mirrorTraffic")
    """Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic
     values need to sum to utmost 50."""
    provisioning_state: Optional[Union[str, "_models.EndpointProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""
    public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = rest_field(
        name="publicNetworkAccess"
    )
    """Set to 'Enabled' for endpoints that should allow public access when Private Link is enabled.
     Known values are: \"Enabled\" and \"Disabled\"."""
    traffic: Optional[Dict[str, int]] = rest_field()
    """Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to
     100."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[Dict[str, str]] = None,
        compute: Optional[str] = None,
        mirror_traffic: Optional[Dict[str, int]] = None,
        public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = None,
        traffic: Optional[Dict[str, int]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineRequestSettings(_model_base.Model):
    """Online deployment scoring requests configuration.

    :ivar max_concurrent_requests_per_instance: The number of maximum concurrent requests per node
     allowed per deployment. Defaults to 1.
    :vartype max_concurrent_requests_per_instance: int
    :ivar max_queue_wait: (Deprecated for Managed Online Endpoints) The maximum amount of time a
     request will stay in the queue in ISO 8601 format. Defaults to 500ms. (Now increase
     ``request_timeout_ms`` to account for any networking/queue delays).
    :vartype max_queue_wait: ~datetime.timedelta
    :ivar request_timeout: The scoring timeout in ISO 8601 format. Defaults to 5000ms.
    :vartype request_timeout: ~datetime.timedelta
    """

    max_concurrent_requests_per_instance: Optional[int] = rest_field(name="maxConcurrentRequestsPerInstance")
    """The number of maximum concurrent requests per node allowed per deployment. Defaults to 1."""
    max_queue_wait: Optional[datetime.timedelta] = rest_field(name="maxQueueWait")
    """(Deprecated for Managed Online Endpoints) The maximum amount of time a request will stay in the
     queue in ISO 8601 format. Defaults to 500ms. (Now increase ``request_timeout_ms`` to account
     for any networking/queue delays)."""
    request_timeout: Optional[datetime.timedelta] = rest_field(name="requestTimeout")
    """The scoring timeout in ISO 8601 format. Defaults to 5000ms."""

    @overload
    def __init__(
        self,
        *,
        max_concurrent_requests_per_instance: Optional[int] = None,
        max_queue_wait: Optional[datetime.timedelta] = None,
        request_timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineScaleSettings(_model_base.Model):
    """Online deployment scaling configuration.


    :ivar scale_type: The scale type for the deployment. Required. Known values are: "Default" and
     "TargetUtilization".
    :vartype scale_type: str or ~azure.ai.resources.autogen.models.ScaleType
    """

    scale_type: Union[str, "_models.ScaleType"] = rest_discriminator(name="scaleType")
    """The scale type for the deployment. Required. Known values are: \"Default\" and
     \"TargetUtilization\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OpenAIFile(_model_base.Model):
    """Represents an assistant that can call the model and use tools.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always 'file'. Required. Default value is "file".
    :vartype object: str
    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar bytes: The size of the file, in bytes. Required.
    :vartype bytes: int
    :ivar filename: The name of the file. Required.
    :vartype filename: str
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar purpose: The intended purpose of a file. Required. Known values are: "fine-tune",
     "fine-tune-results", "assistants", "assistants_output", "batch", "batch_output", and "vision".
    :vartype purpose: str or ~azure.ai.resources.autogen.models.FilePurpose
    :ivar status: The state of the file. This field is available in Azure OpenAI only. Known values
     are: "uploaded", "pending", "running", "processed", "error", "deleting", and "deleted".
    :vartype status: str or ~azure.ai.resources.autogen.models.FileState
    :ivar status_details: The error message with details in case processing of this file failed.
     This field is available in Azure OpenAI only.
    :vartype status_details: str
    """

    object: Literal["file"] = rest_field()
    """The object type, which is always 'file'. Required. Default value is \"file\"."""
    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    bytes: int = rest_field()
    """The size of the file, in bytes. Required."""
    filename: str = rest_field()
    """The name of the file. Required."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    purpose: Union[str, "_models.FilePurpose"] = rest_field()
    """The intended purpose of a file. Required. Known values are: \"fine-tune\",
     \"fine-tune-results\", \"assistants\", \"assistants_output\", \"batch\", \"batch_output\", and
     \"vision\"."""
    status: Optional[Union[str, "_models.FileState"]] = rest_field()
    """The state of the file. This field is available in Azure OpenAI only. Known values are:
     \"uploaded\", \"pending\", \"running\", \"processed\", \"error\", \"deleting\", and
     \"deleted\"."""
    status_details: Optional[str] = rest_field()
    """The error message with details in case processing of this file failed. This field is available
     in Azure OpenAI only."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        bytes: int,
        filename: str,
        created_at: datetime.datetime,
        purpose: Union[str, "_models.FilePurpose"],
        status: Optional[Union[str, "_models.FileState"]] = None,
        status_details: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["file"] = "file"


class OpenAIPageableListOfAssistant(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.Assistant]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.Assistant"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.Assistant"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OpenAIPageableListOfRunStep(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.RunStep]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.RunStep"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.RunStep"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OpenAIPageableListOfThreadMessage(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.ThreadMessage]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.ThreadMessage"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.ThreadMessage"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OpenAIPageableListOfThreadRun(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.ThreadRun]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.ThreadRun"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.ThreadRun"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OpenAIPageableListOfVectorStore(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.VectorStore]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.VectorStore"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.VectorStore"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OpenAIPageableListOfVectorStoreFile(_model_base.Model):
    """The response data for a requested list of items.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar object: The object type, which is always list. Required. Default value is "list".
    :vartype object: str
    :ivar data: The requested list of items. Required.
    :vartype data: list[~azure.ai.resources.autogen.models.VectorStoreFile]
    :ivar first_id: The first ID represented in this list. Required.
    :vartype first_id: str
    :ivar last_id: The last ID represented in this list. Required.
    :vartype last_id: str
    :ivar has_more: A value indicating whether there are additional values available not captured
     in this list. Required.
    :vartype has_more: bool
    """

    object: Literal["list"] = rest_field()
    """The object type, which is always list. Required. Default value is \"list\"."""
    data: List["_models.VectorStoreFile"] = rest_field()
    """The requested list of items. Required."""
    first_id: str = rest_field()
    """The first ID represented in this list. Required."""
    last_id: str = rest_field()
    """The last ID represented in this list. Required."""
    has_more: bool = rest_field()
    """A value indicating whether there are additional values available not captured in this list.
     Required."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.VectorStoreFile"],
        first_id: str,
        last_id: str,
        has_more: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["list"] = "list"


class OutputPathAssetReference(AssetReferenceBase, discriminator="OutputPath"):
    """Reference to an asset via its path in a job output.


    :ivar job_id: ARM resource ID of the job.
    :vartype job_id: str
    :ivar path: The path of the file/directory in the job output.
    :vartype path: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required. OutputPath
    :vartype reference_type: str or ~azure.ai.resources.autogen.models.OUTPUT_PATH
    """

    job_id: Optional[str] = rest_field(name="jobId")
    """ARM resource ID of the job."""
    path: Optional[str] = rest_field()
    """The path of the file/directory in the job output."""
    reference_type: Literal[ReferenceType.OUTPUT_PATH] = rest_discriminator(name="referenceType")  # type: ignore
    """[Required] Specifies the type of asset reference. Required. OutputPath"""

    @overload
    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, reference_type=ReferenceType.OUTPUT_PATH, **kwargs)


class PartialBatchDeployment(_model_base.Model):
    """Mutable batch inference settings per deployment.

    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    """

    description: Optional[str] = rest_field()
    """Description of the endpoint deployment."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties(
    _model_base.Model
):  # pylint: disable=name-too-long
    """Strictly used in update requests.

    :ivar properties: Additional attributes of the entity.
    :vartype properties: ~azure.ai.resources.autogen.models.PartialBatchDeployment
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    properties: Optional["_models.PartialBatchDeployment"] = rest_field()
    """Additional attributes of the entity."""
    tags: Optional[Dict[str, str]] = rest_field()
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.PartialBatchDeployment"] = None,
        tags: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialManagedServiceIdentity(_model_base.Model):
    """Managed service identity (system assigned and/or user assigned identities).

    :ivar type: Managed service identity (system assigned and/or user assigned identities). Known
     values are: "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
    :vartype type: str or ~azure.ai.resources.autogen.models.ManagedServiceIdentityType
    :ivar user_assigned_identities: The set of user assigned identities associated with the
     resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.  # pylint: disable=line-too-long
     The dictionary values can be empty objects ({}) in requests.
    :vartype user_assigned_identities: dict[str, dict[str, any]]
    """

    type: Optional[Union[str, "_models.ManagedServiceIdentityType"]] = rest_field()
    """Managed service identity (system assigned and/or user assigned identities). Known values are:
     \"None\", \"SystemAssigned\", \"UserAssigned\", and \"SystemAssigned,UserAssigned\"."""
    user_assigned_identities: Optional[Dict[str, Dict[str, Any]]] = rest_field(name="userAssignedIdentities")
    """The set of user assigned identities associated with the resource. The userAssignedIdentities
     dictionary keys will be ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.  # pylint: disable=line-too-long
     The dictionary values can be empty objects ({}) in requests."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.ManagedServiceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResource(_model_base.Model):
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    tags: Optional[Dict[str, str]] = rest_field()
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResourceWithIdentity(PartialMinimalTrackedResource):  # pylint: disable=name-too-long
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.ai.resources.autogen.models.PartialManagedServiceIdentity
    """

    identity: Optional["_models.PartialManagedServiceIdentity"] = rest_field()
    """Managed service identity (system assigned and/or user assigned identities)."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        identity: Optional["_models.PartialManagedServiceIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResourceWithSku(PartialMinimalTrackedResource):
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.ai.resources.autogen.models.PartialSku
    """

    sku: Optional["_models.PartialSku"] = rest_field()
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["_models.PartialSku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialSku(_model_base.Model):
    """Common SKU definition.

    :ivar capacity: If the SKU supports scale out/in then the capacity integer should be included.
     If scale out/in is not possible for the resource this may be omitted.
    :vartype capacity: int
    :ivar family: If the service has different generations of hardware, for the same SKU, then that
     can be captured here.
    :vartype family: str
    :ivar name: The name of the SKU. Ex - P3. It is typically a letter+number code.
    :vartype name: str
    :ivar size: The SKU size. When the name field is the combination of tier and some other value,
     this would be the standalone code.
    :vartype size: str
    :ivar tier: This field is required to be implemented by the Resource Provider if the service
     has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
     "Standard", and "Premium".
    :vartype tier: str or ~azure.ai.resources.autogen.models.SkuTier
    """

    capacity: Optional[int] = rest_field()
    """If the SKU supports scale out/in then the capacity integer should be included. If scale out/in
     is not possible for the resource this may be omitted."""
    family: Optional[str] = rest_field()
    """If the service has different generations of hardware, for the same SKU, then that can be
     captured here."""
    name: Optional[str] = rest_field()
    """The name of the SKU. Ex - P3. It is typically a letter+number code."""
    size: Optional[str] = rest_field()
    """The SKU size. When the name field is the combination of tier and some other value, this would
     be the standalone code."""
    tier: Optional[Union[str, "_models.SkuTier"]] = rest_field()
    """This field is required to be implemented by the Resource Provider if the service has more than
     one tier, but is not required on a PUT. Known values are: \"Free\", \"Basic\", \"Standard\",
     and \"Premium\"."""

    @overload
    def __init__(
        self,
        *,
        capacity: Optional[int] = None,
        family: Optional[str] = None,
        name: Optional[str] = None,
        size: Optional[str] = None,
        tier: Optional[Union[str, "_models.SkuTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProbeSettings(_model_base.Model):
    """Deployment container liveness/readiness probe configuration.

    :ivar failure_threshold: The number of failures to allow before returning an unhealthy status.
    :vartype failure_threshold: int
    :ivar initial_delay: The delay before the first probe in ISO 8601 format.
    :vartype initial_delay: ~datetime.timedelta
    :ivar period: The length of time between probes in ISO 8601 format.
    :vartype period: ~datetime.timedelta
    :ivar success_threshold: The number of successful probes before returning a healthy status.
    :vartype success_threshold: int
    :ivar timeout: The probe timeout in ISO 8601 format.
    :vartype timeout: ~datetime.timedelta
    """

    failure_threshold: Optional[int] = rest_field(name="failureThreshold")
    """The number of failures to allow before returning an unhealthy status."""
    initial_delay: Optional[datetime.timedelta] = rest_field(name="initialDelay")
    """The delay before the first probe in ISO 8601 format."""
    period: Optional[datetime.timedelta] = rest_field()
    """The length of time between probes in ISO 8601 format."""
    success_threshold: Optional[int] = rest_field(name="successThreshold")
    """The number of successful probes before returning a healthy status."""
    timeout: Optional[datetime.timedelta] = rest_field()
    """The probe timeout in ISO 8601 format."""

    @overload
    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        initial_delay: Optional[datetime.timedelta] = None,
        period: Optional[datetime.timedelta] = None,
        success_threshold: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegenerateEndpointKeysRequest(_model_base.Model):
    """Request to regenerate endpoint keys.

    All required parameters must be populated in order to send to server.

    :ivar key_type: [Required] Specification for which type of key to generate. Primary or
     Secondary. Required. Known values are: "Primary" and "Secondary".
    :vartype key_type: str or ~azure.ai.resources.autogen.models.KeyType
    :ivar key_value: The value the key is set to.
    :vartype key_value: str
    """

    key_type: Union[str, "_models.KeyType"] = rest_field(name="keyType")
    """[Required] Specification for which type of key to generate. Primary or Secondary. Required.
     Known values are: \"Primary\" and \"Secondary\"."""
    key_value: Optional[str] = rest_field(name="keyValue")
    """The value the key is set to."""

    @overload
    def __init__(
        self,
        *,
        key_type: Union[str, "_models.KeyType"],
        key_value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequestLogging(_model_base.Model):
    """Definition for RequestLogging.

    :ivar capture_headers: For payload logging, we only collect payload by default. If customers
     also want to collect the specified headers, they can set them in captureHeaders so that backend
     will collect those headers along with payload.
    :vartype capture_headers: list[str]
    """

    capture_headers: Optional[List[str]] = rest_field(name="captureHeaders")
    """For payload logging, we only collect payload by default. If customers also want to collect the
     specified headers, they can set them in captureHeaders so that backend will collect those
     headers along with payload."""

    @overload
    def __init__(
        self,
        *,
        capture_headers: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequiredAction(_model_base.Model):
    """An abstract representation of a required action for an assistant thread run to continue.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SubmitToolOutputsAction


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequiredToolCall(_model_base.Model):
    """An abstract representation a a tool invocation needed by the model to continue a run.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    RequiredFunctionToolCall


    :ivar type: The object type for the required tool call. Required. Default value is None.
    :vartype type: str
    :ivar id: The ID of the tool call. This ID must be referenced when submitting tool outputs.
     Required.
    :vartype id: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type for the required tool call. Required. Default value is None."""
    id: str = rest_field()
    """The ID of the tool call. This ID must be referenced when submitting tool outputs. Required."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequiredFunctionToolCall(RequiredToolCall, discriminator="function"):
    """A representation of a requested call to a function tool, needed by the model to continue
    evaluation of a run.


    :ivar id: The ID of the tool call. This ID must be referenced when submitting tool outputs.
     Required.
    :vartype id: str
    :ivar type: The object type of the required tool call. Always 'function' for function tools.
     Required. Default value is "function".
    :vartype type: str
    :ivar function: Detailed information about the function to be executed by the tool that
     includes name and arguments. Required.
    :vartype function: ~azure.ai.resources.autogen.models.RequiredFunctionToolCallDetails
    """

    type: Literal["function"] = rest_discriminator(name="type")  # type: ignore
    """The object type of the required tool call. Always 'function' for function tools. Required.
     Default value is \"function\"."""
    function: "_models.RequiredFunctionToolCallDetails" = rest_field()
    """Detailed information about the function to be executed by the tool that includes name and
     arguments. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        function: "_models.RequiredFunctionToolCallDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="function", **kwargs)


class RequiredFunctionToolCallDetails(_model_base.Model):
    """The detailed information for a function invocation, as provided by a required action invoking a
    function tool, that includes the name of and arguments to the function.


    :ivar name: The name of the function. Required.
    :vartype name: str
    :ivar arguments: The arguments to use when invoking the named function, as provided by the
     model. Arguments are presented as a JSON document that should be validated and parsed for
     evaluation. Required.
    :vartype arguments: str
    """

    name: str = rest_field()
    """The name of the function. Required."""
    arguments: str = rest_field()
    """The arguments to use when invoking the named function, as provided by the model. Arguments are
     presented as a JSON document that should be validated and parsed for evaluation. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        arguments: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunCompletionUsage(_model_base.Model):
    """Usage statistics related to the run. This value will be ``null`` if the run is not in a
    terminal state (i.e. ``in_progress``\\ , ``queued``\\ , etc.).


    :ivar completion_tokens: Number of completion tokens used over the course of the run. Required.
    :vartype completion_tokens: int
    :ivar prompt_tokens: Number of prompt tokens used over the course of the run. Required.
    :vartype prompt_tokens: int
    :ivar total_tokens: Total number of tokens used (prompt + completion). Required.
    :vartype total_tokens: int
    """

    completion_tokens: int = rest_field()
    """Number of completion tokens used over the course of the run. Required."""
    prompt_tokens: int = rest_field()
    """Number of prompt tokens used over the course of the run. Required."""
    total_tokens: int = rest_field()
    """Total number of tokens used (prompt + completion). Required."""

    @overload
    def __init__(
        self,
        *,
        completion_tokens: int,
        prompt_tokens: int,
        total_tokens: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunError(_model_base.Model):
    """The details of an error as encountered by an assistant thread run.


    :ivar code: The status for the error. Required.
    :vartype code: str
    :ivar message: The human-readable text associated with the error. Required.
    :vartype message: str
    """

    code: str = rest_field()
    """The status for the error. Required."""
    message: str = rest_field()
    """The human-readable text associated with the error. Required."""

    @overload
    def __init__(
        self,
        *,
        code: str,
        message: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStep(_model_base.Model):
    """Detailed information about a single step of an assistant thread run.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always 'thread.run.step'. Required. Default value is
     "thread.run.step".
    :vartype object: str
    :ivar type: The type of run step, which can be either message_creation or tool_calls. Required.
     Known values are: "message_creation" and "tool_calls".
    :vartype type: str or ~azure.ai.resources.autogen.models.RunStepType
    :ivar assistant_id: The ID of the assistant associated with the run step. Required.
    :vartype assistant_id: str
    :ivar thread_id: The ID of the thread that was run. Required.
    :vartype thread_id: str
    :ivar run_id: The ID of the run that this run step is a part of. Required.
    :vartype run_id: str
    :ivar status: The status of this run step. Required. Known values are: "in_progress",
     "cancelled", "failed", "completed", and "expired".
    :vartype status: str or ~azure.ai.resources.autogen.models.RunStepStatus
    :ivar step_details: The details for this run step. Required.
    :vartype step_details: ~azure.ai.resources.autogen.models.RunStepDetails
    :ivar last_error: If applicable, information about the last error encountered by this run step.
     Required.
    :vartype last_error: ~azure.ai.resources.autogen.models.RunStepError
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar expired_at: The Unix timestamp, in seconds, representing when this item expired.
     Required.
    :vartype expired_at: ~datetime.datetime
    :ivar completed_at: The Unix timestamp, in seconds, representing when this completed. Required.
    :vartype completed_at: ~datetime.datetime
    :ivar cancelled_at: The Unix timestamp, in seconds, representing when this was cancelled.
     Required.
    :vartype cancelled_at: ~datetime.datetime
    :ivar failed_at: The Unix timestamp, in seconds, representing when this failed. Required.
    :vartype failed_at: ~datetime.datetime
    :ivar usage: Usage statistics related to the run step. This value will be ``null`` while the
     run step's status is ``in_progress``.
    :vartype usage: ~azure.ai.resources.autogen.models.RunStepCompletionUsage
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["thread.run.step"] = rest_field()
    """The object type, which is always 'thread.run.step'. Required. Default value is
     \"thread.run.step\"."""
    type: Union[str, "_models.RunStepType"] = rest_field()
    """The type of run step, which can be either message_creation or tool_calls. Required. Known
     values are: \"message_creation\" and \"tool_calls\"."""
    assistant_id: str = rest_field()
    """The ID of the assistant associated with the run step. Required."""
    thread_id: str = rest_field()
    """The ID of the thread that was run. Required."""
    run_id: str = rest_field()
    """The ID of the run that this run step is a part of. Required."""
    status: Union[str, "_models.RunStepStatus"] = rest_field()
    """The status of this run step. Required. Known values are: \"in_progress\", \"cancelled\",
     \"failed\", \"completed\", and \"expired\"."""
    step_details: "_models.RunStepDetails" = rest_field()
    """The details for this run step. Required."""
    last_error: "_models.RunStepError" = rest_field()
    """If applicable, information about the last error encountered by this run step. Required."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    expired_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this item expired. Required."""
    completed_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this completed. Required."""
    cancelled_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this was cancelled. Required."""
    failed_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this failed. Required."""
    usage: Optional["_models.RunStepCompletionUsage"] = rest_field()
    """Usage statistics related to the run step. This value will be ``null`` while the run step's
     status is ``in_progress``."""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.RunStepType"],
        assistant_id: str,
        thread_id: str,
        run_id: str,
        status: Union[str, "_models.RunStepStatus"],
        step_details: "_models.RunStepDetails",
        last_error: "_models.RunStepError",
        created_at: datetime.datetime,
        expired_at: datetime.datetime,
        completed_at: datetime.datetime,
        cancelled_at: datetime.datetime,
        failed_at: datetime.datetime,
        metadata: Dict[str, str],
        usage: Optional["_models.RunStepCompletionUsage"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["thread.run.step"] = "thread.run.step"


class RunStepCodeInterpreterToolCallOutput(_model_base.Model):
    """An abstract representation of an emitted output from a code interpreter tool.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    RunStepCodeInterpreterImageOutput, RunStepCodeInterpreterLogOutput


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepCodeInterpreterImageOutput(RunStepCodeInterpreterToolCallOutput, discriminator="image"):
    """A representation of an image output emitted by a code interpreter tool in response to a tool
    call by the model.


    :ivar type: The object type, which is always 'image'. Required. Default value is "image".
    :vartype type: str
    :ivar image: Referential information for the image associated with this output. Required.
    :vartype image: ~azure.ai.resources.autogen.models.RunStepCodeInterpreterImageReference
    """

    type: Literal["image"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'image'. Required. Default value is \"image\"."""
    image: "_models.RunStepCodeInterpreterImageReference" = rest_field()
    """Referential information for the image associated with this output. Required."""

    @overload
    def __init__(
        self,
        *,
        image: "_models.RunStepCodeInterpreterImageReference",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="image", **kwargs)


class RunStepCodeInterpreterImageReference(_model_base.Model):
    """An image reference emitted by a code interpreter tool in response to a tool call by the model.


    :ivar file_id: The ID of the file associated with this image. Required.
    :vartype file_id: str
    """

    file_id: str = rest_field()
    """The ID of the file associated with this image. Required."""

    @overload
    def __init__(
        self,
        *,
        file_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepCodeInterpreterLogOutput(RunStepCodeInterpreterToolCallOutput, discriminator="logs"):
    """A representation of a log output emitted by a code interpreter tool in response to a tool call
    by the model.


    :ivar type: The object type, which is always 'logs'. Required. Default value is "logs".
    :vartype type: str
    :ivar logs: The serialized log output emitted by the code interpreter. Required.
    :vartype logs: str
    """

    type: Literal["logs"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'logs'. Required. Default value is \"logs\"."""
    logs: str = rest_field()
    """The serialized log output emitted by the code interpreter. Required."""

    @overload
    def __init__(
        self,
        *,
        logs: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="logs", **kwargs)


class RunStepToolCall(_model_base.Model):
    """An abstract representation of a detailed tool call as recorded within a run step for an
    existing run.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    RunStepCodeInterpreterToolCall, RunStepFileSearchToolCall, RunStepFunctionToolCall


    :ivar type: The object type. Required. Default value is None.
    :vartype type: str
    :ivar id: The ID of the tool call. This ID must be referenced when you submit tool outputs.
     Required.
    :vartype id: str
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Default value is None."""
    id: str = rest_field()
    """The ID of the tool call. This ID must be referenced when you submit tool outputs. Required."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepCodeInterpreterToolCall(RunStepToolCall, discriminator="code_interpreter"):
    """A record of a call to a code interpreter tool, issued by the model in evaluation of a defined
    tool, that represents inputs and outputs consumed and emitted by the code interpreter.


    :ivar id: The ID of the tool call. This ID must be referenced when you submit tool outputs.
     Required.
    :vartype id: str
    :ivar type: The object type, which is always 'code_interpreter'. Required. Default value is
     "code_interpreter".
    :vartype type: str
    :ivar code_interpreter: The details of the tool call to the code interpreter tool. Required.
    :vartype code_interpreter:
     ~azure.ai.resources.autogen.models.RunStepCodeInterpreterToolCallDetails
    """

    type: Literal["code_interpreter"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'code_interpreter'. Required. Default value is
     \"code_interpreter\"."""
    code_interpreter: "_models.RunStepCodeInterpreterToolCallDetails" = rest_field()
    """The details of the tool call to the code interpreter tool. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        code_interpreter: "_models.RunStepCodeInterpreterToolCallDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="code_interpreter", **kwargs)


class RunStepCodeInterpreterToolCallDetails(_model_base.Model):
    """The detailed information about a code interpreter invocation by the model.


    :ivar input: The input provided by the model to the code interpreter tool. Required.
    :vartype input: str
    :ivar outputs: The outputs produced by the code interpreter tool back to the model in response
     to the tool call. Required.
    :vartype outputs: list[~azure.ai.resources.autogen.models.RunStepCodeInterpreterToolCallOutput]
    """

    input: str = rest_field()
    """The input provided by the model to the code interpreter tool. Required."""
    outputs: List["_models.RunStepCodeInterpreterToolCallOutput"] = rest_field()
    """The outputs produced by the code interpreter tool back to the model in response to the tool
     call. Required."""

    @overload
    def __init__(
        self,
        *,
        input: str,
        outputs: List["_models.RunStepCodeInterpreterToolCallOutput"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepCompletionUsage(_model_base.Model):
    """Usage statistics related to the run step.


    :ivar completion_tokens: Number of completion tokens used over the course of the run step.
     Required.
    :vartype completion_tokens: int
    :ivar prompt_tokens: Number of prompt tokens used over the course of the run step. Required.
    :vartype prompt_tokens: int
    :ivar total_tokens: Total number of tokens used (prompt + completion). Required.
    :vartype total_tokens: int
    """

    completion_tokens: int = rest_field()
    """Number of completion tokens used over the course of the run step. Required."""
    prompt_tokens: int = rest_field()
    """Number of prompt tokens used over the course of the run step. Required."""
    total_tokens: int = rest_field()
    """Total number of tokens used (prompt + completion). Required."""

    @overload
    def __init__(
        self,
        *,
        completion_tokens: int,
        prompt_tokens: int,
        total_tokens: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepDetails(_model_base.Model):
    """An abstract representation of the details for a run step.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    RunStepMessageCreationDetails, RunStepToolCallDetails


    :ivar type: The object type. Required. Known values are: "message_creation" and "tool_calls".
    :vartype type: str or ~azure.ai.resources.autogen.models.RunStepType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Known values are: \"message_creation\" and \"tool_calls\"."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepError(_model_base.Model):
    """The error information associated with a failed run step.


    :ivar code: The error code for this error. Required. Known values are: "server_error" and
     "rate_limit_exceeded".
    :vartype code: str or ~azure.ai.resources.autogen.models.RunStepErrorCode
    :ivar message: The human-readable text associated with this error. Required.
    :vartype message: str
    """

    code: Union[str, "_models.RunStepErrorCode"] = rest_field()
    """The error code for this error. Required. Known values are: \"server_error\" and
     \"rate_limit_exceeded\"."""
    message: str = rest_field()
    """The human-readable text associated with this error. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Union[str, "_models.RunStepErrorCode"],
        message: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepFileSearchToolCall(RunStepToolCall, discriminator="file_search"):
    """A record of a call to a file search tool, issued by the model in evaluation of a defined tool,
    that represents executed file search.


    :ivar id: The ID of the tool call. This ID must be referenced when you submit tool outputs.
     Required.
    :vartype id: str
    :ivar type: The object type, which is always 'file_search'. Required. Default value is
     "file_search".
    :vartype type: str
    :ivar file_search: Reserved for future use. Required.
    :vartype file_search: dict[str, str]
    """

    type: Literal["file_search"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'file_search'. Required. Default value is \"file_search\"."""
    file_search: Dict[str, str] = rest_field()
    """Reserved for future use. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        file_search: Dict[str, str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="file_search", **kwargs)


class RunStepFunctionToolCall(RunStepToolCall, discriminator="function"):
    """A record of a call to a function tool, issued by the model in evaluation of a defined tool,
    that represents the inputs and output consumed and emitted by the specified function.


    :ivar id: The ID of the tool call. This ID must be referenced when you submit tool outputs.
     Required.
    :vartype id: str
    :ivar type: The object type, which is always 'function'. Required. Default value is "function".
    :vartype type: str
    :ivar function: The detailed information about the function called by the model. Required.
    :vartype function: ~azure.ai.resources.autogen.models.RunStepFunctionToolCallDetails
    """

    type: Literal["function"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'function'. Required. Default value is \"function\"."""
    function: "_models.RunStepFunctionToolCallDetails" = rest_field()
    """The detailed information about the function called by the model. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        function: "_models.RunStepFunctionToolCallDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="function", **kwargs)


class RunStepFunctionToolCallDetails(_model_base.Model):
    """The detailed information about the function called by the model.


    :ivar name: The name of the function. Required.
    :vartype name: str
    :ivar arguments: The arguments that the model requires are provided to the named function.
     Required.
    :vartype arguments: str
    :ivar output: The output of the function, only populated for function calls that have already
     have had their outputs submitted. Required.
    :vartype output: str
    """

    name: str = rest_field()
    """The name of the function. Required."""
    arguments: str = rest_field()
    """The arguments that the model requires are provided to the named function. Required."""
    output: str = rest_field()
    """The output of the function, only populated for function calls that have already have had their
     outputs submitted. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        arguments: str,
        output: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepMessageCreationDetails(RunStepDetails, discriminator="message_creation"):
    """The detailed information associated with a message creation run step.


    :ivar type: The object type, which is always 'message_creation'. Required. Represents a run
     step to create a message.
    :vartype type: str or ~azure.ai.resources.autogen.models.MESSAGE_CREATION
    :ivar message_creation: Information about the message creation associated with this run step.
     Required.
    :vartype message_creation: ~azure.ai.resources.autogen.models.RunStepMessageCreationReference
    """

    type: Literal[RunStepType.MESSAGE_CREATION] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'message_creation'. Required. Represents a run step to create
     a message."""
    message_creation: "_models.RunStepMessageCreationReference" = rest_field()
    """Information about the message creation associated with this run step. Required."""

    @overload
    def __init__(
        self,
        *,
        message_creation: "_models.RunStepMessageCreationReference",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=RunStepType.MESSAGE_CREATION, **kwargs)


class RunStepMessageCreationReference(_model_base.Model):
    """The details of a message created as a part of a run step.


    :ivar message_id: The ID of the message created by this run step. Required.
    :vartype message_id: str
    """

    message_id: str = rest_field()
    """The ID of the message created by this run step. Required."""

    @overload
    def __init__(
        self,
        *,
        message_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RunStepToolCallDetails(RunStepDetails, discriminator="tool_calls"):
    """The detailed information associated with a run step calling tools.


    :ivar type: The object type, which is always 'tool_calls'. Required. Represents a run step that
     calls tools.
    :vartype type: str or ~azure.ai.resources.autogen.models.TOOL_CALLS
    :ivar tool_calls: A list of tool call details for this run step. Required.
    :vartype tool_calls: list[~azure.ai.resources.autogen.models.RunStepToolCall]
    """

    type: Literal[RunStepType.TOOL_CALLS] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'tool_calls'. Required. Represents a run step that calls
     tools."""
    tool_calls: List["_models.RunStepToolCall"] = rest_field()
    """A list of tool call details for this run step. Required."""

    @overload
    def __init__(
        self,
        *,
        tool_calls: List["_models.RunStepToolCall"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=RunStepType.TOOL_CALLS, **kwargs)


class SasCredential(BaseCredential, discriminator="SAS"):
    """SAS Credential definition.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar name: Credential name. Required.
    :vartype name: str
    :ivar sas_token: SAS Token. Required.
    :vartype sas_token: str
    :ivar type: Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.SAS
    """

    sas_token: str = rest_field(name="sasToken", visibility=["read"])
    """SAS Token. Required."""
    type: Literal[CredentialType.SAS] = rest_discriminator(name="type")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=CredentialType.SAS, **kwargs)


class SkuCapacity(_model_base.Model):
    """SKU capacity information.

    :ivar default: Gets or sets the default capacity.
    :vartype default: int
    :ivar maximum: Gets or sets the maximum.
    :vartype maximum: int
    :ivar minimum: Gets or sets the minimum.
    :vartype minimum: int
    :ivar scale_type: Gets or sets the type of the scale. Known values are: "Automatic", "Manual",
     and "None".
    :vartype scale_type: str or ~azure.ai.resources.autogen.models.SkuScaleType
    """

    default: Optional[int] = rest_field()
    """Gets or sets the default capacity."""
    maximum: Optional[int] = rest_field()
    """Gets or sets the maximum."""
    minimum: Optional[int] = rest_field()
    """Gets or sets the minimum."""
    scale_type: Optional[Union[str, "_models.SkuScaleType"]] = rest_field(name="scaleType")
    """Gets or sets the type of the scale. Known values are: \"Automatic\", \"Manual\", and \"None\"."""

    @overload
    def __init__(
        self,
        *,
        default: Optional[int] = None,
        maximum: Optional[int] = None,
        minimum: Optional[int] = None,
        scale_type: Optional[Union[str, "_models.SkuScaleType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SkuResource(_model_base.Model):
    """Fulfills ARM Contract requirement to list all available SKUS for a resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar capacity: Gets or sets the Sku Capacity.
    :vartype capacity: ~azure.ai.resources.autogen.models.SkuCapacity
    :ivar resource_type: The resource type name.
    :vartype resource_type: str
    :ivar sku: Gets or sets the Sku.
    :vartype sku: ~azure.ai.resources.autogen.models.SkuSetting
    """

    capacity: Optional["_models.SkuCapacity"] = rest_field()
    """Gets or sets the Sku Capacity."""
    resource_type: Optional[str] = rest_field(name="resourceType", visibility=["read"])
    """The resource type name."""
    sku: Optional["_models.SkuSetting"] = rest_field()
    """Gets or sets the Sku."""

    @overload
    def __init__(
        self,
        *,
        capacity: Optional["_models.SkuCapacity"] = None,
        sku: Optional["_models.SkuSetting"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SkuSetting(_model_base.Model):
    """SkuSetting fulfills the need for stripped down SKU info in ARM contract.


    :ivar name: [Required] The name of the SKU. Ex - P3. It is typically a letter+number code.
     Required.
    :vartype name: str
    :ivar tier: This field is required to be implemented by the Resource Provider if the service
     has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
     "Standard", and "Premium".
    :vartype tier: str or ~azure.ai.resources.autogen.models.SkuTier
    """

    name: str = rest_field()
    """[Required] The name of the SKU. Ex - P3. It is typically a letter+number code. Required."""
    tier: Optional[Union[str, "_models.SkuTier"]] = rest_field()
    """This field is required to be implemented by the Resource Provider if the service has more than
     one tier, but is not required on a PUT. Known values are: \"Free\", \"Basic\", \"Standard\",
     and \"Premium\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        tier: Optional[Union[str, "_models.SkuTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SubmitToolOutputsAction(RequiredAction, discriminator="submit_tool_outputs"):
    """The details for required tool calls that must be submitted for an assistant thread run to
    continue.


    :ivar type: The object type, which is always 'submit_tool_outputs'. Required. Default value is
     "submit_tool_outputs".
    :vartype type: str
    :ivar submit_tool_outputs: The details describing tools that should be called to submit tool
     outputs. Required.
    :vartype submit_tool_outputs: ~azure.ai.resources.autogen.models.SubmitToolOutputsDetails
    """

    type: Literal["submit_tool_outputs"] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'submit_tool_outputs'. Required. Default value is
     \"submit_tool_outputs\"."""
    submit_tool_outputs: "_models.SubmitToolOutputsDetails" = rest_field()
    """The details describing tools that should be called to submit tool outputs. Required."""

    @overload
    def __init__(
        self,
        *,
        submit_tool_outputs: "_models.SubmitToolOutputsDetails",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type="submit_tool_outputs", **kwargs)


class SubmitToolOutputsDetails(_model_base.Model):
    """The details describing tools that should be called to submit tool outputs.


    :ivar tool_calls: The list of tool calls that must be resolved for the assistant thread run to
     continue. Required.
    :vartype tool_calls: list[~azure.ai.resources.autogen.models.RequiredToolCall]
    """

    tool_calls: List["_models.RequiredToolCall"] = rest_field()
    """The list of tool calls that must be resolved for the assistant thread run to continue.
     Required."""

    @overload
    def __init__(
        self,
        *,
        tool_calls: List["_models.RequiredToolCall"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemData(_model_base.Model):
    """Metadata pertaining to creation and last modification of the resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar created_at: The timestamp the resource was created at.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: The identity that created the resource.
    :vartype created_by: str
    :ivar created_by_type: The identity type that created the resource.
    :vartype created_by_type: str
    :ivar last_modified_at: The timestamp of resource last modification (UTC).
    :vartype last_modified_at: ~datetime.datetime
    """

    created_at: Optional[datetime.datetime] = rest_field(name="createdAt", visibility=["read"], format="rfc3339")
    """The timestamp the resource was created at."""
    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read"])
    """The identity that created the resource."""
    created_by_type: Optional[str] = rest_field(name="createdByType", visibility=["read"])
    """The identity type that created the resource."""
    last_modified_at: Optional[datetime.datetime] = rest_field(
        name="lastModifiedAt", visibility=["read"], format="rfc3339"
    )
    """The timestamp of resource last modification (UTC)."""


class ThreadDeletionStatus(_model_base.Model):
    """The status of a thread deletion operation.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The ID of the resource specified for deletion. Required.
    :vartype id: str
    :ivar deleted: A value indicating whether deletion was successful. Required.
    :vartype deleted: bool
    :ivar object: The object type, which is always 'thread.deleted'. Required. Default value is
     "thread.deleted".
    :vartype object: str
    """

    id: str = rest_field()
    """The ID of the resource specified for deletion. Required."""
    deleted: bool = rest_field()
    """A value indicating whether deletion was successful. Required."""
    object: Literal["thread.deleted"] = rest_field()
    """The object type, which is always 'thread.deleted'. Required. Default value is
     \"thread.deleted\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        deleted: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["thread.deleted"] = "thread.deleted"


class ThreadMessage(_model_base.Model):
    """A single, existing message within an assistant thread.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always 'thread.message'. Required. Default value is
     "thread.message".
    :vartype object: str
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar thread_id: The ID of the thread that this message belongs to. Required.
    :vartype thread_id: str
    :ivar status: The status of the message. Required. Known values are: "in_progress",
     "incomplete", and "completed".
    :vartype status: str or ~azure.ai.resources.autogen.models.MessageStatus
    :ivar incomplete_details: On an incomplete message, details about why the message is
     incomplete. Required.
    :vartype incomplete_details: ~azure.ai.resources.autogen.models.MessageIncompleteDetails
    :ivar completed_at: The Unix timestamp (in seconds) for when the message was completed.
     Required.
    :vartype completed_at: ~datetime.datetime
    :ivar incomplete_at: The Unix timestamp (in seconds) for when the message was marked as
     incomplete. Required.
    :vartype incomplete_at: ~datetime.datetime
    :ivar role: The role associated with the assistant thread message. Required. Known values are:
     "user" and "assistant".
    :vartype role: str or ~azure.ai.resources.autogen.models.MessageRole
    :ivar content: The list of content items associated with the assistant thread message.
     Required.
    :vartype content: list[~azure.ai.resources.autogen.models.MessageContent]
    :ivar assistant_id: If applicable, the ID of the assistant that authored this message.
     Required.
    :vartype assistant_id: str
    :ivar run_id: If applicable, the ID of the run associated with the authoring of this message.
     Required.
    :vartype run_id: str
    :ivar attachments: A list of files attached to the message, and the tools they were added to.
     Required.
    :vartype attachments: list[~azure.ai.resources.autogen.models.MessageAttachment]
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["thread.message"] = rest_field()
    """The object type, which is always 'thread.message'. Required. Default value is
     \"thread.message\"."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    thread_id: str = rest_field()
    """The ID of the thread that this message belongs to. Required."""
    status: Union[str, "_models.MessageStatus"] = rest_field()
    """The status of the message. Required. Known values are: \"in_progress\", \"incomplete\", and
     \"completed\"."""
    incomplete_details: "_models.MessageIncompleteDetails" = rest_field()
    """On an incomplete message, details about why the message is incomplete. Required."""
    completed_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the message was completed. Required."""
    incomplete_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the message was marked as incomplete. Required."""
    role: Union[str, "_models.MessageRole"] = rest_field()
    """The role associated with the assistant thread message. Required. Known values are: \"user\" and
     \"assistant\"."""
    content: List["_models.MessageContent"] = rest_field()
    """The list of content items associated with the assistant thread message. Required."""
    assistant_id: str = rest_field()
    """If applicable, the ID of the assistant that authored this message. Required."""
    run_id: str = rest_field()
    """If applicable, the ID of the run associated with the authoring of this message. Required."""
    attachments: List["_models.MessageAttachment"] = rest_field()
    """A list of files attached to the message, and the tools they were added to. Required."""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        created_at: datetime.datetime,
        thread_id: str,
        status: Union[str, "_models.MessageStatus"],
        incomplete_details: "_models.MessageIncompleteDetails",
        completed_at: datetime.datetime,
        incomplete_at: datetime.datetime,
        role: Union[str, "_models.MessageRole"],
        content: List["_models.MessageContent"],
        assistant_id: str,
        run_id: str,
        attachments: List["_models.MessageAttachment"],
        metadata: Dict[str, str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["thread.message"] = "thread.message"


class ThreadMessageOptions(_model_base.Model):
    """A single message within an assistant thread, as provided during that thread's creation for its
    initial state.

    All required parameters must be populated in order to send to server.

    :ivar role: The role of the entity that is creating the message. Allowed values include:


     * ``user``\\ : Indicates the message is sent by an actual user and should be used in most
     cases to represent user-generated messages.
     * ``assistant``\\ : Indicates the message is generated by the assistant. Use this value to
     insert messages from the assistant into
       the conversation. Required. Known values are: "user" and "assistant".
    :vartype role: str or ~azure.ai.resources.autogen.models.MessageRole
    :ivar content: The textual content of the initial message. Currently, robust input including
     images and annotated text may only be provided via
     a separate call to the create message API. Required.
    :vartype content: str
    :ivar attachments: A list of files attached to the message, and the tools they should be added
     to.
    :vartype attachments: list[~azure.ai.resources.autogen.models.MessageAttachment]
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    role: Union[str, "_models.MessageRole"] = rest_field()
    """The role of the entity that is creating the message. Allowed values include:
     
     
     * ``user``\ : Indicates the message is sent by an actual user and should be used in most cases
     to represent user-generated messages.
     * ``assistant``\ : Indicates the message is generated by the assistant. Use this value to
     insert messages from the assistant into
       the conversation. Required. Known values are: \"user\" and \"assistant\"."""
    content: str = rest_field()
    """The textual content of the initial message. Currently, robust input including images and
     annotated text may only be provided via
     a separate call to the create message API. Required."""
    attachments: Optional[List["_models.MessageAttachment"]] = rest_field()
    """A list of files attached to the message, and the tools they should be added to."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        role: Union[str, "_models.MessageRole"],
        content: str,
        attachments: Optional[List["_models.MessageAttachment"]] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ThreadRun(_model_base.Model):
    """Data representing a single evaluation run of an assistant thread.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always 'thread.run'. Required. Default value is
     "thread.run".
    :vartype object: str
    :ivar thread_id: The ID of the thread associated with this run. Required.
    :vartype thread_id: str
    :ivar assistant_id: The ID of the assistant associated with the thread this run was performed
     against. Required.
    :vartype assistant_id: str
    :ivar status: The status of the assistant thread run. Required. Known values are: "queued",
     "in_progress", "requires_action", "cancelling", "cancelled", "failed", "completed", and
     "expired".
    :vartype status: str or ~azure.ai.resources.autogen.models.RunStatus
    :ivar required_action: The details of the action required for the assistant thread run to
     continue.
    :vartype required_action: ~azure.ai.resources.autogen.models.RequiredAction
    :ivar last_error: The last error, if any, encountered by this assistant thread run. Required.
    :vartype last_error: ~azure.ai.resources.autogen.models.RunError
    :ivar model: The ID of the model to use. Required.
    :vartype model: str
    :ivar instructions: The overridden system instructions used for this assistant thread run.
     Required.
    :vartype instructions: str
    :ivar tools: The overridden enabled tools used for this assistant thread run. Required.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar created_at: The Unix timestamp, in seconds, representing when this object was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar expires_at: The Unix timestamp, in seconds, representing when this item expires.
     Required.
    :vartype expires_at: ~datetime.datetime
    :ivar started_at: The Unix timestamp, in seconds, representing when this item was started.
     Required.
    :vartype started_at: ~datetime.datetime
    :ivar completed_at: The Unix timestamp, in seconds, representing when this completed. Required.
    :vartype completed_at: ~datetime.datetime
    :ivar cancelled_at: The Unix timestamp, in seconds, representing when this was cancelled.
     Required.
    :vartype cancelled_at: ~datetime.datetime
    :ivar failed_at: The Unix timestamp, in seconds, representing when this failed. Required.
    :vartype failed_at: ~datetime.datetime
    :ivar incomplete_details: Details on why the run is incomplete. Will be ``null`` if the run is
     not incomplete. Required. Known values are: "max_completion_tokens" and "max_prompt_tokens".
    :vartype incomplete_details: str or ~azure.ai.resources.autogen.models.IncompleteRunDetails
    :ivar usage: Usage statistics related to the run. This value will be ``null`` if the run is not
     in a terminal state (i.e. ``in_progress``\\ , ``queued``\\ , etc.). Required.
    :vartype usage: ~azure.ai.resources.autogen.models.RunCompletionUsage
    :ivar temperature: The sampling temperature used for this run. If not set, defaults to 1.
    :vartype temperature: float
    :ivar top_p: The nucleus sampling value used for this run. If not set, defaults to 1.
    :vartype top_p: float
    :ivar max_prompt_tokens: The maximum number of prompt tokens specified to have been used over
     the course of the run. Required.
    :vartype max_prompt_tokens: int
    :ivar max_completion_tokens: The maximum number of completion tokens specified to have been
     used over the course of the run. Required.
    :vartype max_completion_tokens: int
    :ivar truncation_strategy: The strategy to use for dropping messages as the context windows
     moves forward. Required.
    :vartype truncation_strategy: ~azure.ai.resources.autogen.models.TruncationObject
    :ivar tool_choice: Controls whether or not and which tool is called by the model. Required. Is
     one of the following types: str, Union[str, "_models.AssistantsApiToolChoiceOptionMode"],
     AssistantsNamedToolChoice
    :vartype tool_choice: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiToolChoiceOptionMode or
     ~azure.ai.resources.autogen.models.AssistantsNamedToolChoice
    :ivar response_format: The response format of the tool calls used in this run. Required. Is one
     of the following types: str, Union[str, "_models.AssistantsApiResponseFormatMode"],
     AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["thread.run"] = rest_field()
    """The object type, which is always 'thread.run'. Required. Default value is \"thread.run\"."""
    thread_id: str = rest_field()
    """The ID of the thread associated with this run. Required."""
    assistant_id: str = rest_field()
    """The ID of the assistant associated with the thread this run was performed against. Required."""
    status: Union[str, "_models.RunStatus"] = rest_field()
    """The status of the assistant thread run. Required. Known values are: \"queued\",
     \"in_progress\", \"requires_action\", \"cancelling\", \"cancelled\", \"failed\", \"completed\",
     and \"expired\"."""
    required_action: Optional["_models.RequiredAction"] = rest_field()
    """The details of the action required for the assistant thread run to continue."""
    last_error: "_models.RunError" = rest_field()
    """The last error, if any, encountered by this assistant thread run. Required."""
    model: str = rest_field()
    """The ID of the model to use. Required."""
    instructions: str = rest_field()
    """The overridden system instructions used for this assistant thread run. Required."""
    tools: List["_models.ToolDefinition"] = rest_field()
    """The overridden enabled tools used for this assistant thread run. Required."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this object was created. Required."""
    expires_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this item expires. Required."""
    started_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this item was started. Required."""
    completed_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this completed. Required."""
    cancelled_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this was cancelled. Required."""
    failed_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp, in seconds, representing when this failed. Required."""
    incomplete_details: Union[str, "_models.IncompleteRunDetails"] = rest_field()
    """Details on why the run is incomplete. Will be ``null`` if the run is not incomplete. Required.
     Known values are: \"max_completion_tokens\" and \"max_prompt_tokens\"."""
    usage: "_models.RunCompletionUsage" = rest_field()
    """Usage statistics related to the run. This value will be ``null`` if the run is not in a
     terminal state (i.e. ``in_progress``\ , ``queued``\ , etc.). Required."""
    temperature: Optional[float] = rest_field()
    """The sampling temperature used for this run. If not set, defaults to 1."""
    top_p: Optional[float] = rest_field()
    """The nucleus sampling value used for this run. If not set, defaults to 1."""
    max_prompt_tokens: int = rest_field()
    """The maximum number of prompt tokens specified to have been used over the course of the run.
     Required."""
    max_completion_tokens: int = rest_field()
    """The maximum number of completion tokens specified to have been used over the course of the run.
     Required."""
    truncation_strategy: "_models.TruncationObject" = rest_field()
    """The strategy to use for dropping messages as the context windows moves forward. Required."""
    tool_choice: "_types.AssistantsApiToolChoiceOption" = rest_field()
    """Controls whether or not and which tool is called by the model. Required. Is one of the
     following types: str, Union[str, \"_models.AssistantsApiToolChoiceOptionMode\"],
     AssistantsNamedToolChoice"""
    response_format: "_types.AssistantsApiResponseFormatOption" = rest_field()
    """The response format of the tool calls used in this run. Required. Is one of the following
     types: str, Union[str, \"_models.AssistantsApiResponseFormatMode\"],
     AssistantsApiResponseFormat"""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        thread_id: str,
        assistant_id: str,
        status: Union[str, "_models.RunStatus"],
        last_error: "_models.RunError",
        model: str,
        instructions: str,
        tools: List["_models.ToolDefinition"],
        created_at: datetime.datetime,
        expires_at: datetime.datetime,
        started_at: datetime.datetime,
        completed_at: datetime.datetime,
        cancelled_at: datetime.datetime,
        failed_at: datetime.datetime,
        incomplete_details: Union[str, "_models.IncompleteRunDetails"],
        usage: "_models.RunCompletionUsage",
        max_prompt_tokens: int,
        max_completion_tokens: int,
        truncation_strategy: "_models.TruncationObject",
        tool_choice: "_types.AssistantsApiToolChoiceOption",
        response_format: "_types.AssistantsApiResponseFormatOption",
        metadata: Dict[str, str],
        required_action: Optional["_models.RequiredAction"] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["thread.run"] = "thread.run"


class ToolOutput(_model_base.Model):
    """The data provided during a tool outputs submission to resolve pending tool calls and allow the
    model to continue.

    :ivar tool_call_id: The ID of the tool call being resolved, as provided in the tool calls of a
     required action from a run.
    :vartype tool_call_id: str
    :ivar output: The output from the tool to be submitted.
    :vartype output: str
    """

    tool_call_id: Optional[str] = rest_field()
    """The ID of the tool call being resolved, as provided in the tool calls of a required action from
     a run."""
    output: Optional[str] = rest_field()
    """The output from the tool to be submitted."""

    @overload
    def __init__(
        self,
        *,
        tool_call_id: Optional[str] = None,
        output: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ToolResources(_model_base.Model):
    """A set of resources that are used by the assistant's tools. The resources are specific to the
    type of tool. For example, the ``code_interpreter`` tool requires a list of file IDs, while the
    ``file_search`` tool requires a list of vector store IDs.

    :ivar code_interpreter: Resources to be used by the ``code_interpreter tool`` consisting of
     file IDs.
    :vartype code_interpreter: ~azure.ai.resources.autogen.models.CodeInterpreterToolResource
    :ivar file_search: Resources to be used by the ``file_search`` tool consisting of vector store
     IDs.
    :vartype file_search: ~azure.ai.resources.autogen.models.FileSearchToolResource
    """

    code_interpreter: Optional["_models.CodeInterpreterToolResource"] = rest_field()
    """Resources to be used by the ``code_interpreter tool`` consisting of file IDs."""
    file_search: Optional["_models.FileSearchToolResource"] = rest_field()
    """Resources to be used by the ``file_search`` tool consisting of vector store IDs."""

    @overload
    def __init__(
        self,
        *,
        code_interpreter: Optional["_models.CodeInterpreterToolResource"] = None,
        file_search: Optional["_models.FileSearchToolResource"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TruncationObject(_model_base.Model):
    """Controls for how a thread will be truncated prior to the run. Use this to control the initial
    context window of the run.


    :ivar type: The truncation strategy to use for the thread. The default is ``auto``. If set to
     ``last_messages``\\ , the thread will
     be truncated to the ``lastMessages`` count most recent messages in the thread. When set to
     ``auto``\\ , messages in the middle of the thread
     will be dropped to fit the context length of the model, ``max_prompt_tokens``. Required. Known
     values are: "auto" and "last_messages".
    :vartype type: str or ~azure.ai.resources.autogen.models.TruncationStrategy
    :ivar last_messages: The number of most recent messages from the thread when constructing the
     context for the run.
    :vartype last_messages: int
    """

    type: Union[str, "_models.TruncationStrategy"] = rest_field()
    """The truncation strategy to use for the thread. The default is ``auto``. If set to
     ``last_messages``\ , the thread will
     be truncated to the ``lastMessages`` count most recent messages in the thread. When set to
     ``auto``\ , messages in the middle of the thread
     will be dropped to fit the context length of the model, ``max_prompt_tokens``. Required. Known
     values are: \"auto\" and \"last_messages\"."""
    last_messages: Optional[int] = rest_field()
    """The number of most recent messages from the thread when constructing the context for the run."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.TruncationStrategy"],
        last_messages: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateAssistantOptions(_model_base.Model):
    """The request details to use when modifying an existing assistant.

    :ivar model: The ID of the model to use.
    :vartype model: str
    :ivar name: The modified name for the assistant to use.
    :vartype name: str
    :ivar description: The modified description for the assistant to use.
    :vartype description: str
    :ivar instructions: The modified system instructions for the new assistant to use.
    :vartype instructions: str
    :ivar tools: The modified collection of tools to enable for the assistant.
    :vartype tools: list[~azure.ai.resources.autogen.models.ToolDefinition]
    :ivar tool_resources: A set of resources that are used by the assistant's tools. The resources
     are specific to the type of tool. For example, the ``code_interpreter`` tool requires a list of
     file IDs, while the ``file_search`` tool requires a list of vector store IDs.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.UpdateToolResourcesOptions
    :ivar temperature: What sampling temperature to use, between 0 and 2. Higher values like 0.8
     will make the output more random, while lower values like 0.2 will make it more focused and
     deterministic.
    :vartype temperature: float
    :ivar top_p: An alternative to sampling with temperature, called nucleus sampling, where the
     model considers the results of the tokens with top_p probability mass. So 0.1 means only the
     tokens comprising the top 10% probability mass are considered. We generally recommend altering
     this or temperature but not both.
    :vartype top_p: float
    :ivar response_format: The response format of the tool calls used by this assistant. Is one of
     the following types: str, Union[str, "_models.AssistantsApiResponseFormatMode"],
     AssistantsApiResponseFormat
    :vartype response_format: str or str or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormatMode or
     ~azure.ai.resources.autogen.models.AssistantsApiResponseFormat
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    model: Optional[str] = rest_field()
    """The ID of the model to use."""
    name: Optional[str] = rest_field()
    """The modified name for the assistant to use."""
    description: Optional[str] = rest_field()
    """The modified description for the assistant to use."""
    instructions: Optional[str] = rest_field()
    """The modified system instructions for the new assistant to use."""
    tools: Optional[List["_models.ToolDefinition"]] = rest_field()
    """The modified collection of tools to enable for the assistant."""
    tool_resources: Optional["_models.UpdateToolResourcesOptions"] = rest_field()
    """A set of resources that are used by the assistant's tools. The resources are specific to the
     type of tool. For example, the ``code_interpreter`` tool requires a list of file IDs, while the
     ``file_search`` tool requires a list of vector store IDs."""
    temperature: Optional[float] = rest_field()
    """What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
     more random, while lower values like 0.2 will make it more focused and deterministic."""
    top_p: Optional[float] = rest_field()
    """An alternative to sampling with temperature, called nucleus sampling, where the model considers
     the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
     the top 10% probability mass are considered. We generally recommend altering this or
     temperature but not both."""
    response_format: Optional["_types.AssistantsApiResponseFormatOption"] = rest_field()
    """The response format of the tool calls used by this assistant. Is one of the following types:
     str, Union[str, \"_models.AssistantsApiResponseFormatMode\"], AssistantsApiResponseFormat"""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        model: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        instructions: Optional[str] = None,
        tools: Optional[List["_models.ToolDefinition"]] = None,
        tool_resources: Optional["_models.UpdateToolResourcesOptions"] = None,
        temperature: Optional[float] = None,
        top_p: Optional[float] = None,
        response_format: Optional["_types.AssistantsApiResponseFormatOption"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateAssistantThreadOptions(_model_base.Model):
    """The details used to update an existing assistant thread.

    :ivar tool_resources: A set of resources that are made available to the assistant's tools in
     this thread. The resources are specific to the type of tool. For example, the
     ``code_interpreter`` tool requires a list of file IDs, while the ``file_search`` tool requires
     a list of vector store IDs.
    :vartype tool_resources: ~azure.ai.resources.autogen.models.UpdateToolResourcesOptions
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    tool_resources: Optional["_models.UpdateToolResourcesOptions"] = rest_field()
    """A set of resources that are made available to the assistant's tools in this thread. The
     resources are specific to the type of tool. For example, the ``code_interpreter`` tool requires
     a list of file IDs, while the ``file_search`` tool requires a list of vector store IDs."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        tool_resources: Optional["_models.UpdateToolResourcesOptions"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateCodeInterpreterToolResourceOptions(_model_base.Model):
    """Request object to update ``code_interpreted`` tool resources.

    :ivar file_ids: A list of file IDs to override the current list of the assistant.
    :vartype file_ids: list[str]
    """

    file_ids: Optional[List[str]] = rest_field()
    """A list of file IDs to override the current list of the assistant."""

    @overload
    def __init__(
        self,
        *,
        file_ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateEvaluationRequest(_model_base.Model):
    """Update Evaluation Request.

    All required parameters must be populated in order to send to server.

    :ivar tags: Tags to be updated. Required.
    :vartype tags: dict[str, str]
    :ivar display_name: Display Name. Required.
    :vartype display_name: str
    :ivar description: Description. Required.
    :vartype description: str
    """

    tags: Dict[str, str] = rest_field()
    """Tags to be updated. Required."""
    display_name: str = rest_field(name="displayName")
    """Display Name. Required."""
    description: str = rest_field()
    """Description. Required."""

    @overload
    def __init__(
        self,
        *,
        tags: Dict[str, str],
        display_name: str,
        description: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateFileSearchToolResourceOptions(_model_base.Model):
    """Request object to update ``file_search`` tool resources.

    :ivar vector_store_ids: A list of vector store IDs to override the current list of the
     assistant.
    :vartype vector_store_ids: list[str]
    """

    vector_store_ids: Optional[List[str]] = rest_field()
    """A list of vector store IDs to override the current list of the assistant."""

    @overload
    def __init__(
        self,
        *,
        vector_store_ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateToolResourcesOptions(_model_base.Model):
    """Request object. A set of resources that are used by the assistant's tools. The resources are
    specific to the type of tool. For example, the ``code_interpreter`` tool requires a list of
    file IDs, while the ``file_search`` tool requires a list of vector store IDs.

    :ivar code_interpreter: Overrides the list of file IDs made available to the
     ``code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.
    :vartype code_interpreter:
     ~azure.ai.resources.autogen.models.UpdateCodeInterpreterToolResourceOptions
    :ivar file_search: Overrides the vector store attached to this assistant. There can be a
     maximum of 1 vector store attached to the assistant.
    :vartype file_search: ~azure.ai.resources.autogen.models.UpdateFileSearchToolResourceOptions
    """

    code_interpreter: Optional["_models.UpdateCodeInterpreterToolResourceOptions"] = rest_field()
    """Overrides the list of file IDs made available to the ``code_interpreter`` tool. There can be a
     maximum of 20 files associated with the tool."""
    file_search: Optional["_models.UpdateFileSearchToolResourceOptions"] = rest_field()
    """Overrides the vector store attached to this assistant. There can be a maximum of 1 vector store
     attached to the assistant."""

    @overload
    def __init__(
        self,
        *,
        code_interpreter: Optional["_models.UpdateCodeInterpreterToolResourceOptions"] = None,
        file_search: Optional["_models.UpdateFileSearchToolResourceOptions"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UriFileDataVersion(DataVersionBase, discriminator="uri_file"):
    """UriFileDataVersion Definition.


    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     https://go.microsoft.com/fwlink/?linkid=2202330. Required.
    :vartype data_uri: str
    :ivar data_type: [Required] Specifies the type of data. Required. URI file.
    :vartype data_type: str or ~azure.ai.resources.autogen.models.URI_FILE
    """

    data_type: Literal[DataType.URI_FILE] = rest_discriminator(name="dataType")  # type: ignore
    """[Required] Specifies the type of data. Required. URI file."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, data_type=DataType.URI_FILE, **kwargs)


class UriFolderDataVersion(DataVersionBase, discriminator="uri_folder"):
    """UriFolderDataVersion Definition.


    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     https://go.microsoft.com/fwlink/?linkid=2202330. Required.
    :vartype data_uri: str
    :ivar data_type: [Required] Specifies the type of data. Required. URI folder.
    :vartype data_type: str or ~azure.ai.resources.autogen.models.URI_FOLDER
    """

    data_type: Literal[DataType.URI_FOLDER] = rest_discriminator(name="dataType")  # type: ignore
    """[Required] Specifies the type of data. Required. URI folder."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, data_type=DataType.URI_FOLDER, **kwargs)


class VectorStore(_model_base.Model):
    """A vector store is a collection of processed files can be used by the ``file_search`` tool.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always ``vector_store``. Required. Default value is
     "vector_store".
    :vartype object: str
    :ivar created_at: The Unix timestamp (in seconds) for when the vector store was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar name: The name of the vector store. Required.
    :vartype name: str
    :ivar usage_bytes: The total number of bytes used by the files in the vector store. Required.
    :vartype usage_bytes: int
    :ivar file_counts: Files count grouped by status processed or being processed by this vector
     store. Required.
    :vartype file_counts: ~azure.ai.resources.autogen.models.VectorStoreFileCount
    :ivar status: The status of the vector store, which can be either ``expired``\\ ,
     ``in_progress``\\ , or ``completed``. A status of ``completed`` indicates that the vector store
     is ready for use. Required. Known values are: "expired", "in_progress", and "completed".
    :vartype status: str or ~azure.ai.resources.autogen.models.VectorStoreStatus
    :ivar expires_after: Details on when this vector store expires.
    :vartype expires_after: ~azure.ai.resources.autogen.models.VectorStoreExpirationPolicy
    :ivar expires_at: The Unix timestamp (in seconds) for when the vector store will expire.
    :vartype expires_at: ~datetime.datetime
    :ivar last_active_at: The Unix timestamp (in seconds) for when the vector store was last
     active. Required.
    :vartype last_active_at: ~datetime.datetime
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required.
    :vartype metadata: dict[str, str]
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["vector_store"] = rest_field()
    """The object type, which is always ``vector_store``. Required. Default value is \"vector_store\"."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the vector store was created. Required."""
    name: str = rest_field()
    """The name of the vector store. Required."""
    usage_bytes: int = rest_field()
    """The total number of bytes used by the files in the vector store. Required."""
    file_counts: "_models.VectorStoreFileCount" = rest_field()
    """Files count grouped by status processed or being processed by this vector store. Required."""
    status: Union[str, "_models.VectorStoreStatus"] = rest_field()
    """The status of the vector store, which can be either ``expired``\ , ``in_progress``\ , or
     ``completed``. A status of ``completed`` indicates that the vector store is ready for use.
     Required. Known values are: \"expired\", \"in_progress\", and \"completed\"."""
    expires_after: Optional["_models.VectorStoreExpirationPolicy"] = rest_field()
    """Details on when this vector store expires."""
    expires_at: Optional[datetime.datetime] = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the vector store will expire."""
    last_active_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the vector store was last active. Required."""
    metadata: Dict[str, str] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        created_at: datetime.datetime,
        name: str,
        usage_bytes: int,
        file_counts: "_models.VectorStoreFileCount",
        status: Union[str, "_models.VectorStoreStatus"],
        last_active_at: datetime.datetime,
        metadata: Dict[str, str],
        expires_after: Optional["_models.VectorStoreExpirationPolicy"] = None,
        expires_at: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["vector_store"] = "vector_store"


class VectorStoreChunkingStrategyRequest(_model_base.Model):
    """An abstract representation of a vector store chunking strategy configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    VectorStoreAutoChunkingStrategyRequest, VectorStoreStaticChunkingStrategyRequest

    All required parameters must be populated in order to send to server.

    :ivar type: The object type. Required. Known values are: "auto" and "static".
    :vartype type: str or ~azure.ai.resources.autogen.models.VectorStoreChunkingStrategyRequestType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Known values are: \"auto\" and \"static\"."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreAutoChunkingStrategyRequest(VectorStoreChunkingStrategyRequest, discriminator="auto"):
    """The default strategy. This strategy currently uses a max_chunk_size_tokens of 800 and
    chunk_overlap_tokens of 400.

    All required parameters must be populated in order to send to server.

    :ivar type: The object type, which is always 'auto'. Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.AUTO
    """

    type: Literal[VectorStoreChunkingStrategyRequestType.AUTO] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'auto'. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=VectorStoreChunkingStrategyRequestType.AUTO, **kwargs)


class VectorStoreChunkingStrategyResponse(_model_base.Model):
    """An abstract representation of a vector store chunking strategy configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    VectorStoreAutoChunkingStrategyResponse, VectorStoreStaticChunkingStrategyResponse


    :ivar type: The object type. Required. Known values are: "other" and "static".
    :vartype type: str or
     ~azure.ai.resources.autogen.models.VectorStoreChunkingStrategyResponseType
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The object type. Required. Known values are: \"other\" and \"static\"."""

    @overload
    def __init__(
        self,
        *,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreAutoChunkingStrategyResponse(VectorStoreChunkingStrategyResponse, discriminator="other"):
    """This is returned when the chunking strategy is unknown. Typically, this is because the file was
    indexed before the chunking_strategy concept was introduced in the API.


    :ivar type: The object type, which is always 'other'. Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.OTHER
    """

    type: Literal[VectorStoreChunkingStrategyResponseType.OTHER] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'other'. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=VectorStoreChunkingStrategyResponseType.OTHER, **kwargs)


class VectorStoreDeletionStatus(_model_base.Model):
    """Response object for deleting a vector store.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The ID of the resource specified for deletion. Required.
    :vartype id: str
    :ivar deleted: A value indicating whether deletion was successful. Required.
    :vartype deleted: bool
    :ivar object: The object type, which is always 'vector_store.deleted'. Required. Default value
     is "vector_store.deleted".
    :vartype object: str
    """

    id: str = rest_field()
    """The ID of the resource specified for deletion. Required."""
    deleted: bool = rest_field()
    """A value indicating whether deletion was successful. Required."""
    object: Literal["vector_store.deleted"] = rest_field()
    """The object type, which is always 'vector_store.deleted'. Required. Default value is
     \"vector_store.deleted\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        deleted: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["vector_store.deleted"] = "vector_store.deleted"


class VectorStoreExpirationPolicy(_model_base.Model):
    """The expiration policy for a vector store.


    :ivar anchor: Anchor timestamp after which the expiration policy applies. Supported anchors:
     ``last_active_at``. Required. "last_active_at"
    :vartype anchor: str or ~azure.ai.resources.autogen.models.VectorStoreExpirationPolicyAnchor
    :ivar days: The anchor timestamp after which the expiration policy applies. Required.
    :vartype days: int
    """

    anchor: Union[str, "_models.VectorStoreExpirationPolicyAnchor"] = rest_field()
    """Anchor timestamp after which the expiration policy applies. Supported anchors:
     ``last_active_at``. Required. \"last_active_at\""""
    days: int = rest_field()
    """The anchor timestamp after which the expiration policy applies. Required."""

    @overload
    def __init__(
        self,
        *,
        anchor: Union[str, "_models.VectorStoreExpirationPolicyAnchor"],
        days: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreFile(_model_base.Model):
    """Description of a file attached to a vector store.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always ``vector_store.file``. Required. Default value
     is "vector_store.file".
    :vartype object: str
    :ivar usage_bytes: The total vector store usage in bytes. Note that this may be different from
     the original file size. Required.
    :vartype usage_bytes: int
    :ivar created_at: The Unix timestamp (in seconds) for when the vector store file was created.
     Required.
    :vartype created_at: ~datetime.datetime
    :ivar vector_store_id: The ID of the vector store that the file is attached to. Required.
    :vartype vector_store_id: str
    :ivar status: The status of the vector store file, which can be either ``in_progress``\\ ,
     ``completed``\\ , ``cancelled``\\ , or ``failed``. The status ``completed`` indicates that the
     vector store file is ready for use. Required. Known values are: "in_progress", "completed",
     "failed", and "cancelled".
    :vartype status: str or ~azure.ai.resources.autogen.models.VectorStoreFileStatus
    :ivar last_error: The last error associated with this vector store file. Will be ``null`` if
     there are no errors. Required.
    :vartype last_error: ~azure.ai.resources.autogen.models.VectorStoreFileError
    :ivar chunking_strategy: The strategy used to chunk the file. Required.
    :vartype chunking_strategy:
     ~azure.ai.resources.autogen.models.VectorStoreChunkingStrategyResponse
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["vector_store.file"] = rest_field()
    """The object type, which is always ``vector_store.file``. Required. Default value is
     \"vector_store.file\"."""
    usage_bytes: int = rest_field()
    """The total vector store usage in bytes. Note that this may be different from the original file
     size. Required."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the vector store file was created. Required."""
    vector_store_id: str = rest_field()
    """The ID of the vector store that the file is attached to. Required."""
    status: Union[str, "_models.VectorStoreFileStatus"] = rest_field()
    """The status of the vector store file, which can be either ``in_progress``\ , ``completed``\ ,
     ``cancelled``\ , or ``failed``. The status ``completed`` indicates that the vector store file
     is ready for use. Required. Known values are: \"in_progress\", \"completed\", \"failed\", and
     \"cancelled\"."""
    last_error: "_models.VectorStoreFileError" = rest_field()
    """The last error associated with this vector store file. Will be ``null`` if there are no errors.
     Required."""
    chunking_strategy: "_models.VectorStoreChunkingStrategyResponse" = rest_field()
    """The strategy used to chunk the file. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        usage_bytes: int,
        created_at: datetime.datetime,
        vector_store_id: str,
        status: Union[str, "_models.VectorStoreFileStatus"],
        last_error: "_models.VectorStoreFileError",
        chunking_strategy: "_models.VectorStoreChunkingStrategyResponse",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["vector_store.file"] = "vector_store.file"


class VectorStoreFileBatch(_model_base.Model):
    """A batch of files attached to a vector store.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The identifier, which can be referenced in API endpoints. Required.
    :vartype id: str
    :ivar object: The object type, which is always ``vector_store.file_batch``. Required. Default
     value is "vector_store.files_batch".
    :vartype object: str
    :ivar created_at: The Unix timestamp (in seconds) for when the vector store files batch was
     created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar vector_store_id: The ID of the vector store that the file is attached to. Required.
    :vartype vector_store_id: str
    :ivar status: The status of the vector store files batch, which can be either ``in_progress``\\
     , ``completed``\\ , ``cancelled`` or ``failed``. Required. Known values are: "in_progress",
     "completed", "cancelled", and "failed".
    :vartype status: str or ~azure.ai.resources.autogen.models.VectorStoreFileBatchStatus
    :ivar file_counts: Files count grouped by status processed or being processed by this vector
     store. Required.
    :vartype file_counts: ~azure.ai.resources.autogen.models.VectorStoreFileCount
    """

    id: str = rest_field()
    """The identifier, which can be referenced in API endpoints. Required."""
    object: Literal["vector_store.files_batch"] = rest_field()
    """The object type, which is always ``vector_store.file_batch``. Required. Default value is
     \"vector_store.files_batch\"."""
    created_at: datetime.datetime = rest_field(format="unix-timestamp")
    """The Unix timestamp (in seconds) for when the vector store files batch was created. Required."""
    vector_store_id: str = rest_field()
    """The ID of the vector store that the file is attached to. Required."""
    status: Union[str, "_models.VectorStoreFileBatchStatus"] = rest_field()
    """The status of the vector store files batch, which can be either ``in_progress``\ ,
     ``completed``\ , ``cancelled`` or ``failed``. Required. Known values are: \"in_progress\",
     \"completed\", \"cancelled\", and \"failed\"."""
    file_counts: "_models.VectorStoreFileCount" = rest_field()
    """Files count grouped by status processed or being processed by this vector store. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        created_at: datetime.datetime,
        vector_store_id: str,
        status: Union[str, "_models.VectorStoreFileBatchStatus"],
        file_counts: "_models.VectorStoreFileCount",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["vector_store.files_batch"] = "vector_store.files_batch"


class VectorStoreFileCount(_model_base.Model):
    """Counts of files processed or being processed by this vector store grouped by status.


    :ivar in_progress: The number of files that are currently being processed. Required.
    :vartype in_progress: int
    :ivar completed: The number of files that have been successfully processed. Required.
    :vartype completed: int
    :ivar failed: The number of files that have failed to process. Required.
    :vartype failed: int
    :ivar cancelled: The number of files that were cancelled. Required.
    :vartype cancelled: int
    :ivar total: The total number of files. Required.
    :vartype total: int
    """

    in_progress: int = rest_field()
    """The number of files that are currently being processed. Required."""
    completed: int = rest_field()
    """The number of files that have been successfully processed. Required."""
    failed: int = rest_field()
    """The number of files that have failed to process. Required."""
    cancelled: int = rest_field()
    """The number of files that were cancelled. Required."""
    total: int = rest_field()
    """The total number of files. Required."""

    @overload
    def __init__(
        self,
        *,
        in_progress: int,
        completed: int,
        failed: int,
        cancelled: int,
        total: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreFileDeletionStatus(_model_base.Model):
    """Response object for deleting a vector store file relationship.

    Readonly variables are only populated by the server, and will be ignored when sending a request.


    :ivar id: The ID of the resource specified for deletion. Required.
    :vartype id: str
    :ivar deleted: A value indicating whether deletion was successful. Required.
    :vartype deleted: bool
    :ivar object: The object type, which is always 'vector_store.deleted'. Required. Default value
     is "vector_store.file.deleted".
    :vartype object: str
    """

    id: str = rest_field()
    """The ID of the resource specified for deletion. Required."""
    deleted: bool = rest_field()
    """A value indicating whether deletion was successful. Required."""
    object: Literal["vector_store.file.deleted"] = rest_field()
    """The object type, which is always 'vector_store.deleted'. Required. Default value is
     \"vector_store.file.deleted\"."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        deleted: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.object: Literal["vector_store.file.deleted"] = "vector_store.file.deleted"


class VectorStoreFileError(_model_base.Model):
    """Details on the error that may have ocurred while processing a file for this vector store.


    :ivar code: One of ``server_error`` or ``rate_limit_exceeded``. Required. Known values are:
     "internal_error", "file_not_found", "parsing_error", and "unhandled_mime_type".
    :vartype code: str or ~azure.ai.resources.autogen.models.VectorStoreFileErrorCode
    :ivar message: A human-readable description of the error. Required.
    :vartype message: str
    """

    code: Union[str, "_models.VectorStoreFileErrorCode"] = rest_field()
    """One of ``server_error`` or ``rate_limit_exceeded``. Required. Known values are:
     \"internal_error\", \"file_not_found\", \"parsing_error\", and \"unhandled_mime_type\"."""
    message: str = rest_field()
    """A human-readable description of the error. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Union[str, "_models.VectorStoreFileErrorCode"],
        message: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreOptions(_model_base.Model):
    """Request object for creating a vector store.

    :ivar file_ids: A list of file IDs that the vector store should use. Useful for tools like
     ``file_search`` that can access files.
    :vartype file_ids: list[str]
    :ivar name: The name of the vector store.
    :vartype name: str
    :ivar expires_after: Details on when this vector store expires.
    :vartype expires_after: ~azure.ai.resources.autogen.models.VectorStoreExpirationPolicy
    :ivar chunking_strategy: The chunking strategy used to chunk the file(s). If not set, will use
     the auto strategy. Only applicable if file_ids is non-empty.
    :vartype chunking_strategy:
     ~azure.ai.resources.autogen.models.VectorStoreChunkingStrategyRequest
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    file_ids: Optional[List[str]] = rest_field()
    """A list of file IDs that the vector store should use. Useful for tools like ``file_search`` that
     can access files."""
    name: Optional[str] = rest_field()
    """The name of the vector store."""
    expires_after: Optional["_models.VectorStoreExpirationPolicy"] = rest_field()
    """Details on when this vector store expires."""
    chunking_strategy: Optional["_models.VectorStoreChunkingStrategyRequest"] = rest_field()
    """The chunking strategy used to chunk the file(s). If not set, will use the auto strategy. Only
     applicable if file_ids is non-empty."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        file_ids: Optional[List[str]] = None,
        name: Optional[str] = None,
        expires_after: Optional["_models.VectorStoreExpirationPolicy"] = None,
        chunking_strategy: Optional["_models.VectorStoreChunkingStrategyRequest"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreStaticChunkingStrategyOptions(_model_base.Model):
    """Options to configure a vector store static chunking strategy.


    :ivar max_chunk_size_tokens: The maximum number of tokens in each chunk. The default value is
     800. The minimum value is 100 and the maximum value is 4096. Required.
    :vartype max_chunk_size_tokens: int
    :ivar chunk_overlap_tokens: The number of tokens that overlap between chunks. The default value
     is 400. Note that the overlap must not exceed half of max_chunk_size_tokens. Required.
    :vartype chunk_overlap_tokens: int
    """

    max_chunk_size_tokens: int = rest_field()
    """The maximum number of tokens in each chunk. The default value is 800. The minimum value is 100
     and the maximum value is 4096. Required."""
    chunk_overlap_tokens: int = rest_field()
    """The number of tokens that overlap between chunks. The default value is 400. Note that the
     overlap must not exceed half of max_chunk_size_tokens. Required."""

    @overload
    def __init__(
        self,
        *,
        max_chunk_size_tokens: int,
        chunk_overlap_tokens: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VectorStoreStaticChunkingStrategyRequest(VectorStoreChunkingStrategyRequest, discriminator="static"):
    """A statically configured chunking strategy.

    All required parameters must be populated in order to send to server.

    :ivar type: The object type, which is always 'static'. Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.STATIC
    :ivar static: The options for the static chunking strategy. Required.
    :vartype static: ~azure.ai.resources.autogen.models.VectorStoreStaticChunkingStrategyOptions
    """

    type: Literal[VectorStoreChunkingStrategyRequestType.STATIC] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'static'. Required."""
    static: "_models.VectorStoreStaticChunkingStrategyOptions" = rest_field()
    """The options for the static chunking strategy. Required."""

    @overload
    def __init__(
        self,
        *,
        static: "_models.VectorStoreStaticChunkingStrategyOptions",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=VectorStoreChunkingStrategyRequestType.STATIC, **kwargs)


class VectorStoreStaticChunkingStrategyResponse(
    VectorStoreChunkingStrategyResponse, discriminator="static"
):  # pylint: disable=name-too-long
    """A statically configured chunking strategy.


    :ivar type: The object type, which is always 'static'. Required.
    :vartype type: str or ~azure.ai.resources.autogen.models.STATIC
    :ivar static: The options for the static chunking strategy. Required.
    :vartype static: ~azure.ai.resources.autogen.models.VectorStoreStaticChunkingStrategyOptions
    """

    type: Literal[VectorStoreChunkingStrategyResponseType.STATIC] = rest_discriminator(name="type")  # type: ignore
    """The object type, which is always 'static'. Required."""
    static: "_models.VectorStoreStaticChunkingStrategyOptions" = rest_field()
    """The options for the static chunking strategy. Required."""

    @overload
    def __init__(
        self,
        *,
        static: "_models.VectorStoreStaticChunkingStrategyOptions",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=VectorStoreChunkingStrategyResponseType.STATIC, **kwargs)


class VectorStoreUpdateOptions(_model_base.Model):
    """Request object for updating a vector store.

    :ivar name: The name of the vector store.
    :vartype name: str
    :ivar expires_after: Details on when this vector store expires.
    :vartype expires_after: ~azure.ai.resources.autogen.models.VectorStoreExpirationPolicy
    :ivar metadata: A set of up to 16 key/value pairs that can be attached to an object, used for
     storing additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length.
    :vartype metadata: dict[str, str]
    """

    name: Optional[str] = rest_field()
    """The name of the vector store."""
    expires_after: Optional["_models.VectorStoreExpirationPolicy"] = rest_field()
    """Details on when this vector store expires."""
    metadata: Optional[Dict[str, str]] = rest_field()
    """A set of up to 16 key/value pairs that can be attached to an object, used for storing
     additional information about that object in a structured format. Keys may be up to 64
     characters in length and values may be up to 512 characters in length."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        expires_after: Optional["_models.VectorStoreExpirationPolicy"] = None,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VersionInfo(_model_base.Model):
    """Next version definition.


    :ivar next_version: Next version as defined by the server. The server keeps track of all
     versions that are string-representations of integers. If one exists, the nextVersion will be a
     string representation of the highest integer value + 1. Otherwise, the nextVersion will default
     to '1'.
    :vartype next_version: int
    :ivar latest_version: Current latest version of the resource. Required.
    :vartype latest_version: str
    """

    next_version: Optional[int] = rest_field(name="nextVersion")
    """Next version as defined by the server. The server keeps track of all versions that are
     string-representations of integers. If one exists, the nextVersion will be a string
     representation of the highest integer value + 1. Otherwise, the nextVersion will default to
     '1'."""
    latest_version: str = rest_field(name="latestVersion")
    """Current latest version of the resource. Required."""

    @overload
    def __init__(
        self,
        *,
        latest_version: str,
        next_version: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
