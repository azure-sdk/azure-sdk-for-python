# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, AsyncIterable, AsyncIterator, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_check_name_availability_operation_group_check_availability_request,
    build_diagnostic_resources_create_request,
    build_diagnostic_resources_get_request,
    build_discovery_solution_nlp_operation_group_discover_solutions_by_subscription_request,
    build_discovery_solution_nlp_operation_group_discover_solutions_request,
    build_discovery_solution_operation_group_list_request,
    build_operations_list_request,
    build_simplified_solutions_resources_create_request,
    build_simplified_solutions_resources_get_request,
    build_solution_resource_self_helps_get_request,
    build_solution_resources_create_request,
    build_solution_resources_get_request,
    build_solution_resources_update_request,
    build_solution_resources_warm_up_request,
    build_troubleshooter_resources_continue_method_request,
    build_troubleshooter_resources_create_request,
    build_troubleshooter_resources_end_request,
    build_troubleshooter_resources_get_request,
    build_troubleshooter_resources_restart_request,
)
from .._configuration import HelpClientConfiguration

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
        """List the operations for the provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.help.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DiagnosticResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`diagnostic_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, scope: str, diagnostics_resource_name: str, **kwargs: Any) -> _models.DiagnosticResource:
        """Get the diagnostics using the 'diagnosticsResourceName' you chose while creating the
        diagnostic.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param diagnostics_resource_name: Unique resource name for insight resources. Required.
        :type diagnostics_resource_name: str
        :return: DiagnosticResource. The DiagnosticResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiagnosticResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DiagnosticResource] = kwargs.pop("cls", None)

        _request = build_diagnostic_resources_get_request(
            scope=scope,
            diagnostics_resource_name=diagnostics_resource_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiagnosticResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        scope: str,
        diagnostics_resource_name: str,
        diagnostic_resource_request: Union[_models.DiagnosticResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(diagnostic_resource_request, (IOBase, bytes)):
            _content = diagnostic_resource_request
        else:
            _content = json.dumps(diagnostic_resource_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_diagnostic_resources_create_request(
            scope=scope,
            diagnostics_resource_name=diagnostics_resource_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        scope: str,
        diagnostics_resource_name: str,
        diagnostic_resource_request: _models.DiagnosticResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.DiagnosticResource]:
        """Creates a diagnostic for the specific resource using solutionId from discovery solutions.
        <br/>Diagnostics are powerful solutions that access product resources or other relevant data
        and provide the root cause of the issue and the steps to address the issue.<br/><br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param diagnostics_resource_name: Unique resource name for insight resources. Required.
        :type diagnostics_resource_name: str
        :param diagnostic_resource_request: The required request body for this insightResource
         invocation. Required.
        :type diagnostic_resource_request: ~azure.mgmt.help.models.DiagnosticResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns DiagnosticResource. The DiagnosticResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.DiagnosticResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        diagnostics_resource_name: str,
        diagnostic_resource_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.DiagnosticResource]:
        """Creates a diagnostic for the specific resource using solutionId from discovery solutions.
        <br/>Diagnostics are powerful solutions that access product resources or other relevant data
        and provide the root cause of the issue and the steps to address the issue.<br/><br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param diagnostics_resource_name: Unique resource name for insight resources. Required.
        :type diagnostics_resource_name: str
        :param diagnostic_resource_request: The required request body for this insightResource
         invocation. Required.
        :type diagnostic_resource_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns DiagnosticResource. The DiagnosticResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.DiagnosticResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        diagnostics_resource_name: str,
        diagnostic_resource_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.DiagnosticResource]:
        """Creates a diagnostic for the specific resource using solutionId from discovery solutions.
        <br/>Diagnostics are powerful solutions that access product resources or other relevant data
        and provide the root cause of the issue and the steps to address the issue.<br/><br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param diagnostics_resource_name: Unique resource name for insight resources. Required.
        :type diagnostics_resource_name: str
        :param diagnostic_resource_request: The required request body for this insightResource
         invocation. Required.
        :type diagnostic_resource_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns DiagnosticResource. The DiagnosticResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.DiagnosticResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create(
        self,
        scope: str,
        diagnostics_resource_name: str,
        diagnostic_resource_request: Union[_models.DiagnosticResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.DiagnosticResource]:
        """Creates a diagnostic for the specific resource using solutionId from discovery solutions.
        <br/>Diagnostics are powerful solutions that access product resources or other relevant data
        and provide the root cause of the issue and the steps to address the issue.<br/><br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param diagnostics_resource_name: Unique resource name for insight resources. Required.
        :type diagnostics_resource_name: str
        :param diagnostic_resource_request: The required request body for this insightResource
         invocation. Is one of the following types: DiagnosticResource, JSON, IO[bytes] Required.
        :type diagnostic_resource_request: ~azure.mgmt.help.models.DiagnosticResource or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns DiagnosticResource. The DiagnosticResource
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.DiagnosticResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DiagnosticResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                scope=scope,
                diagnostics_resource_name=diagnostics_resource_name,
                diagnostic_resource_request=diagnostic_resource_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.DiagnosticResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.DiagnosticResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.DiagnosticResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )


class SolutionResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`solution_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, scope: str, solution_resource_name: str, **kwargs: Any) -> _models.SolutionResource:
        """Get the solution using the applicable solutionResourceName while creating the solution.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :return: SolutionResource. The SolutionResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.SolutionResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SolutionResource] = kwargs.pop("cls", None)

        _request = build_solution_resources_get_request(
            scope=scope,
            solution_resource_name=solution_resource_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SolutionResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        scope: str,
        solution_resource_name: str,
        solution_request_body: Union[_models.SolutionResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(solution_request_body, (IOBase, bytes)):
            _content = solution_request_body
        else:
            _content = json.dumps(solution_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solution_resources_create_request(
            scope=scope,
            solution_resource_name=solution_resource_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        scope: str,
        solution_resource_name: str,
        solution_request_body: _models.SolutionResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Creates a solution for the specific Azure resource or subscription using the inputs ‘solutionId
        and requiredInputs’ from discovery solutions. <br/> Azure solutions comprise a comprehensive
        library of self-help resources that have been thoughtfully curated by Azure engineers to aid
        customers in resolving typical troubleshooting issues. These solutions encompass: <br/> (1.)
        Dynamic and context-aware diagnostics, guided troubleshooting wizards, and data visualizations.
        <br/> (2.) Rich instructional video tutorials and illustrative diagrams and images. <br/> (3.)
        Thoughtfully assembled textual troubleshooting instructions. <br/> All these components are
        seamlessly converged into unified solutions tailored to address a specific support problem
        area.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_request_body: The required request body for this solution resource creation.
         Required.
        :type solution_request_body: ~azure.mgmt.help.models.SolutionResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        solution_resource_name: str,
        solution_request_body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Creates a solution for the specific Azure resource or subscription using the inputs ‘solutionId
        and requiredInputs’ from discovery solutions. <br/> Azure solutions comprise a comprehensive
        library of self-help resources that have been thoughtfully curated by Azure engineers to aid
        customers in resolving typical troubleshooting issues. These solutions encompass: <br/> (1.)
        Dynamic and context-aware diagnostics, guided troubleshooting wizards, and data visualizations.
        <br/> (2.) Rich instructional video tutorials and illustrative diagrams and images. <br/> (3.)
        Thoughtfully assembled textual troubleshooting instructions. <br/> All these components are
        seamlessly converged into unified solutions tailored to address a specific support problem
        area.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_request_body: The required request body for this solution resource creation.
         Required.
        :type solution_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        solution_resource_name: str,
        solution_request_body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Creates a solution for the specific Azure resource or subscription using the inputs ‘solutionId
        and requiredInputs’ from discovery solutions. <br/> Azure solutions comprise a comprehensive
        library of self-help resources that have been thoughtfully curated by Azure engineers to aid
        customers in resolving typical troubleshooting issues. These solutions encompass: <br/> (1.)
        Dynamic and context-aware diagnostics, guided troubleshooting wizards, and data visualizations.
        <br/> (2.) Rich instructional video tutorials and illustrative diagrams and images. <br/> (3.)
        Thoughtfully assembled textual troubleshooting instructions. <br/> All these components are
        seamlessly converged into unified solutions tailored to address a specific support problem
        area.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_request_body: The required request body for this solution resource creation.
         Required.
        :type solution_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create(
        self,
        scope: str,
        solution_resource_name: str,
        solution_request_body: Union[_models.SolutionResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Creates a solution for the specific Azure resource or subscription using the inputs ‘solutionId
        and requiredInputs’ from discovery solutions. <br/> Azure solutions comprise a comprehensive
        library of self-help resources that have been thoughtfully curated by Azure engineers to aid
        customers in resolving typical troubleshooting issues. These solutions encompass: <br/> (1.)
        Dynamic and context-aware diagnostics, guided troubleshooting wizards, and data visualizations.
        <br/> (2.) Rich instructional video tutorials and illustrative diagrams and images. <br/> (3.)
        Thoughtfully assembled textual troubleshooting instructions. <br/> All these components are
        seamlessly converged into unified solutions tailored to address a specific support problem
        area.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_request_body: The required request body for this solution resource creation. Is
         one of the following types: SolutionResource, JSON, IO[bytes] Required.
        :type solution_request_body: ~azure.mgmt.help.models.SolutionResource or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SolutionResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                scope=scope,
                solution_resource_name=solution_resource_name,
                solution_request_body=solution_request_body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SolutionResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SolutionResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SolutionResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        scope: str,
        solution_resource_name: str,
        solution_patch_request_body: Union[_models.SolutionPatchRequestBody, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(solution_patch_request_body, (IOBase, bytes)):
            _content = solution_patch_request_body
        else:
            _content = json.dumps(solution_patch_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solution_resources_update_request(
            scope=scope,
            solution_resource_name=solution_resource_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        scope: str,
        solution_resource_name: str,
        solution_patch_request_body: _models.SolutionPatchRequestBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Update the requiredInputs or additional information needed to execute the solution.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_patch_request_body: The required request body for updating a solution resource.
         Required.
        :type solution_patch_request_body: ~azure.mgmt.help.models.SolutionPatchRequestBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_update(
        self,
        scope: str,
        solution_resource_name: str,
        solution_patch_request_body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Update the requiredInputs or additional information needed to execute the solution.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_patch_request_body: The required request body for updating a solution resource.
         Required.
        :type solution_patch_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_update(
        self,
        scope: str,
        solution_resource_name: str,
        solution_patch_request_body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Update the requiredInputs or additional information needed to execute the solution.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_patch_request_body: The required request body for updating a solution resource.
         Required.
        :type solution_patch_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_update(
        self,
        scope: str,
        solution_resource_name: str,
        solution_patch_request_body: Union[_models.SolutionPatchRequestBody, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SolutionResource]:
        """Update the requiredInputs or additional information needed to execute the solution.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_patch_request_body: The required request body for updating a solution resource.
         Is one of the following types: SolutionPatchRequestBody, JSON, IO[bytes] Required.
        :type solution_patch_request_body: ~azure.mgmt.help.models.SolutionPatchRequestBody or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns SolutionResource. The SolutionResource is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SolutionResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SolutionResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                scope=scope,
                solution_resource_name=solution_resource_name,
                solution_patch_request_body=solution_patch_request_body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SolutionResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SolutionResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SolutionResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def warm_up(
        self,
        scope: str,
        solution_resource_name: str,
        solution_warm_up_request_body: Optional[_models.SolutionWarmUpRequestBody] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Warm up the solution resource by preloading asynchronous diagnostics results into cache.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_warm_up_request_body: The required request body for warming up a solution
         resource. Default value is None.
        :type solution_warm_up_request_body: ~azure.mgmt.help.models.SolutionWarmUpRequestBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def warm_up(
        self,
        scope: str,
        solution_resource_name: str,
        solution_warm_up_request_body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Warm up the solution resource by preloading asynchronous diagnostics results into cache.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_warm_up_request_body: The required request body for warming up a solution
         resource. Default value is None.
        :type solution_warm_up_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def warm_up(
        self,
        scope: str,
        solution_resource_name: str,
        solution_warm_up_request_body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Warm up the solution resource by preloading asynchronous diagnostics results into cache.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_warm_up_request_body: The required request body for warming up a solution
         resource. Default value is None.
        :type solution_warm_up_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def warm_up(
        self,
        scope: str,
        solution_resource_name: str,
        solution_warm_up_request_body: Optional[Union[_models.SolutionWarmUpRequestBody, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Warm up the solution resource by preloading asynchronous diagnostics results into cache.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param solution_resource_name: Solution resource Name. Required.
        :type solution_resource_name: str
        :param solution_warm_up_request_body: The required request body for warming up a solution
         resource. Is one of the following types: SolutionWarmUpRequestBody, JSON, IO[bytes] Default
         value is None.
        :type solution_warm_up_request_body: ~azure.mgmt.help.models.SolutionWarmUpRequestBody or JSON
         or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(solution_warm_up_request_body, (IOBase, bytes)):
            _content = solution_warm_up_request_body
        else:
            if solution_warm_up_request_body is not None:
                _content = json.dumps(solution_warm_up_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_solution_resources_warm_up_request(
            scope=scope,
            solution_resource_name=solution_resource_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class SimplifiedSolutionsResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`simplified_solutions_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, scope: str, simplified_solutions_resource_name: str, **kwargs: Any
    ) -> _models.SimplifiedSolutionsResource:
        """Get the simplified Solutions using the applicable solutionResourceName while creating the
        simplified Solutions.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param simplified_solutions_resource_name: Simplified Solutions Resource Name. Required.
        :type simplified_solutions_resource_name: str
        :return: SimplifiedSolutionsResource. The SimplifiedSolutionsResource is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.SimplifiedSolutionsResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SimplifiedSolutionsResource] = kwargs.pop("cls", None)

        _request = build_simplified_solutions_resources_get_request(
            scope=scope,
            simplified_solutions_resource_name=simplified_solutions_resource_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SimplifiedSolutionsResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        scope: str,
        simplified_solutions_resource_name: str,
        simplified_solutions_request_body: Union[_models.SimplifiedSolutionsResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(simplified_solutions_request_body, (IOBase, bytes)):
            _content = simplified_solutions_request_body
        else:
            _content = json.dumps(simplified_solutions_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_simplified_solutions_resources_create_request(
            scope=scope,
            simplified_solutions_resource_name=simplified_solutions_resource_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        scope: str,
        simplified_solutions_resource_name: str,
        simplified_solutions_request_body: _models.SimplifiedSolutionsResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SimplifiedSolutionsResource]:
        """Creates Simplified Solutions for an Azure subscription using 'solutionId' from Discovery
        Solutions as the input. <br/><br/> Simplified Solutions API makes the consumption of solutions
        APIs easier while still providing access to the same powerful solutions rendered in Solutions
        API. With Simplified Solutions, users don't have to worry about stitching together the article
        using replacement maps and can use the content in the API response to directly render as HTML
        content.<br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param simplified_solutions_resource_name: Simplified Solutions Resource Name. Required.
        :type simplified_solutions_resource_name: str
        :param simplified_solutions_request_body: The required request body for simplified Solutions
         resource creation. Required.
        :type simplified_solutions_request_body: ~azure.mgmt.help.models.SimplifiedSolutionsResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SimplifiedSolutionsResource. The
         SimplifiedSolutionsResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SimplifiedSolutionsResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        simplified_solutions_resource_name: str,
        simplified_solutions_request_body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SimplifiedSolutionsResource]:
        """Creates Simplified Solutions for an Azure subscription using 'solutionId' from Discovery
        Solutions as the input. <br/><br/> Simplified Solutions API makes the consumption of solutions
        APIs easier while still providing access to the same powerful solutions rendered in Solutions
        API. With Simplified Solutions, users don't have to worry about stitching together the article
        using replacement maps and can use the content in the API response to directly render as HTML
        content.<br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param simplified_solutions_resource_name: Simplified Solutions Resource Name. Required.
        :type simplified_solutions_resource_name: str
        :param simplified_solutions_request_body: The required request body for simplified Solutions
         resource creation. Required.
        :type simplified_solutions_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SimplifiedSolutionsResource. The
         SimplifiedSolutionsResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SimplifiedSolutionsResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self,
        scope: str,
        simplified_solutions_resource_name: str,
        simplified_solutions_request_body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SimplifiedSolutionsResource]:
        """Creates Simplified Solutions for an Azure subscription using 'solutionId' from Discovery
        Solutions as the input. <br/><br/> Simplified Solutions API makes the consumption of solutions
        APIs easier while still providing access to the same powerful solutions rendered in Solutions
        API. With Simplified Solutions, users don't have to worry about stitching together the article
        using replacement maps and can use the content in the API response to directly render as HTML
        content.<br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param simplified_solutions_resource_name: Simplified Solutions Resource Name. Required.
        :type simplified_solutions_resource_name: str
        :param simplified_solutions_request_body: The required request body for simplified Solutions
         resource creation. Required.
        :type simplified_solutions_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns SimplifiedSolutionsResource. The
         SimplifiedSolutionsResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SimplifiedSolutionsResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create(
        self,
        scope: str,
        simplified_solutions_resource_name: str,
        simplified_solutions_request_body: Union[_models.SimplifiedSolutionsResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.SimplifiedSolutionsResource]:
        """Creates Simplified Solutions for an Azure subscription using 'solutionId' from Discovery
        Solutions as the input. <br/><br/> Simplified Solutions API makes the consumption of solutions
        APIs easier while still providing access to the same powerful solutions rendered in Solutions
        API. With Simplified Solutions, users don't have to worry about stitching together the article
        using replacement maps and can use the content in the API response to directly render as HTML
        content.<br/>.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param simplified_solutions_resource_name: Simplified Solutions Resource Name. Required.
        :type simplified_solutions_resource_name: str
        :param simplified_solutions_request_body: The required request body for simplified Solutions
         resource creation. Is one of the following types: SimplifiedSolutionsResource, JSON, IO[bytes]
         Required.
        :type simplified_solutions_request_body: ~azure.mgmt.help.models.SimplifiedSolutionsResource or
         JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns SimplifiedSolutionsResource. The
         SimplifiedSolutionsResource is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.help.models.SimplifiedSolutionsResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SimplifiedSolutionsResource] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                scope=scope,
                simplified_solutions_resource_name=simplified_solutions_resource_name,
                simplified_solutions_request_body=simplified_solutions_request_body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.SimplifiedSolutionsResource, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.SimplifiedSolutionsResource].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.SimplifiedSolutionsResource](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )


class TroubleshooterResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`troubleshooter_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, scope: str, troubleshooter_name: str, **kwargs: Any) -> _models.TroubleshooterResource:
        """Gets troubleshooter instance result which includes the step status/result of the troubleshooter
        resource name that is being executed.<br/> Get API is used to retrieve the result of a
        Troubleshooter instance, which includes the status and result of each step in the
        Troubleshooter workflow. This API requires the Troubleshooter resource name that was created
        using the Create API.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :return: TroubleshooterResource. The TroubleshooterResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.TroubleshooterResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TroubleshooterResource] = kwargs.pop("cls", None)

        _request = build_troubleshooter_resources_get_request(
            scope=scope,
            troubleshooter_name=troubleshooter_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TroubleshooterResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        scope: str,
        troubleshooter_name: str,
        create_troubleshooter_request_body: _models.TroubleshooterResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.TroubleshooterResource:
        """Creates the specific troubleshooter action under a resource or subscription using the
        ‘solutionId’ and  ‘properties.parameters’ as the trigger. <br/> Azure Troubleshooters help with
        hard to classify issues, reducing the gap between customer observed problems and solutions by
        guiding the user effortlessly through the troubleshooting process. Each Troubleshooter flow
        represents a problem area within Azure and has a complex tree-like structure that addresses
        many root causes. These flows are prepared with the help of Subject Matter experts and customer
        support engineers by carefully considering previous support requests raised by customers.
        Troubleshooters terminate at a well curated solution based off of resource backend signals and
        customer manual selections.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param create_troubleshooter_request_body: The required request body for this Troubleshooter
         resource creation. Required.
        :type create_troubleshooter_request_body: ~azure.mgmt.help.models.TroubleshooterResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TroubleshooterResource. The TroubleshooterResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.TroubleshooterResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self,
        scope: str,
        troubleshooter_name: str,
        create_troubleshooter_request_body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.TroubleshooterResource:
        """Creates the specific troubleshooter action under a resource or subscription using the
        ‘solutionId’ and  ‘properties.parameters’ as the trigger. <br/> Azure Troubleshooters help with
        hard to classify issues, reducing the gap between customer observed problems and solutions by
        guiding the user effortlessly through the troubleshooting process. Each Troubleshooter flow
        represents a problem area within Azure and has a complex tree-like structure that addresses
        many root causes. These flows are prepared with the help of Subject Matter experts and customer
        support engineers by carefully considering previous support requests raised by customers.
        Troubleshooters terminate at a well curated solution based off of resource backend signals and
        customer manual selections.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param create_troubleshooter_request_body: The required request body for this Troubleshooter
         resource creation. Required.
        :type create_troubleshooter_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TroubleshooterResource. The TroubleshooterResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.TroubleshooterResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self,
        scope: str,
        troubleshooter_name: str,
        create_troubleshooter_request_body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.TroubleshooterResource:
        """Creates the specific troubleshooter action under a resource or subscription using the
        ‘solutionId’ and  ‘properties.parameters’ as the trigger. <br/> Azure Troubleshooters help with
        hard to classify issues, reducing the gap between customer observed problems and solutions by
        guiding the user effortlessly through the troubleshooting process. Each Troubleshooter flow
        represents a problem area within Azure and has a complex tree-like structure that addresses
        many root causes. These flows are prepared with the help of Subject Matter experts and customer
        support engineers by carefully considering previous support requests raised by customers.
        Troubleshooters terminate at a well curated solution based off of resource backend signals and
        customer manual selections.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param create_troubleshooter_request_body: The required request body for this Troubleshooter
         resource creation. Required.
        :type create_troubleshooter_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TroubleshooterResource. The TroubleshooterResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.TroubleshooterResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self,
        scope: str,
        troubleshooter_name: str,
        create_troubleshooter_request_body: Union[_models.TroubleshooterResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.TroubleshooterResource:
        """Creates the specific troubleshooter action under a resource or subscription using the
        ‘solutionId’ and  ‘properties.parameters’ as the trigger. <br/> Azure Troubleshooters help with
        hard to classify issues, reducing the gap between customer observed problems and solutions by
        guiding the user effortlessly through the troubleshooting process. Each Troubleshooter flow
        represents a problem area within Azure and has a complex tree-like structure that addresses
        many root causes. These flows are prepared with the help of Subject Matter experts and customer
        support engineers by carefully considering previous support requests raised by customers.
        Troubleshooters terminate at a well curated solution based off of resource backend signals and
        customer manual selections.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param create_troubleshooter_request_body: The required request body for this Troubleshooter
         resource creation. Is one of the following types: TroubleshooterResource, JSON, IO[bytes]
         Required.
        :type create_troubleshooter_request_body: ~azure.mgmt.help.models.TroubleshooterResource or
         JSON or IO[bytes]
        :return: TroubleshooterResource. The TroubleshooterResource is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.TroubleshooterResource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TroubleshooterResource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(create_troubleshooter_request_body, (IOBase, bytes)):
            _content = create_troubleshooter_request_body
        else:
            _content = json.dumps(create_troubleshooter_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_troubleshooter_resources_create_request(
            scope=scope,
            troubleshooter_name=troubleshooter_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TroubleshooterResource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def continue_method(
        self,
        scope: str,
        troubleshooter_name: str,
        continue_request_body: Optional[_models.ContinueRequestBody] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Uses ‘stepId’ and ‘responses’ as the trigger to continue the troubleshooting steps for the
        respective troubleshooter resource name. <br/>Continue API is used to provide inputs that are
        required for the specific troubleshooter to progress into the next step in the process. This
        API is used after the Troubleshooter has been created using the Create API.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param continue_request_body: The required request body for going to next step in
         Troubleshooter resource. Default value is None.
        :type continue_request_body: ~azure.mgmt.help.models.ContinueRequestBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def continue_method(
        self,
        scope: str,
        troubleshooter_name: str,
        continue_request_body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Uses ‘stepId’ and ‘responses’ as the trigger to continue the troubleshooting steps for the
        respective troubleshooter resource name. <br/>Continue API is used to provide inputs that are
        required for the specific troubleshooter to progress into the next step in the process. This
        API is used after the Troubleshooter has been created using the Create API.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param continue_request_body: The required request body for going to next step in
         Troubleshooter resource. Default value is None.
        :type continue_request_body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def continue_method(
        self,
        scope: str,
        troubleshooter_name: str,
        continue_request_body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Uses ‘stepId’ and ‘responses’ as the trigger to continue the troubleshooting steps for the
        respective troubleshooter resource name. <br/>Continue API is used to provide inputs that are
        required for the specific troubleshooter to progress into the next step in the process. This
        API is used after the Troubleshooter has been created using the Create API.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param continue_request_body: The required request body for going to next step in
         Troubleshooter resource. Default value is None.
        :type continue_request_body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def continue_method(
        self,
        scope: str,
        troubleshooter_name: str,
        continue_request_body: Optional[Union[_models.ContinueRequestBody, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Uses ‘stepId’ and ‘responses’ as the trigger to continue the troubleshooting steps for the
        respective troubleshooter resource name. <br/>Continue API is used to provide inputs that are
        required for the specific troubleshooter to progress into the next step in the process. This
        API is used after the Troubleshooter has been created using the Create API.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :param continue_request_body: The required request body for going to next step in
         Troubleshooter resource. Is one of the following types: ContinueRequestBody, JSON, IO[bytes]
         Default value is None.
        :type continue_request_body: ~azure.mgmt.help.models.ContinueRequestBody or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(continue_request_body, (IOBase, bytes)):
            _content = continue_request_body
        else:
            if continue_request_body is not None:
                _content = json.dumps(continue_request_body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_troubleshooter_resources_continue_method_request(
            scope=scope,
            troubleshooter_name=troubleshooter_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def end(self, scope: str, troubleshooter_name: str, **kwargs: Any) -> None:
        """Ends the troubleshooter action.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_troubleshooter_resources_end_request(
            scope=scope,
            troubleshooter_name=troubleshooter_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def restart(
        self, scope: str, troubleshooter_name: str, **kwargs: Any
    ) -> _models.RestartTroubleshooterResponse:
        """Restarts the troubleshooter API using applicable troubleshooter resource name as the
        input.<br/> It returns new resource name which should be used in subsequent request. The old
        resource name is obsolete after this API is invoked.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param troubleshooter_name: Troubleshooter resource Name. Required.
        :type troubleshooter_name: str
        :return: RestartTroubleshooterResponse. The RestartTroubleshooterResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.RestartTroubleshooterResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RestartTroubleshooterResponse] = kwargs.pop("cls", None)

        _request = build_troubleshooter_resources_restart_request(
            scope=scope,
            troubleshooter_name=troubleshooter_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RestartTroubleshooterResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SolutionResourceSelfHelpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`solution_resource_self_helps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, solution_id: str, **kwargs: Any) -> _models.SolutionResourceSelfHelp:
        """Gets Self Help Solutions for a given solutionId. Self Help Solutions consist of rich
        instructional video tutorials, links and guides to public documentation related to a specific
        problem that enables users to troubleshoot Azure issues.

        :param solution_id: SolutionId is a unique id to identify a solution. You can retrieve the
         solution id using the Discovery api -
         `https://learn.microsoft.com/en-us/rest/api/help/discovery-solution/list?view=rest-help-2023-09-01-preview&tabs=HTTP
         <https://learn.microsoft.com/en-us/rest/api/help/discovery-solution/list?view=rest-help-2023-09-01-preview&tabs=HTTP>`_.
         Required.
        :type solution_id: str
        :return: SolutionResourceSelfHelp. The SolutionResourceSelfHelp is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.SolutionResourceSelfHelp
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SolutionResourceSelfHelp] = kwargs.pop("cls", None)

        _request = build_solution_resource_self_helps_get_request(
            solution_id=solution_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SolutionResourceSelfHelp, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CheckNameAvailabilityOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`check_name_availability_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def check_availability(
        self,
        scope: str,
        check_name_availability_request: Optional[_models.CheckNameAvailabilityRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CheckNameAvailabilityResponse:
        """This API is used to check the uniqueness of a resource name used for a diagnostic,
        troubleshooter or solutions.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param check_name_availability_request: The required parameters for availability check. Default
         value is None.
        :type check_name_availability_request: ~azure.mgmt.help.models.CheckNameAvailabilityRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CheckNameAvailabilityResponse. The CheckNameAvailabilityResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.CheckNameAvailabilityResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_availability(
        self,
        scope: str,
        check_name_availability_request: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CheckNameAvailabilityResponse:
        """This API is used to check the uniqueness of a resource name used for a diagnostic,
        troubleshooter or solutions.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param check_name_availability_request: The required parameters for availability check. Default
         value is None.
        :type check_name_availability_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CheckNameAvailabilityResponse. The CheckNameAvailabilityResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.CheckNameAvailabilityResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_availability(
        self,
        scope: str,
        check_name_availability_request: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CheckNameAvailabilityResponse:
        """This API is used to check the uniqueness of a resource name used for a diagnostic,
        troubleshooter or solutions.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param check_name_availability_request: The required parameters for availability check. Default
         value is None.
        :type check_name_availability_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CheckNameAvailabilityResponse. The CheckNameAvailabilityResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.CheckNameAvailabilityResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def check_availability(
        self,
        scope: str,
        check_name_availability_request: Optional[Union[_models.CheckNameAvailabilityRequest, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CheckNameAvailabilityResponse:
        """This API is used to check the uniqueness of a resource name used for a diagnostic,
        troubleshooter or solutions.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param check_name_availability_request: The required parameters for availability check. Is one
         of the following types: CheckNameAvailabilityRequest, JSON, IO[bytes] Default value is None.
        :type check_name_availability_request: ~azure.mgmt.help.models.CheckNameAvailabilityRequest or
         JSON or IO[bytes]
        :return: CheckNameAvailabilityResponse. The CheckNameAvailabilityResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.help.models.CheckNameAvailabilityResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(check_name_availability_request, (IOBase, bytes)):
            _content = check_name_availability_request
        else:
            if check_name_availability_request is not None:
                _content = json.dumps(check_name_availability_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_check_name_availability_operation_group_check_availability_request(
            scope=scope,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CheckNameAvailabilityResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DiscoverySolutionOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`discovery_solution_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, skiptoken: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.SolutionMetadataResource"]:
        """Lists the relevant Azure Diagnostics, Solutions and Troubleshooters using
        `problemClassification API
        <https://learn.microsoft.com/rest/api/support/problem-classifications/list?tabs=HTTP>`_) AND
        resourceUri or resourceType.<br/> Discovery Solutions is the initial entry point within Help
        API, which identifies relevant Azure diagnostics and solutions. <br/><br/> Required Input :
        problemClassificationId (Use the `problemClassification API
        <https://learn.microsoft.com/rest/api/support/problem-classifications/list?tabs=HTTP>`_)
        <br/>Optional input: resourceUri OR resource Type <br/><br/> <b>Note: </b>  ‘requiredInputs’
        from Discovery solutions response must be passed via ‘additionalParameters’ as an input to
        Diagnostics and Solutions API.

        :keyword filter: 'ProblemClassificationId' is a mandatory filter to get solutions ids. It also
         supports optional 'ResourceType' and 'SolutionType' filters. The `$filter
         <https://learn.microsoft.com/en-us/odata/webapi/first-odata-api#filter>`_ supports only 'and',
         'or' and 'eq' operators. Example: $filter=ProblemClassificationId eq
         '1ddda5b4-cf6c-4d4f-91ad-bc38ab0e811e'. Default value is None.
        :paramtype filter: str
        :keyword skiptoken: Skiptoken is only used if a previous operation returned a partial result.
         Default value is None.
        :paramtype skiptoken: str
        :return: An iterator like instance of SolutionMetadataResource
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.help.models.SolutionMetadataResource]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SolutionMetadataResource]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_discovery_solution_operation_group_list_request(
                    filter=filter,
                    skiptoken=skiptoken,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SolutionMetadataResource], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DiscoverySolutionNLPOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.help.aio.HelpClient`'s
        :attr:`discovery_solution_nlp_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: HelpClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def discover_solutions(
        self,
        discover_solution_request: _models.DiscoveryNlpRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: ~azure.mgmt.help.models.DiscoveryNlpRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_solutions(
        self, discover_solution_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_solutions(
        self, discover_solution_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def discover_solutions(
        self, discover_solution_request: Union[_models.DiscoveryNlpRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary.

        :param discover_solution_request: The request body. Is one of the following types:
         DiscoveryNlpRequest, JSON, IO[bytes] Required.
        :type discover_solution_request: ~azure.mgmt.help.models.DiscoveryNlpRequest or JSON or
         IO[bytes]
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DiscoveryNlpResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(discover_solution_request, (IOBase, bytes)):
            _content = discover_solution_request
        else:
            _content = json.dumps(discover_solution_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_discovery_solution_nlp_operation_group_discover_solutions_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiscoveryNlpResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def discover_solutions_by_subscription(
        self,
        discover_solution_request: _models.DiscoveryNlpRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary and subscription.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: ~azure.mgmt.help.models.DiscoveryNlpRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_solutions_by_subscription(
        self, discover_solution_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary and subscription.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def discover_solutions_by_subscription(
        self, discover_solution_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary and subscription.

        :param discover_solution_request: The request body. Required.
        :type discover_solution_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def discover_solutions_by_subscription(
        self, discover_solution_request: Union[_models.DiscoveryNlpRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.DiscoveryNlpResponse:
        """Search for relevant Azure Diagnostics, Solutions and Troubleshooters using a natural language
        issue summary and subscription.

        :param discover_solution_request: The request body. Is one of the following types:
         DiscoveryNlpRequest, JSON, IO[bytes] Required.
        :type discover_solution_request: ~azure.mgmt.help.models.DiscoveryNlpRequest or JSON or
         IO[bytes]
        :return: DiscoveryNlpResponse. The DiscoveryNlpResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.help.models.DiscoveryNlpResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DiscoveryNlpResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(discover_solution_request, (IOBase, bytes)):
            _content = discover_solution_request
        else:
            _content = json.dumps(discover_solution_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_discovery_solution_nlp_operation_group_discover_solutions_by_subscription_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DiscoveryNlpResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
