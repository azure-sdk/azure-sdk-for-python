# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
from typing import Any, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .._utils.model_base import Model as _Model, rest_discriminator, rest_field
from ._enums import PartitionScheme, ServiceKind

if TYPE_CHECKING:
    from .. import models as _models


class ApplicationDeltaHealthPolicy(_Model):
    """Defines a delta health policy used to evaluate the health of an application or one of its child
    entities when upgrading the cluster.

    :ivar default_service_type_delta_health_policy: The delta health policy used by default to
     evaluate the health of a service type when upgrading the cluster.
    :vartype default_service_type_delta_health_policy:
     ~azure.mgmt.servicefabric.models.ServiceTypeDeltaHealthPolicy
    :ivar service_type_delta_health_policies: The map with service type delta health policy per
     service type name. The map is empty by default.
    :vartype service_type_delta_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ServiceTypeDeltaHealthPolicy]
    """

    default_service_type_delta_health_policy: Optional["_models.ServiceTypeDeltaHealthPolicy"] = rest_field(
        name="defaultServiceTypeDeltaHealthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The delta health policy used by default to evaluate the health of a service type when upgrading
     the cluster."""
    service_type_delta_health_policies: Optional[dict[str, "_models.ServiceTypeDeltaHealthPolicy"]] = rest_field(
        name="serviceTypeDeltaHealthPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """The map with service type delta health policy per service type name. The map is empty by
     default."""

    @overload
    def __init__(
        self,
        *,
        default_service_type_delta_health_policy: Optional["_models.ServiceTypeDeltaHealthPolicy"] = None,
        service_type_delta_health_policies: Optional[dict[str, "_models.ServiceTypeDeltaHealthPolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationHealthPolicy(_Model):
    """Defines a health policy used to evaluate the health of an application or one of its children
    entities.

    :ivar default_service_type_health_policy: The health policy used by default to evaluate the
     health of a service type.
    :vartype default_service_type_health_policy:
     ~azure.mgmt.servicefabric.models.ServiceTypeHealthPolicy
    :ivar service_type_health_policies: The map with service type health policy per service type
     name. The map is empty by default.
    :vartype service_type_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ServiceTypeHealthPolicy]
    """

    default_service_type_health_policy: Optional["_models.ServiceTypeHealthPolicy"] = rest_field(
        name="defaultServiceTypeHealthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The health policy used by default to evaluate the health of a service type."""
    service_type_health_policies: Optional[dict[str, "_models.ServiceTypeHealthPolicy"]] = rest_field(
        name="serviceTypeHealthPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """The map with service type health policy per service type name. The map is empty by default."""

    @overload
    def __init__(
        self,
        *,
        default_service_type_health_policy: Optional["_models.ServiceTypeHealthPolicy"] = None,
        service_type_health_policies: Optional[dict[str, "_models.ServiceTypeHealthPolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationMetricDescription(_Model):
    """Describes capacity information for a custom resource balancing metric. This can be used to
    limit the total consumption of this metric by the services of this application.

    :ivar name: The name of the metric.
    :vartype name: str
    :ivar maximum_capacity: The maximum node capacity for Service Fabric application. This is the
     maximum Load for an instance of this application on a single node. Even if the capacity of node
     is greater than this value, Service Fabric will limit the total load of services within the
     application on each node to this value. If set to zero, capacity for this metric is unlimited
     on each node. When creating a new application with application capacity defined, the product of
     MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.
     When updating existing application with application capacity, the product of MaximumNodes and
     this value must always be smaller than or equal to TotalApplicationCapacity.
    :vartype maximum_capacity: int
    :ivar reservation_capacity: The node reservation capacity for Service Fabric application. This
     is the amount of load which is reserved on nodes which have instances of this application. If
     MinimumNodes is specified, then the product of these values will be the capacity reserved in
     the cluster for the application. If set to zero, no capacity is reserved for this metric. When
     setting application capacity or when updating application capacity; this value must be smaller
     than or equal to MaximumCapacity for each metric.
    :vartype reservation_capacity: int
    :ivar total_application_capacity: The total metric capacity for Service Fabric application.
     This is the total metric capacity for this application in the cluster. Service Fabric will try
     to limit the sum of loads of services within the application to this value. When creating a new
     application with application capacity defined, the product of MaximumNodes and MaximumCapacity
     must always be smaller than or equal to this value.
    :vartype total_application_capacity: int
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the metric."""
    maximum_capacity: Optional[int] = rest_field(
        name="maximumCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum node capacity for Service Fabric application. This is the maximum Load for an
     instance of this application on a single node. Even if the capacity of node is greater than
     this value, Service Fabric will limit the total load of services within the application on each
     node to this value. If set to zero, capacity for this metric is unlimited on each node. When
     creating a new application with application capacity defined, the product of MaximumNodes and
     this value must always be smaller than or equal to TotalApplicationCapacity. When updating
     existing application with application capacity, the product of MaximumNodes and this value must
     always be smaller than or equal to TotalApplicationCapacity."""
    reservation_capacity: Optional[int] = rest_field(
        name="reservationCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The node reservation capacity for Service Fabric application. This is the amount of load which
     is reserved on nodes which have instances of this application. If MinimumNodes is specified,
     then the product of these values will be the capacity reserved in the cluster for the
     application. If set to zero, no capacity is reserved for this metric. When setting application
     capacity or when updating application capacity; this value must be smaller than or equal to
     MaximumCapacity for each metric."""
    total_application_capacity: Optional[int] = rest_field(
        name="totalApplicationCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The total metric capacity for Service Fabric application. This is the total metric capacity for
     this application in the cluster. Service Fabric will try to limit the sum of loads of services
     within the application to this value. When creating a new application with application capacity
     defined, the product of MaximumNodes and MaximumCapacity must always be smaller than or equal
     to this value."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        maximum_capacity: Optional[int] = None,
        reservation_capacity: Optional[int] = None,
        total_application_capacity: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Resource(_Model):
    """Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    type: Optional[str] = rest_field(visibility=["read"])
    """The type of the resource. E.g. \"Microsoft.Compute/virtualMachines\" or
     \"Microsoft.Storage/storageAccounts\"."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Azure Resource Manager metadata containing createdBy and modifiedBy information."""


class ApplicationResource(Resource):
    """The application resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The application resource properties.
    :vartype properties: ~azure.mgmt.servicefabric.models.ApplicationResourceProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar etag: "If etag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.").
    :vartype etag: str
    :ivar identity: The managed service identities assigned to this resource.
    :vartype identity: ~azure.mgmt.servicefabric.models.ManagedServiceIdentity
    """

    properties: Optional["_models.ApplicationResourceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The application resource properties."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    etag: Optional[str] = rest_field(visibility=["read"])
    """\"If etag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.\")."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The managed service identities assigned to this resource."""

    __flattened_items = [
        "type_version",
        "parameters",
        "upgrade_policy",
        "minimum_nodes",
        "maximum_nodes",
        "remove_application_capacity",
        "metrics",
        "managed_identities",
        "provisioning_state",
        "type_name",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ApplicationResourceProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ApplicationResourceUpdateProperties(_Model):
    """The application resource properties for patch operations.

    :ivar type_version: The version of the application type as defined in the application manifest.
    :vartype type_version: str
    :ivar parameters: List of application parameters with overridden values from their default
     values specified in the application manifest.
    :vartype parameters: dict[str, str]
    :ivar upgrade_policy: Describes the policy for a monitored application upgrade.
    :vartype upgrade_policy: ~azure.mgmt.servicefabric.models.ApplicationUpgradePolicy
    :ivar minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
     The value of this property cannot be more than the value of the MaximumNodes property.
    :vartype minimum_nodes: int
    :ivar maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. By default, the value of this property is zero and it means that
     the services can be placed on any node.
    :vartype maximum_nodes: int
    :ivar remove_application_capacity: Remove the current application capacity settings.
    :vartype remove_application_capacity: bool
    :ivar metrics: List of application capacity metric description.
    :vartype metrics: list[~azure.mgmt.servicefabric.models.ApplicationMetricDescription]
    :ivar managed_identities: List of user assigned identities for the application, each mapped to
     a friendly name.
    :vartype managed_identities:
     list[~azure.mgmt.servicefabric.models.ApplicationUserAssignedIdentity]
    """

    type_version: Optional[str] = rest_field(
        name="typeVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The version of the application type as defined in the application manifest."""
    parameters: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """List of application parameters with overridden values from their default values specified in
     the application manifest."""
    upgrade_policy: Optional["_models.ApplicationUpgradePolicy"] = rest_field(
        name="upgradePolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes the policy for a monitored application upgrade."""
    minimum_nodes: Optional[int] = rest_field(
        name="minimumNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum number of nodes where Service Fabric will reserve capacity for this application.
     Note that this does not mean that the services of this application will be placed on all of
     those nodes. If this property is set to zero, no capacity will be reserved. The value of this
     property cannot be more than the value of the MaximumNodes property."""
    maximum_nodes: Optional[int] = rest_field(
        name="maximumNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of nodes where Service Fabric will reserve capacity for this application.
     Note that this does not mean that the services of this application will be placed on all of
     those nodes. By default, the value of this property is zero and it means that the services can
     be placed on any node."""
    remove_application_capacity: Optional[bool] = rest_field(
        name="removeApplicationCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Remove the current application capacity settings."""
    metrics: Optional[list["_models.ApplicationMetricDescription"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of application capacity metric description."""
    managed_identities: Optional[list["_models.ApplicationUserAssignedIdentity"]] = rest_field(
        name="managedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of user assigned identities for the application, each mapped to a friendly name."""

    @overload
    def __init__(
        self,
        *,
        type_version: Optional[str] = None,
        parameters: Optional[dict[str, str]] = None,
        upgrade_policy: Optional["_models.ApplicationUpgradePolicy"] = None,
        minimum_nodes: Optional[int] = None,
        maximum_nodes: Optional[int] = None,
        remove_application_capacity: Optional[bool] = None,
        metrics: Optional[list["_models.ApplicationMetricDescription"]] = None,
        managed_identities: Optional[list["_models.ApplicationUserAssignedIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationResourceProperties(ApplicationResourceUpdateProperties):
    """The application resource properties.

    :ivar type_version: The version of the application type as defined in the application manifest.
    :vartype type_version: str
    :ivar parameters: List of application parameters with overridden values from their default
     values specified in the application manifest.
    :vartype parameters: dict[str, str]
    :ivar upgrade_policy: Describes the policy for a monitored application upgrade.
    :vartype upgrade_policy: ~azure.mgmt.servicefabric.models.ApplicationUpgradePolicy
    :ivar minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
     The value of this property cannot be more than the value of the MaximumNodes property.
    :vartype minimum_nodes: int
    :ivar maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. By default, the value of this property is zero and it means that
     the services can be placed on any node.
    :vartype maximum_nodes: int
    :ivar remove_application_capacity: Remove the current application capacity settings.
    :vartype remove_application_capacity: bool
    :ivar metrics: List of application capacity metric description.
    :vartype metrics: list[~azure.mgmt.servicefabric.models.ApplicationMetricDescription]
    :ivar managed_identities: List of user assigned identities for the application, each mapped to
     a friendly name.
    :vartype managed_identities:
     list[~azure.mgmt.servicefabric.models.ApplicationUserAssignedIdentity]
    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    :ivar type_name: The application type name as defined in the application manifest.
    :vartype type_name: str
    """

    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state, which only appears in the response."""
    type_name: Optional[str] = rest_field(name="typeName", visibility=["read", "create", "update", "delete", "query"])
    """The application type name as defined in the application manifest."""

    @overload
    def __init__(
        self,
        *,
        type_version: Optional[str] = None,
        parameters: Optional[dict[str, str]] = None,
        upgrade_policy: Optional["_models.ApplicationUpgradePolicy"] = None,
        minimum_nodes: Optional[int] = None,
        maximum_nodes: Optional[int] = None,
        remove_application_capacity: Optional[bool] = None,
        metrics: Optional[list["_models.ApplicationMetricDescription"]] = None,
        managed_identities: Optional[list["_models.ApplicationUserAssignedIdentity"]] = None,
        type_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProxyResource(Resource):
    """Proxy Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    """


class ProxyResourceApplicationResourceUpdateProperties(ProxyResource):  # pylint: disable=name-too-long
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The resource-specific properties for this resource.
    :vartype properties: ~azure.mgmt.servicefabric.models.ApplicationResourceUpdateProperties
    """

    properties: Optional["_models.ApplicationResourceUpdateProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource-specific properties for this resource."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ApplicationResourceUpdateProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationResourceUpdate(ProxyResourceApplicationResourceUpdateProperties):
    """The application resource for patch operations.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar properties: The application resource properties for patch operations.
    :vartype properties: ~azure.mgmt.servicefabric.models.ApplicationResourceUpdateProperties
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""

    __flattened_items = [
        "type_version",
        "parameters",
        "upgrade_policy",
        "minimum_nodes",
        "maximum_nodes",
        "remove_application_capacity",
        "metrics",
        "managed_identities",
    ]

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.ApplicationResourceUpdateProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ApplicationTypeResource(Resource):
    """The application type name resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The application type name properties.
    :vartype properties: ~azure.mgmt.servicefabric.models.ApplicationTypeResourceProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar etag: "If etag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.").
    :vartype etag: str
    """

    properties: Optional["_models.ApplicationTypeResourceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The application type name properties."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    etag: Optional[str] = rest_field(visibility=["read"])
    """\"If etag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.\")."""

    __flattened_items = ["provisioning_state"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ApplicationTypeResourceProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ApplicationTypeResourceProperties(_Model):
    """The application type name properties.

    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    """

    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state, which only appears in the response."""


class ApplicationTypeVersionResource(Resource):
    """An application type version resource for the specified application type name resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The properties of the application type version resource.
    :vartype properties: ~azure.mgmt.servicefabric.models.ApplicationTypeVersionResourceProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar etag: "If etag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.").
    :vartype etag: str
    """

    properties: Optional["_models.ApplicationTypeVersionResourceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the application type version resource."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    etag: Optional[str] = rest_field(visibility=["read"])
    """\"If etag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.\")."""

    __flattened_items = ["provisioning_state", "app_package_url", "default_parameter_list"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ApplicationTypeVersionResourceProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ApplicationTypeVersionResourceProperties(_Model):
    """The properties of the application type version resource.

    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    :ivar app_package_url: The URL to the application package. Required.
    :vartype app_package_url: str
    :ivar default_parameter_list: List of application type parameters that can be overridden when
     creating or updating the application.
    :vartype default_parameter_list: dict[str, str]
    """

    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state, which only appears in the response."""
    app_package_url: str = rest_field(name="appPackageUrl", visibility=["read", "create", "update", "delete", "query"])
    """The URL to the application package. Required."""
    default_parameter_list: Optional[dict[str, str]] = rest_field(name="defaultParameterList", visibility=["read"])
    """List of application type parameters that can be overridden when creating or updating the
     application."""

    @overload
    def __init__(
        self,
        *,
        app_package_url: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationTypeVersionsCleanupPolicy(_Model):
    """The policy used to clean up unused versions.

    :ivar max_unused_versions_to_keep: Number of unused versions per application type to keep.
     Required.
    :vartype max_unused_versions_to_keep: int
    """

    max_unused_versions_to_keep: int = rest_field(
        name="maxUnusedVersionsToKeep", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of unused versions per application type to keep. Required."""

    @overload
    def __init__(
        self,
        *,
        max_unused_versions_to_keep: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationUpgradePolicy(_Model):
    """Describes the policy for a monitored application upgrade.

    :ivar upgrade_replica_set_check_timeout: The maximum amount of time to block processing of an
     upgrade domain and prevent loss of availability when there are unexpected issues. When this
     timeout expires, processing of the upgrade domain will proceed regardless of availability loss
     issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0
     and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout: str
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar rolling_upgrade_monitoring_policy: The policy used for monitoring the application
     upgrade.
    :vartype rolling_upgrade_monitoring_policy:
     ~azure.mgmt.servicefabric.models.ArmRollingUpgradeMonitoringPolicy
    :ivar application_health_policy: Defines a health policy used to evaluate the health of an
     application or one of its children entities.
    :vartype application_health_policy: ~azure.mgmt.servicefabric.models.ArmApplicationHealthPolicy
    :ivar upgrade_mode: The mode used to monitor health during a rolling upgrade. The values are
     UnmonitoredAuto, UnmonitoredManual, and Monitored. Known values are: "Invalid",
     "UnmonitoredAuto", "UnmonitoredManual", and "Monitored".
    :vartype upgrade_mode: str or ~azure.mgmt.servicefabric.models.RollingUpgradeMode
    :ivar recreate_application: Determines whether the application should be recreated on update.
     If value=true, the rest of the upgrade policy parameters are not allowed and it will result in
     availability loss.
    :vartype recreate_application: bool
    """

    upgrade_replica_set_check_timeout: Optional[str] = rest_field(
        name="upgradeReplicaSetCheckTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum amount of time to block processing of an upgrade domain and prevent loss of
     availability when there are unexpected issues. When this timeout expires, processing of the
     upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the
     start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
     32-bit integer)."""
    force_restart: Optional[bool] = rest_field(
        name="forceRestart", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, then processes are forcefully restarted during upgrade even when the code version has
     not changed (the upgrade only changes configuration or data)."""
    rolling_upgrade_monitoring_policy: Optional["_models.ArmRollingUpgradeMonitoringPolicy"] = rest_field(
        name="rollingUpgradeMonitoringPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The policy used for monitoring the application upgrade."""
    application_health_policy: Optional["_models.ArmApplicationHealthPolicy"] = rest_field(
        name="applicationHealthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines a health policy used to evaluate the health of an application or one of its children
     entities."""
    upgrade_mode: Optional[Union[str, "_models.RollingUpgradeMode"]] = rest_field(
        name="upgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
     UnmonitoredManual, and Monitored. Known values are: \"Invalid\", \"UnmonitoredAuto\",
     \"UnmonitoredManual\", and \"Monitored\"."""
    recreate_application: Optional[bool] = rest_field(
        name="recreateApplication", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines whether the application should be recreated on update. If value=true, the rest of
     the upgrade policy parameters are not allowed and it will result in availability loss."""

    @overload
    def __init__(
        self,
        *,
        upgrade_replica_set_check_timeout: Optional[str] = None,
        force_restart: Optional[bool] = None,
        rolling_upgrade_monitoring_policy: Optional["_models.ArmRollingUpgradeMonitoringPolicy"] = None,
        application_health_policy: Optional["_models.ArmApplicationHealthPolicy"] = None,
        upgrade_mode: Optional[Union[str, "_models.RollingUpgradeMode"]] = None,
        recreate_application: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApplicationUserAssignedIdentity(_Model):
    """Describes a user assigned identity for the application.

    :ivar name: The friendly name of user assigned identity. Required.
    :vartype name: str
    :ivar principal_id: The principal id of user assigned identity. Required.
    :vartype principal_id: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The friendly name of user assigned identity. Required."""
    principal_id: str = rest_field(name="principalId", visibility=["read", "create", "update", "delete", "query"])
    """The principal id of user assigned identity. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        principal_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ArmApplicationHealthPolicy(_Model):
    """Defines a health policy used to evaluate the health of an application or one of its children
    entities.

    :ivar consider_warning_as_error: Indicates whether warnings are treated with the same severity
     as errors.
    :vartype consider_warning_as_error: bool
    :ivar max_percent_unhealthy_deployed_applications: The maximum allowed percentage of unhealthy
     deployed applications. Allowed values are Byte values from zero to 100. The percentage
     represents the maximum tolerated percentage of deployed applications that can be unhealthy
     before the application is considered in error. This is calculated by dividing the number of
     unhealthy deployed applications over the number of nodes where the application is currently
     deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers
     of nodes. Default percentage is zero.
    :vartype max_percent_unhealthy_deployed_applications: int
    :ivar default_service_type_health_policy: The health policy used by default to evaluate the
     health of a service type.
    :vartype default_service_type_health_policy:
     ~azure.mgmt.servicefabric.models.ArmServiceTypeHealthPolicy
    :ivar service_type_health_policy_map: The map with service type health policy per service type
     name. The map is empty by default.
    :vartype service_type_health_policy_map: dict[str,
     ~azure.mgmt.servicefabric.models.ArmServiceTypeHealthPolicy]
    """

    consider_warning_as_error: Optional[bool] = rest_field(
        name="considerWarningAsError", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether warnings are treated with the same severity as errors."""
    max_percent_unhealthy_deployed_applications: Optional[int] = rest_field(
        name="maxPercentUnhealthyDeployedApplications", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte
     values from zero to 100. The percentage represents the maximum tolerated percentage of deployed
     applications that can be unhealthy before the application is considered in error. This is
     calculated by dividing the number of unhealthy deployed applications over the number of nodes
     where the application is currently deployed on in the cluster. The computation rounds up to
     tolerate one failure on small numbers of nodes. Default percentage is zero."""
    default_service_type_health_policy: Optional["_models.ArmServiceTypeHealthPolicy"] = rest_field(
        name="defaultServiceTypeHealthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The health policy used by default to evaluate the health of a service type."""
    service_type_health_policy_map: Optional[dict[str, "_models.ArmServiceTypeHealthPolicy"]] = rest_field(
        name="serviceTypeHealthPolicyMap", visibility=["read", "create", "update", "delete", "query"]
    )
    """The map with service type health policy per service type name. The map is empty by default."""

    @overload
    def __init__(
        self,
        *,
        consider_warning_as_error: Optional[bool] = None,
        max_percent_unhealthy_deployed_applications: Optional[int] = None,
        default_service_type_health_policy: Optional["_models.ArmServiceTypeHealthPolicy"] = None,
        service_type_health_policy_map: Optional[dict[str, "_models.ArmServiceTypeHealthPolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ArmRollingUpgradeMonitoringPolicy(_Model):
    """The policy used for monitoring the application upgrade.

    :ivar failure_action: The activation Mode of the service package. Known values are: "Rollback"
     and "Manual".
    :vartype failure_action: str or ~azure.mgmt.servicefabric.models.ArmUpgradeFailureAction
    :ivar health_check_wait_duration: The amount of time to wait after completing an upgrade domain
     before applying health policies. It is interpreted as a string representing an ISO 8601
     duration with following format "hh:mm:ss.fff".
    :vartype health_check_wait_duration: str
    :ivar health_check_stable_duration: The amount of time that the application or cluster must
     remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a
     string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
    :vartype health_check_stable_duration: str
    :ivar health_check_retry_timeout: The amount of time to retry health evaluation when the
     application or cluster is unhealthy before FailureAction is executed. It is interpreted as a
     string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
    :vartype health_check_retry_timeout: str
    :ivar upgrade_timeout: The amount of time the overall upgrade has to complete before
     FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string
     representing an ISO 8601 duration with following format "hh:mm:ss.fff".
    :vartype upgrade_timeout: str
    :ivar upgrade_domain_timeout: The amount of time each upgrade domain has to complete before
     FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string
     representing an ISO 8601 duration with following format "hh:mm:ss.fff".
    :vartype upgrade_domain_timeout: str
    """

    failure_action: Optional[Union[str, "_models.ArmUpgradeFailureAction"]] = rest_field(
        name="failureAction", visibility=["read", "create", "update", "delete", "query"]
    )
    """The activation Mode of the service package. Known values are: \"Rollback\" and \"Manual\"."""
    health_check_wait_duration: Optional[str] = rest_field(
        name="healthCheckWaitDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time to wait after completing an upgrade domain before applying health policies.
     It is interpreted as a string representing an ISO 8601 duration with following format
     \"hh:mm:ss.fff\"."""
    health_check_stable_duration: Optional[str] = rest_field(
        name="healthCheckStableDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time that the application or cluster must remain healthy before the upgrade
     proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601
     duration with following format \"hh:mm:ss.fff\"."""
    health_check_retry_timeout: Optional[str] = rest_field(
        name="healthCheckRetryTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time to retry health evaluation when the application or cluster is unhealthy
     before FailureAction is executed. It is interpreted as a string representing an ISO 8601
     duration with following format \"hh:mm:ss.fff\"."""
    upgrade_timeout: Optional[str] = rest_field(
        name="upgradeTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot
     be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with
     following format \"hh:mm:ss.fff\"."""
    upgrade_domain_timeout: Optional[str] = rest_field(
        name="upgradeDomainTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot
     be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with
     following format \"hh:mm:ss.fff\"."""

    @overload
    def __init__(
        self,
        *,
        failure_action: Optional[Union[str, "_models.ArmUpgradeFailureAction"]] = None,
        health_check_wait_duration: Optional[str] = None,
        health_check_stable_duration: Optional[str] = None,
        health_check_retry_timeout: Optional[str] = None,
        upgrade_timeout: Optional[str] = None,
        upgrade_domain_timeout: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ArmServiceTypeHealthPolicy(_Model):
    """Represents the health policy used to evaluate the health of services belonging to a service
    type.

    :ivar max_percent_unhealthy_services: The maximum percentage of services allowed to be
     unhealthy before your application is considered in error.
    :vartype max_percent_unhealthy_services: int
    :ivar max_percent_unhealthy_partitions_per_service: The maximum percentage of partitions per
     service allowed to be unhealthy before your application is considered in error.
    :vartype max_percent_unhealthy_partitions_per_service: int
    :ivar max_percent_unhealthy_replicas_per_partition: The maximum percentage of replicas per
     partition allowed to be unhealthy before your application is considered in error.
    :vartype max_percent_unhealthy_replicas_per_partition: int
    """

    max_percent_unhealthy_services: Optional[int] = rest_field(
        name="maxPercentUnhealthyServices", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum percentage of services allowed to be unhealthy before your application is
     considered in error."""
    max_percent_unhealthy_partitions_per_service: Optional[int] = rest_field(
        name="maxPercentUnhealthyPartitionsPerService", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum percentage of partitions per service allowed to be unhealthy before your
     application is considered in error."""
    max_percent_unhealthy_replicas_per_partition: Optional[int] = rest_field(
        name="maxPercentUnhealthyReplicasPerPartition", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum percentage of replicas per partition allowed to be unhealthy before your
     application is considered in error."""

    @overload
    def __init__(
        self,
        *,
        max_percent_unhealthy_services: Optional[int] = None,
        max_percent_unhealthy_partitions_per_service: Optional[int] = None,
        max_percent_unhealthy_replicas_per_partition: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureActiveDirectory(_Model):
    """The settings to enable AAD authentication on the cluster.

    :ivar tenant_id: Azure active directory tenant id.
    :vartype tenant_id: str
    :ivar cluster_application: Azure active directory cluster application id.
    :vartype cluster_application: str
    :ivar client_application: Azure active directory client application id.
    :vartype client_application: str
    """

    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """Azure active directory tenant id."""
    cluster_application: Optional[str] = rest_field(
        name="clusterApplication", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure active directory cluster application id."""
    client_application: Optional[str] = rest_field(
        name="clientApplication", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure active directory client application id."""

    @overload
    def __init__(
        self,
        *,
        tenant_id: Optional[str] = None,
        cluster_application: Optional[str] = None,
        client_application: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CertificateDescription(_Model):
    """Describes the certificate details.

    :ivar thumbprint: Thumbprint of the primary certificate. Required.
    :vartype thumbprint: str
    :ivar thumbprint_secondary: Thumbprint of the secondary certificate.
    :vartype thumbprint_secondary: str
    :ivar x509_store_name: The local certificate store location. Known values are: "AddressBook",
     "AuthRoot", "CertificateAuthority", "Disallowed", "My", "Root", "TrustedPeople", and
     "TrustedPublisher".
    :vartype x509_store_name: str or ~azure.mgmt.servicefabric.models.StoreName
    """

    thumbprint: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Thumbprint of the primary certificate. Required."""
    thumbprint_secondary: Optional[str] = rest_field(
        name="thumbprintSecondary", visibility=["read", "create", "update", "delete", "query"]
    )
    """Thumbprint of the secondary certificate."""
    x509_store_name: Optional[Union[str, "_models.StoreName"]] = rest_field(
        name="x509StoreName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The local certificate store location. Known values are: \"AddressBook\", \"AuthRoot\",
     \"CertificateAuthority\", \"Disallowed\", \"My\", \"Root\", \"TrustedPeople\", and
     \"TrustedPublisher\"."""

    @overload
    def __init__(
        self,
        *,
        thumbprint: str,
        thumbprint_secondary: Optional[str] = None,
        x509_store_name: Optional[Union[str, "_models.StoreName"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClientCertificateCommonName(_Model):
    """Describes the client certificate details using common name.

    :ivar is_admin: Indicates if the client certificate has admin access to the cluster. Non admin
     clients can perform only read only operations on the cluster. Required.
    :vartype is_admin: bool
    :ivar certificate_common_name: The common name of the client certificate. Required.
    :vartype certificate_common_name: str
    :ivar certificate_issuer_thumbprint: The issuer thumbprint of the client certificate. Required.
    :vartype certificate_issuer_thumbprint: str
    """

    is_admin: bool = rest_field(name="isAdmin", visibility=["read", "create", "update", "delete", "query"])
    """Indicates if the client certificate has admin access to the cluster. Non admin clients can
     perform only read only operations on the cluster. Required."""
    certificate_common_name: str = rest_field(
        name="certificateCommonName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The common name of the client certificate. Required."""
    certificate_issuer_thumbprint: str = rest_field(
        name="certificateIssuerThumbprint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The issuer thumbprint of the client certificate. Required."""

    @overload
    def __init__(
        self,
        *,
        is_admin: bool,
        certificate_common_name: str,
        certificate_issuer_thumbprint: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClientCertificateThumbprint(_Model):
    """Describes the client certificate details using thumbprint.

    :ivar is_admin: Indicates if the client certificate has admin access to the cluster. Non admin
     clients can perform only read only operations on the cluster. Required.
    :vartype is_admin: bool
    :ivar certificate_thumbprint: The thumbprint of the client certificate. Required.
    :vartype certificate_thumbprint: str
    """

    is_admin: bool = rest_field(name="isAdmin", visibility=["read", "create", "update", "delete", "query"])
    """Indicates if the client certificate has admin access to the cluster. Non admin clients can
     perform only read only operations on the cluster. Required."""
    certificate_thumbprint: str = rest_field(
        name="certificateThumbprint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The thumbprint of the client certificate. Required."""

    @overload
    def __init__(
        self,
        *,
        is_admin: bool,
        certificate_thumbprint: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TrackedResource(Resource):
    """Tracked Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: str = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives. Required."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Cluster(TrackedResource):
    """The cluster resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: The cluster resource properties.
    :vartype properties: ~azure.mgmt.servicefabric.models.ClusterProperties
    :ivar etag: "If etag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.").
    :vartype etag: str
    """

    properties: Optional["_models.ClusterProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The cluster resource properties."""
    etag: Optional[str] = rest_field(visibility=["read"])
    """\"If etag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.\")."""

    __flattened_items = [
        "add_on_features",
        "available_cluster_versions",
        "azure_active_directory",
        "certificate",
        "certificate_common_names",
        "client_certificate_common_names",
        "client_certificate_thumbprints",
        "cluster_code_version",
        "cluster_endpoint",
        "cluster_id",
        "cluster_state",
        "diagnostics_storage_account_config",
        "event_store_service_enabled",
        "fabric_settings",
        "management_endpoint",
        "node_types",
        "provisioning_state",
        "reliability_level",
        "reverse_proxy_certificate",
        "reverse_proxy_certificate_common_names",
        "upgrade_description",
        "upgrade_mode",
        "application_type_versions_cleanup_policy",
        "vm_image",
        "sf_zonal_upgrade_mode",
        "vmss_zonal_upgrade_mode",
        "infrastructure_service_manager",
        "upgrade_wave",
        "upgrade_pause_start_timestamp_utc",
        "upgrade_pause_end_timestamp_utc",
        "wave_upgrade_paused",
        "notifications",
        "enable_http_gateway_exclusive_auth_mode",
    ]

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
        properties: Optional["_models.ClusterProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ClusterCodeVersionsListResult(_Model):
    """The response of a ClusterCodeVersions list operation.

    :ivar value: The ClusterCodeVersions items on this page. Required.
    :vartype value: list[~azure.mgmt.servicefabric.models.ClusterCodeVersionsResult]
    :ivar next_link: The link to the next page of items.
    :vartype next_link: str
    """

    value: list["_models.ClusterCodeVersionsResult"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The ClusterCodeVersions items on this page. Required."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read", "create", "update", "delete", "query"])
    """The link to the next page of items."""

    @overload
    def __init__(
        self,
        *,
        value: list["_models.ClusterCodeVersionsResult"],
        next_link: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterCodeVersionsResult(ProxyResource):
    """The result of the Service Fabric runtime versions.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The resource-specific properties for this resource.
    :vartype properties: ~azure.mgmt.servicefabric.models.ClusterVersionDetails
    """

    properties: Optional["_models.ClusterVersionDetails"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource-specific properties for this resource."""

    __flattened_items = ["code_version", "support_expiry_utc", "environment"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ClusterVersionDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ClusterHealthPolicy(_Model):
    """Defines a health policy used to evaluate the health of the cluster or of a cluster node.

    :ivar max_percent_unhealthy_nodes: The maximum allowed percentage of unhealthy nodes before
     reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.

     The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
     before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy node, the health is
     evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy nodes over the total number of
     nodes in the cluster.
     The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage
     is zero.

     In large clusters, some nodes will always be down or out for repairs, so this percentage should
     be configured to tolerate that.
    :vartype max_percent_unhealthy_nodes: int
    :ivar max_percent_unhealthy_applications: The maximum allowed percentage of unhealthy
     applications before reporting an error. For example, to allow 10% of applications to be
     unhealthy, this value would be 10.

     The percentage represents the maximum tolerated percentage of applications that can be
     unhealthy before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy application, the health is
     evaluated as Warning.
     This is calculated by dividing the number of unhealthy applications over the total number of
     application instances in the cluster, excluding applications of application types that are
     included in the ApplicationTypeHealthPolicyMap.
     The computation rounds up to tolerate one failure on small numbers of applications. Default
     percentage is zero.
    :vartype max_percent_unhealthy_applications: int
    :ivar application_health_policies: Defines the application health policy map used to evaluate
     the health of an application or one of its children entities.
    :vartype application_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ApplicationHealthPolicy]
    """

    max_percent_unhealthy_nodes: Optional[int] = rest_field(
        name="maxPercentUnhealthyNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to
     allow 10% of nodes to be unhealthy, this value would be 10.
     
     The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
     before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy node, the health is
     evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy nodes over the total number of
     nodes in the cluster.
     The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage
     is zero.
     
     In large clusters, some nodes will always be down or out for repairs, so this percentage should
     be configured to tolerate that."""
    max_percent_unhealthy_applications: Optional[int] = rest_field(
        name="maxPercentUnhealthyApplications", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of unhealthy applications before reporting an error. For
     example, to allow 10% of applications to be unhealthy, this value would be 10.
     
     The percentage represents the maximum tolerated percentage of applications that can be
     unhealthy before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy application, the health is
     evaluated as Warning.
     This is calculated by dividing the number of unhealthy applications over the total number of
     application instances in the cluster, excluding applications of application types that are
     included in the ApplicationTypeHealthPolicyMap.
     The computation rounds up to tolerate one failure on small numbers of applications. Default
     percentage is zero."""
    application_health_policies: Optional[dict[str, "_models.ApplicationHealthPolicy"]] = rest_field(
        name="applicationHealthPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the application health policy map used to evaluate the health of an application or one
     of its children entities."""

    @overload
    def __init__(
        self,
        *,
        max_percent_unhealthy_nodes: Optional[int] = None,
        max_percent_unhealthy_applications: Optional[int] = None,
        application_health_policies: Optional[dict[str, "_models.ApplicationHealthPolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterProperties(_Model):
    """Describes the cluster resource properties.

    :ivar add_on_features: The list of add-on features to enable in the cluster.
    :vartype add_on_features: list[str or ~azure.mgmt.servicefabric.models.AddOnFeatures]
    :ivar available_cluster_versions: The Service Fabric runtime versions available for this
     cluster.
    :vartype available_cluster_versions:
     list[~azure.mgmt.servicefabric.models.ClusterVersionDetails]
    :ivar azure_active_directory: The AAD authentication settings of the cluster.
    :vartype azure_active_directory: ~azure.mgmt.servicefabric.models.AzureActiveDirectory
    :ivar certificate: The certificate to use for securing the cluster. The certificate provided
     will be used for node to node security within the cluster, SSL certificate for cluster
     management endpoint and default admin client.
    :vartype certificate: ~azure.mgmt.servicefabric.models.CertificateDescription
    :ivar certificate_common_names: Describes a list of server certificates referenced by common
     name that are used to secure the cluster.
    :vartype certificate_common_names:
     ~azure.mgmt.servicefabric.models.ServerCertificateCommonNames
    :ivar client_certificate_common_names: The list of client certificates referenced by common
     name that are allowed to manage the cluster.
    :vartype client_certificate_common_names:
     list[~azure.mgmt.servicefabric.models.ClientCertificateCommonName]
    :ivar client_certificate_thumbprints: The list of client certificates referenced by thumbprint
     that are allowed to manage the cluster.
    :vartype client_certificate_thumbprints:
     list[~azure.mgmt.servicefabric.models.ClientCertificateThumbprint]
    :ivar cluster_code_version: The Service Fabric runtime version of the cluster. This property
     can only by set the user when **upgradeMode** is set to 'Manual'. To get list of available
     Service Fabric versions for new clusters use `ClusterVersion API
     <https://learn.microsoft.com/rest/api/servicefabric/cluster-versions/list>`_. To get the list
     of available version for existing clusters use **availableClusterVersions**.
    :vartype cluster_code_version: str
    :ivar cluster_endpoint: The Azure Resource Provider endpoint. A system service in the cluster
     connects to this  endpoint.
    :vartype cluster_endpoint: str
    :ivar cluster_id: A service generated unique identifier for the cluster resource.
    :vartype cluster_id: str
    :ivar cluster_state: The current state of the cluster.

     * WaitingForNodes - Indicates that the cluster resource is created and the resource
       provider is waiting for Service Fabric VM extension to boot up and report to it.
     * Deploying - Indicates that the Service Fabric runtime is being installed on the VMs.
       Cluster resource will be in this state until the cluster boots up and system services are up.
     * BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster
       version. This upgrade is automatically initiated when the cluster boots up for the first time.
     * UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user
       provided configuration.
     * UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user
       provided certificate.
     * UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest
       Service Fabric runtime version. This happens only when the **upgradeMode** is set to
       'Automatic'.
     * EnforcingClusterVersion - Indicates that cluster is on a different version than expected
       and the cluster is being upgraded to the expected version.
     * UpgradeServiceUnreachable - Indicates that the system service in the cluster is no
       longer polling the Resource Provider. Clusters in this state cannot be managed by the Resource
       Provider.
     * AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
     * Ready - Indicates that the cluster is in a stable state. Known values are:
       "WaitingForNodes", "Deploying", "BaselineUpgrade", "UpdatingUserConfiguration",
       "UpdatingUserCertificate", "UpdatingInfrastructure", "EnforcingClusterVersion",
       "UpgradeServiceUnreachable", "AutoScale", and "Ready".
    :vartype cluster_state: str or ~azure.mgmt.servicefabric.models.ClusterState
    :ivar diagnostics_storage_account_config: The storage account information for storing Service
     Fabric diagnostic logs.
    :vartype diagnostics_storage_account_config:
     ~azure.mgmt.servicefabric.models.DiagnosticsStorageAccountConfig
    :ivar event_store_service_enabled: Indicates if the event store service is enabled.
    :vartype event_store_service_enabled: bool
    :ivar fabric_settings: The list of custom fabric settings to configure the cluster.
    :vartype fabric_settings: list[~azure.mgmt.servicefabric.models.SettingsSectionDescription]
    :ivar management_endpoint: The http management endpoint of the cluster. Required.
    :vartype management_endpoint: str
    :ivar node_types: The list of node types in the cluster. Required.
    :vartype node_types: list[~azure.mgmt.servicefabric.models.NodeTypeDescription]
    :ivar provisioning_state: The provisioning state of the cluster resource. Known values are:
     "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or ~azure.mgmt.servicefabric.models.ProvisioningState
    :ivar reliability_level: The reliability level sets the replica set size of system services.
     Learn about `ReliabilityLevel
     <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.

     * None - Run the System services with a target replica set count of 1. This should only be
       used for test clusters.
     * Bronze - Run the System services with a target replica set count of 3. This should only
       be used for test clusters.
     * Silver - Run the System services with a target replica set count of 5.
     * Gold - Run the System services with a target replica set count of 7.
     * Platinum - Run the System services with a target replica set count of 9. Known values
       are: "None", "Bronze", "Silver", "Gold", and "Platinum".
    :vartype reliability_level: str or ~azure.mgmt.servicefabric.models.ReliabilityLevel
    :ivar reverse_proxy_certificate: The server certificate used by reverse proxy.
    :vartype reverse_proxy_certificate: ~azure.mgmt.servicefabric.models.CertificateDescription
    :ivar reverse_proxy_certificate_common_names: Describes a list of server certificates
     referenced by common name that are used to secure the cluster.
    :vartype reverse_proxy_certificate_common_names:
     ~azure.mgmt.servicefabric.models.ServerCertificateCommonNames
    :ivar upgrade_description: The policy to use when upgrading the cluster.
    :vartype upgrade_description: ~azure.mgmt.servicefabric.models.ClusterUpgradePolicy
    :ivar upgrade_mode: The upgrade mode of the cluster when new Service Fabric runtime version is
     available. Known values are: "Automatic" and "Manual".
    :vartype upgrade_mode: str or ~azure.mgmt.servicefabric.models.UpgradeMode
    :ivar application_type_versions_cleanup_policy: The policy used to clean up unused versions.
    :vartype application_type_versions_cleanup_policy:
     ~azure.mgmt.servicefabric.models.ApplicationTypeVersionsCleanupPolicy
    :ivar vm_image: The VM image VMSS has been configured with. Generic names such as Windows or
     Linux can be used.
    :vartype vm_image: str
    :ivar sf_zonal_upgrade_mode: This property controls the logical grouping of VMs in upgrade
     domains (UDs). This property can't be modified if a node type with multiple Availability Zones
     is already present in the cluster. Known values are: "Parallel" and "Hierarchical".
    :vartype sf_zonal_upgrade_mode: str or ~azure.mgmt.servicefabric.models.SfZonalUpgradeMode
    :ivar vmss_zonal_upgrade_mode: This property defines the upgrade mode for the virtual machine
     scale set, it is mandatory if a node type with multiple Availability Zones is added. Known
     values are: "Parallel" and "Hierarchical".
    :vartype vmss_zonal_upgrade_mode: str or ~azure.mgmt.servicefabric.models.VmssZonalUpgradeMode
    :ivar infrastructure_service_manager: Indicates if infrastructure service manager is enabled.
    :vartype infrastructure_service_manager: bool
    :ivar upgrade_wave: Indicates when new cluster runtime version upgrades will be applied after
     they are released. By default is Wave0. Only applies when **upgradeMode** is set to
     'Automatic'. Known values are: "Wave0", "Wave1", and "Wave2".
    :vartype upgrade_wave: str or ~azure.mgmt.servicefabric.models.ClusterUpgradeCadence
    :ivar upgrade_pause_start_timestamp_utc: Indicates the start date and time to pause automatic
     runtime version upgrades on the cluster for an specific period of time on the cluster (UTC).
    :vartype upgrade_pause_start_timestamp_utc: ~datetime.datetime
    :ivar upgrade_pause_end_timestamp_utc: Indicates the end date and time to pause automatic
     runtime version upgrades on the cluster for an specific period of time on the cluster (UTC).
    :vartype upgrade_pause_end_timestamp_utc: ~datetime.datetime
    :ivar wave_upgrade_paused: Boolean to pause automatic runtime version upgrades to the cluster.
    :vartype wave_upgrade_paused: bool
    :ivar notifications: Indicates a list of notification channels for cluster events.
    :vartype notifications: list[~azure.mgmt.servicefabric.models.Notification]
    :ivar enable_http_gateway_exclusive_auth_mode: If true, token-based authentication is not
     allowed on the HttpGatewayEndpoint. This is required to support TLS versions 1.3 and above. If
     token-based authentication is used, HttpGatewayTokenAuthEndpointPort must be defined.
    :vartype enable_http_gateway_exclusive_auth_mode: bool
    """

    add_on_features: Optional[list[Union[str, "_models.AddOnFeatures"]]] = rest_field(
        name="addOnFeatures", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of add-on features to enable in the cluster."""
    available_cluster_versions: Optional[list["_models.ClusterVersionDetails"]] = rest_field(
        name="availableClusterVersions", visibility=["read"]
    )
    """The Service Fabric runtime versions available for this cluster."""
    azure_active_directory: Optional["_models.AzureActiveDirectory"] = rest_field(
        name="azureActiveDirectory", visibility=["read", "create", "update", "delete", "query"]
    )
    """The AAD authentication settings of the cluster."""
    certificate: Optional["_models.CertificateDescription"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The certificate to use for securing the cluster. The certificate provided will be used for node
     to node security within the cluster, SSL certificate for cluster management endpoint and
     default admin client."""
    certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = rest_field(
        name="certificateCommonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes a list of server certificates referenced by common name that are used to secure the
     cluster."""
    client_certificate_common_names: Optional[list["_models.ClientCertificateCommonName"]] = rest_field(
        name="clientCertificateCommonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of client certificates referenced by common name that are allowed to manage the
     cluster."""
    client_certificate_thumbprints: Optional[list["_models.ClientCertificateThumbprint"]] = rest_field(
        name="clientCertificateThumbprints", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of client certificates referenced by thumbprint that are allowed to manage the
     cluster."""
    cluster_code_version: Optional[str] = rest_field(
        name="clusterCodeVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Service Fabric runtime version of the cluster. This property can only by set the user when
     **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
     clusters use `ClusterVersion API
     <https://learn.microsoft.com/rest/api/servicefabric/cluster-versions/list>`_. To get the list
     of available version for existing clusters use **availableClusterVersions**."""
    cluster_endpoint: Optional[str] = rest_field(name="clusterEndpoint", visibility=["read"])
    """The Azure Resource Provider endpoint. A system service in the cluster connects to this
     endpoint."""
    cluster_id: Optional[str] = rest_field(name="clusterId", visibility=["read"])
    """A service generated unique identifier for the cluster resource."""
    cluster_state: Optional[Union[str, "_models.ClusterState"]] = rest_field(name="clusterState", visibility=["read"])
    """The current state of the cluster.
 
      * WaitingForNodes - Indicates that the cluster resource is created and the resource
        provider is waiting for Service Fabric VM extension to boot up and report to it.
      * Deploying - Indicates that the Service Fabric runtime is being installed on the VMs.
        Cluster resource will be in this state until the cluster boots up and system services are up.
      * BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster
        version. This upgrade is automatically initiated when the cluster boots up for the first time.
      * UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user
        provided configuration.
      * UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user
        provided certificate.
      * UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest
        Service Fabric runtime version. This happens only when the **upgradeMode** is set to
        'Automatic'.
      * EnforcingClusterVersion - Indicates that cluster is on a different version than expected
        and the cluster is being upgraded to the expected version.
      * UpgradeServiceUnreachable - Indicates that the system service in the cluster is no
        longer polling the Resource Provider. Clusters in this state cannot be managed by the Resource
        Provider.
      * AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
      * Ready - Indicates that the cluster is in a stable state. Known values are:
        \"WaitingForNodes\", \"Deploying\", \"BaselineUpgrade\", \"UpdatingUserConfiguration\",
        \"UpdatingUserCertificate\", \"UpdatingInfrastructure\", \"EnforcingClusterVersion\",
        \"UpgradeServiceUnreachable\", \"AutoScale\", and \"Ready\"."""
    diagnostics_storage_account_config: Optional["_models.DiagnosticsStorageAccountConfig"] = rest_field(
        name="diagnosticsStorageAccountConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The storage account information for storing Service Fabric diagnostic logs."""
    event_store_service_enabled: Optional[bool] = rest_field(
        name="eventStoreServiceEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the event store service is enabled."""
    fabric_settings: Optional[list["_models.SettingsSectionDescription"]] = rest_field(
        name="fabricSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of custom fabric settings to configure the cluster."""
    management_endpoint: str = rest_field(
        name="managementEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The http management endpoint of the cluster. Required."""
    node_types: list["_models.NodeTypeDescription"] = rest_field(
        name="nodeTypes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of node types in the cluster. Required."""
    provisioning_state: Optional[Union[str, "_models.ProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The provisioning state of the cluster resource. Known values are: \"Updating\", \"Succeeded\",
     \"Failed\", and \"Canceled\"."""
    reliability_level: Optional[Union[str, "_models.ReliabilityLevel"]] = rest_field(
        name="reliabilityLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The reliability level sets the replica set size of system services. Learn about
      `ReliabilityLevel
      <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.
 
      * None - Run the System services with a target replica set count of 1. This should only be
        used for test clusters.
      * Bronze - Run the System services with a target replica set count of 3. This should only
        be used for test clusters.
      * Silver - Run the System services with a target replica set count of 5.
      * Gold - Run the System services with a target replica set count of 7.
      * Platinum - Run the System services with a target replica set count of 9. Known values
        are: \"None\", \"Bronze\", \"Silver\", \"Gold\", and \"Platinum\"."""
    reverse_proxy_certificate: Optional["_models.CertificateDescription"] = rest_field(
        name="reverseProxyCertificate", visibility=["read", "create", "update", "delete", "query"]
    )
    """The server certificate used by reverse proxy."""
    reverse_proxy_certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = rest_field(
        name="reverseProxyCertificateCommonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes a list of server certificates referenced by common name that are used to secure the
     cluster."""
    upgrade_description: Optional["_models.ClusterUpgradePolicy"] = rest_field(
        name="upgradeDescription", visibility=["read", "create", "update", "delete", "query"]
    )
    """The policy to use when upgrading the cluster."""
    upgrade_mode: Optional[Union[str, "_models.UpgradeMode"]] = rest_field(
        name="upgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The upgrade mode of the cluster when new Service Fabric runtime version is available. Known
     values are: \"Automatic\" and \"Manual\"."""
    application_type_versions_cleanup_policy: Optional["_models.ApplicationTypeVersionsCleanupPolicy"] = rest_field(
        name="applicationTypeVersionsCleanupPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The policy used to clean up unused versions."""
    vm_image: Optional[str] = rest_field(name="vmImage", visibility=["read", "create", "update", "delete", "query"])
    """The VM image VMSS has been configured with. Generic names such as Windows or Linux can be used."""
    sf_zonal_upgrade_mode: Optional[Union[str, "_models.SfZonalUpgradeMode"]] = rest_field(
        name="sfZonalUpgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """This property controls the logical grouping of VMs in upgrade domains (UDs). This property
     can't be modified if a node type with multiple Availability Zones is already present in the
     cluster. Known values are: \"Parallel\" and \"Hierarchical\"."""
    vmss_zonal_upgrade_mode: Optional[Union[str, "_models.VmssZonalUpgradeMode"]] = rest_field(
        name="vmssZonalUpgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """This property defines the upgrade mode for the virtual machine scale set, it is mandatory if a
     node type with multiple Availability Zones is added. Known values are: \"Parallel\" and
     \"Hierarchical\"."""
    infrastructure_service_manager: Optional[bool] = rest_field(
        name="infrastructureServiceManager", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if infrastructure service manager is enabled."""
    upgrade_wave: Optional[Union[str, "_models.ClusterUpgradeCadence"]] = rest_field(
        name="upgradeWave", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates when new cluster runtime version upgrades will be applied after they are released. By
     default is Wave0. Only applies when **upgradeMode** is set to 'Automatic'. Known values are:
     \"Wave0\", \"Wave1\", and \"Wave2\"."""
    upgrade_pause_start_timestamp_utc: Optional[datetime.datetime] = rest_field(
        name="upgradePauseStartTimestampUtc",
        visibility=["read", "create", "update", "delete", "query"],
        format="rfc3339",
    )
    """Indicates the start date and time to pause automatic runtime version upgrades on the cluster
     for an specific period of time on the cluster (UTC)."""
    upgrade_pause_end_timestamp_utc: Optional[datetime.datetime] = rest_field(
        name="upgradePauseEndTimestampUtc", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Indicates the end date and time to pause automatic runtime version upgrades on the cluster for
     an specific period of time on the cluster (UTC)."""
    wave_upgrade_paused: Optional[bool] = rest_field(
        name="waveUpgradePaused", visibility=["read", "create", "update", "delete", "query"]
    )
    """Boolean to pause automatic runtime version upgrades to the cluster."""
    notifications: Optional[list["_models.Notification"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates a list of notification channels for cluster events."""
    enable_http_gateway_exclusive_auth_mode: Optional[bool] = rest_field(
        name="enableHttpGatewayExclusiveAuthMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, token-based authentication is not allowed on the HttpGatewayEndpoint. This is required
     to support TLS versions 1.3 and above. If token-based authentication is used,
     HttpGatewayTokenAuthEndpointPort must be defined."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        management_endpoint: str,
        node_types: list["_models.NodeTypeDescription"],
        add_on_features: Optional[list[Union[str, "_models.AddOnFeatures"]]] = None,
        azure_active_directory: Optional["_models.AzureActiveDirectory"] = None,
        certificate: Optional["_models.CertificateDescription"] = None,
        certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = None,
        client_certificate_common_names: Optional[list["_models.ClientCertificateCommonName"]] = None,
        client_certificate_thumbprints: Optional[list["_models.ClientCertificateThumbprint"]] = None,
        cluster_code_version: Optional[str] = None,
        diagnostics_storage_account_config: Optional["_models.DiagnosticsStorageAccountConfig"] = None,
        event_store_service_enabled: Optional[bool] = None,
        fabric_settings: Optional[list["_models.SettingsSectionDescription"]] = None,
        reliability_level: Optional[Union[str, "_models.ReliabilityLevel"]] = None,
        reverse_proxy_certificate: Optional["_models.CertificateDescription"] = None,
        reverse_proxy_certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = None,
        upgrade_description: Optional["_models.ClusterUpgradePolicy"] = None,
        upgrade_mode: Optional[Union[str, "_models.UpgradeMode"]] = None,
        application_type_versions_cleanup_policy: Optional["_models.ApplicationTypeVersionsCleanupPolicy"] = None,
        vm_image: Optional[str] = None,
        sf_zonal_upgrade_mode: Optional[Union[str, "_models.SfZonalUpgradeMode"]] = None,
        vmss_zonal_upgrade_mode: Optional[Union[str, "_models.VmssZonalUpgradeMode"]] = None,
        infrastructure_service_manager: Optional[bool] = None,
        upgrade_wave: Optional[Union[str, "_models.ClusterUpgradeCadence"]] = None,
        upgrade_pause_start_timestamp_utc: Optional[datetime.datetime] = None,
        upgrade_pause_end_timestamp_utc: Optional[datetime.datetime] = None,
        wave_upgrade_paused: Optional[bool] = None,
        notifications: Optional[list["_models.Notification"]] = None,
        enable_http_gateway_exclusive_auth_mode: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterPropertiesUpdateParameters(_Model):
    """Describes the cluster resource properties that can be updated during PATCH operation.

    :ivar add_on_features: The list of add-on features to enable in the cluster.
    :vartype add_on_features: list[str or ~azure.mgmt.servicefabric.models.AddOnFeatures]
    :ivar certificate: The certificate to use for securing the cluster. The certificate provided
     will be used for  node to node security within the cluster, SSL certificate for cluster
     management endpoint and default  admin client.
    :vartype certificate: ~azure.mgmt.servicefabric.models.CertificateDescription
    :ivar certificate_common_names: Describes a list of server certificates referenced by common
     name that are used to secure the cluster.
    :vartype certificate_common_names:
     ~azure.mgmt.servicefabric.models.ServerCertificateCommonNames
    :ivar client_certificate_common_names: The list of client certificates referenced by common
     name that are allowed to manage the cluster. This will overwrite the existing list.
    :vartype client_certificate_common_names:
     list[~azure.mgmt.servicefabric.models.ClientCertificateCommonName]
    :ivar client_certificate_thumbprints: The list of client certificates referenced by thumbprint
     that are allowed to manage the cluster. This will overwrite the existing list.
    :vartype client_certificate_thumbprints:
     list[~azure.mgmt.servicefabric.models.ClientCertificateThumbprint]
    :ivar cluster_code_version: The Service Fabric runtime version of the cluster. This property
     can only by set the user when **upgradeMode** is set to 'Manual'. To get list of available
     Service Fabric versions for new clusters use `ClusterVersion API
     <https://learn.microsoft.com/rest/api/servicefabric/cluster-versions/list>`_. To get the list
     of available version for existing clusters use **availableClusterVersions**.
    :vartype cluster_code_version: str
    :ivar event_store_service_enabled: Indicates if the event store service is enabled.
    :vartype event_store_service_enabled: bool
    :ivar fabric_settings: The list of custom fabric settings to configure the cluster. This will
     overwrite the existing list.
    :vartype fabric_settings: list[~azure.mgmt.servicefabric.models.SettingsSectionDescription]
    :ivar node_types: The list of node types in the cluster. This will overwrite the existing list.
    :vartype node_types: list[~azure.mgmt.servicefabric.models.NodeTypeDescription]
    :ivar reliability_level: The reliability level sets the replica set size of system services.
     Learn about `ReliabilityLevel
     <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.

     * None - Run the System services with a target replica set count of 1. This should only be
       used for test clusters.
     * Bronze - Run the System services with a target replica set count of 3. This should only
       be used for test clusters.
     * Silver - Run the System services with a target replica set count of 5.
     * Gold - Run the System services with a target replica set count of 7.
     * Platinum - Run the System services with a target replica set count of 9. Known values
       are: "None", "Bronze", "Silver", "Gold", and "Platinum".
    :vartype reliability_level: str or ~azure.mgmt.servicefabric.models.ReliabilityLevel
    :ivar reverse_proxy_certificate: The server certificate used by reverse proxy.
    :vartype reverse_proxy_certificate: ~azure.mgmt.servicefabric.models.CertificateDescription
    :ivar upgrade_description: The policy to use when upgrading the cluster.
    :vartype upgrade_description: ~azure.mgmt.servicefabric.models.ClusterUpgradePolicy
    :ivar application_type_versions_cleanup_policy: The policy used to clean up unused versions.
    :vartype application_type_versions_cleanup_policy:
     ~azure.mgmt.servicefabric.models.ApplicationTypeVersionsCleanupPolicy
    :ivar upgrade_mode: The upgrade mode of the cluster when new Service Fabric runtime version is
     available. Known values are: "Automatic" and "Manual".
    :vartype upgrade_mode: str or ~azure.mgmt.servicefabric.models.UpgradeMode
    :ivar sf_zonal_upgrade_mode: This property controls the logical grouping of VMs in upgrade
     domains (UDs). This property can't be modified if a node type with multiple Availability Zones
     is already present in the cluster. Known values are: "Parallel" and "Hierarchical".
    :vartype sf_zonal_upgrade_mode: str or ~azure.mgmt.servicefabric.models.SfZonalUpgradeMode
    :ivar vmss_zonal_upgrade_mode: This property defines the upgrade mode for the virtual machine
     scale set, it is mandatory if a node type with multiple Availability Zones is added. Known
     values are: "Parallel" and "Hierarchical".
    :vartype vmss_zonal_upgrade_mode: str or ~azure.mgmt.servicefabric.models.VmssZonalUpgradeMode
    :ivar infrastructure_service_manager: Indicates if infrastructure service manager is enabled.
    :vartype infrastructure_service_manager: bool
    :ivar upgrade_wave: Indicates when new cluster runtime version upgrades will be applied after
     they are released. By default is Wave0. Only applies when **upgradeMode** is set to
     'Automatic'. Known values are: "Wave0", "Wave1", and "Wave2".
    :vartype upgrade_wave: str or ~azure.mgmt.servicefabric.models.ClusterUpgradeCadence
    :ivar upgrade_pause_start_timestamp_utc: The start timestamp to pause runtime version upgrades
     on the cluster (UTC).
    :vartype upgrade_pause_start_timestamp_utc: ~datetime.datetime
    :ivar upgrade_pause_end_timestamp_utc: The end timestamp of pause runtime version upgrades on
     the cluster (UTC).
    :vartype upgrade_pause_end_timestamp_utc: ~datetime.datetime
    :ivar wave_upgrade_paused: Boolean to pause automatic runtime version upgrades to the cluster.
    :vartype wave_upgrade_paused: bool
    :ivar notifications: Indicates a list of notification channels for cluster events.
    :vartype notifications: list[~azure.mgmt.servicefabric.models.Notification]
    :ivar enable_http_gateway_exclusive_auth_mode: If true, token-based authentication is not
     allowed on the HttpGatewayEndpoint. This is required to support TLS versions 1.3 and above. If
     token-based authentication is used, HttpGatewayTokenAuthEndpointPort must be defined.
    :vartype enable_http_gateway_exclusive_auth_mode: bool
    """

    add_on_features: Optional[list[Union[str, "_models.AddOnFeatures"]]] = rest_field(
        name="addOnFeatures", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of add-on features to enable in the cluster."""
    certificate: Optional["_models.CertificateDescription"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The certificate to use for securing the cluster. The certificate provided will be used for
     node to node security within the cluster, SSL certificate for cluster management endpoint and
     default  admin client."""
    certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = rest_field(
        name="certificateCommonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes a list of server certificates referenced by common name that are used to secure the
     cluster."""
    client_certificate_common_names: Optional[list["_models.ClientCertificateCommonName"]] = rest_field(
        name="clientCertificateCommonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of client certificates referenced by common name that are allowed to manage the
     cluster. This will overwrite the existing list."""
    client_certificate_thumbprints: Optional[list["_models.ClientCertificateThumbprint"]] = rest_field(
        name="clientCertificateThumbprints", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of client certificates referenced by thumbprint that are allowed to manage the
     cluster. This will overwrite the existing list."""
    cluster_code_version: Optional[str] = rest_field(
        name="clusterCodeVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Service Fabric runtime version of the cluster. This property can only by set the user when
     **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
     clusters use `ClusterVersion API
     <https://learn.microsoft.com/rest/api/servicefabric/cluster-versions/list>`_. To get the list
     of available version for existing clusters use **availableClusterVersions**."""
    event_store_service_enabled: Optional[bool] = rest_field(
        name="eventStoreServiceEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the event store service is enabled."""
    fabric_settings: Optional[list["_models.SettingsSectionDescription"]] = rest_field(
        name="fabricSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of custom fabric settings to configure the cluster. This will overwrite the existing
     list."""
    node_types: Optional[list["_models.NodeTypeDescription"]] = rest_field(
        name="nodeTypes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of node types in the cluster. This will overwrite the existing list."""
    reliability_level: Optional[Union[str, "_models.ReliabilityLevel"]] = rest_field(
        name="reliabilityLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The reliability level sets the replica set size of system services. Learn about
      `ReliabilityLevel
      <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.
 
      * None - Run the System services with a target replica set count of 1. This should only be
        used for test clusters.
      * Bronze - Run the System services with a target replica set count of 3. This should only
        be used for test clusters.
      * Silver - Run the System services with a target replica set count of 5.
      * Gold - Run the System services with a target replica set count of 7.
      * Platinum - Run the System services with a target replica set count of 9. Known values
        are: \"None\", \"Bronze\", \"Silver\", \"Gold\", and \"Platinum\"."""
    reverse_proxy_certificate: Optional["_models.CertificateDescription"] = rest_field(
        name="reverseProxyCertificate", visibility=["read", "create", "update", "delete", "query"]
    )
    """The server certificate used by reverse proxy."""
    upgrade_description: Optional["_models.ClusterUpgradePolicy"] = rest_field(
        name="upgradeDescription", visibility=["read", "create", "update", "delete", "query"]
    )
    """The policy to use when upgrading the cluster."""
    application_type_versions_cleanup_policy: Optional["_models.ApplicationTypeVersionsCleanupPolicy"] = rest_field(
        name="applicationTypeVersionsCleanupPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The policy used to clean up unused versions."""
    upgrade_mode: Optional[Union[str, "_models.UpgradeMode"]] = rest_field(
        name="upgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The upgrade mode of the cluster when new Service Fabric runtime version is available. Known
     values are: \"Automatic\" and \"Manual\"."""
    sf_zonal_upgrade_mode: Optional[Union[str, "_models.SfZonalUpgradeMode"]] = rest_field(
        name="sfZonalUpgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """This property controls the logical grouping of VMs in upgrade domains (UDs). This property
     can't be modified if a node type with multiple Availability Zones is already present in the
     cluster. Known values are: \"Parallel\" and \"Hierarchical\"."""
    vmss_zonal_upgrade_mode: Optional[Union[str, "_models.VmssZonalUpgradeMode"]] = rest_field(
        name="vmssZonalUpgradeMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """This property defines the upgrade mode for the virtual machine scale set, it is mandatory if a
     node type with multiple Availability Zones is added. Known values are: \"Parallel\" and
     \"Hierarchical\"."""
    infrastructure_service_manager: Optional[bool] = rest_field(
        name="infrastructureServiceManager", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if infrastructure service manager is enabled."""
    upgrade_wave: Optional[Union[str, "_models.ClusterUpgradeCadence"]] = rest_field(
        name="upgradeWave", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates when new cluster runtime version upgrades will be applied after they are released. By
     default is Wave0. Only applies when **upgradeMode** is set to 'Automatic'. Known values are:
     \"Wave0\", \"Wave1\", and \"Wave2\"."""
    upgrade_pause_start_timestamp_utc: Optional[datetime.datetime] = rest_field(
        name="upgradePauseStartTimestampUtc",
        visibility=["read", "create", "update", "delete", "query"],
        format="rfc3339",
    )
    """The start timestamp to pause runtime version upgrades on the cluster (UTC)."""
    upgrade_pause_end_timestamp_utc: Optional[datetime.datetime] = rest_field(
        name="upgradePauseEndTimestampUtc", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end timestamp of pause runtime version upgrades on the cluster (UTC)."""
    wave_upgrade_paused: Optional[bool] = rest_field(
        name="waveUpgradePaused", visibility=["read", "create", "update", "delete", "query"]
    )
    """Boolean to pause automatic runtime version upgrades to the cluster."""
    notifications: Optional[list["_models.Notification"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates a list of notification channels for cluster events."""
    enable_http_gateway_exclusive_auth_mode: Optional[bool] = rest_field(
        name="enableHttpGatewayExclusiveAuthMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, token-based authentication is not allowed on the HttpGatewayEndpoint. This is required
     to support TLS versions 1.3 and above. If token-based authentication is used,
     HttpGatewayTokenAuthEndpointPort must be defined."""

    @overload
    def __init__(
        self,
        *,
        add_on_features: Optional[list[Union[str, "_models.AddOnFeatures"]]] = None,
        certificate: Optional["_models.CertificateDescription"] = None,
        certificate_common_names: Optional["_models.ServerCertificateCommonNames"] = None,
        client_certificate_common_names: Optional[list["_models.ClientCertificateCommonName"]] = None,
        client_certificate_thumbprints: Optional[list["_models.ClientCertificateThumbprint"]] = None,
        cluster_code_version: Optional[str] = None,
        event_store_service_enabled: Optional[bool] = None,
        fabric_settings: Optional[list["_models.SettingsSectionDescription"]] = None,
        node_types: Optional[list["_models.NodeTypeDescription"]] = None,
        reliability_level: Optional[Union[str, "_models.ReliabilityLevel"]] = None,
        reverse_proxy_certificate: Optional["_models.CertificateDescription"] = None,
        upgrade_description: Optional["_models.ClusterUpgradePolicy"] = None,
        application_type_versions_cleanup_policy: Optional["_models.ApplicationTypeVersionsCleanupPolicy"] = None,
        upgrade_mode: Optional[Union[str, "_models.UpgradeMode"]] = None,
        sf_zonal_upgrade_mode: Optional[Union[str, "_models.SfZonalUpgradeMode"]] = None,
        vmss_zonal_upgrade_mode: Optional[Union[str, "_models.VmssZonalUpgradeMode"]] = None,
        infrastructure_service_manager: Optional[bool] = None,
        upgrade_wave: Optional[Union[str, "_models.ClusterUpgradeCadence"]] = None,
        upgrade_pause_start_timestamp_utc: Optional[datetime.datetime] = None,
        upgrade_pause_end_timestamp_utc: Optional[datetime.datetime] = None,
        wave_upgrade_paused: Optional[bool] = None,
        notifications: Optional[list["_models.Notification"]] = None,
        enable_http_gateway_exclusive_auth_mode: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterUpdateParameters(_Model):
    """Cluster update request.

    :ivar properties: Describes the cluster resource properties that can be updated during PATCH
     operation.
    :vartype properties: ~azure.mgmt.servicefabric.models.ClusterPropertiesUpdateParameters
    :ivar tags: Cluster update parameters.
    :vartype tags: dict[str, str]
    """

    properties: Optional["_models.ClusterPropertiesUpdateParameters"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes the cluster resource properties that can be updated during PATCH operation."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Cluster update parameters."""

    __flattened_items = [
        "add_on_features",
        "certificate",
        "certificate_common_names",
        "client_certificate_common_names",
        "client_certificate_thumbprints",
        "cluster_code_version",
        "event_store_service_enabled",
        "fabric_settings",
        "node_types",
        "reliability_level",
        "reverse_proxy_certificate",
        "upgrade_description",
        "application_type_versions_cleanup_policy",
        "upgrade_mode",
        "sf_zonal_upgrade_mode",
        "vmss_zonal_upgrade_mode",
        "infrastructure_service_manager",
        "upgrade_wave",
        "upgrade_pause_start_timestamp_utc",
        "upgrade_pause_end_timestamp_utc",
        "wave_upgrade_paused",
        "notifications",
        "enable_http_gateway_exclusive_auth_mode",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ClusterPropertiesUpdateParameters"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ClusterUpgradeDeltaHealthPolicy(_Model):
    """Describes the delta health policies for the cluster upgrade.

    :ivar max_percent_delta_unhealthy_nodes: The maximum allowed percentage of nodes health
     degradation allowed during cluster upgrades. The delta is measured between the state of the
     nodes at the beginning of upgrade and the state of the nodes at the time of the health
     evaluation. The check is performed after every upgrade domain upgrade completion to make sure
     the global state of the cluster is within tolerated limits. Required.
    :vartype max_percent_delta_unhealthy_nodes: int
    :ivar max_percent_upgrade_domain_delta_unhealthy_nodes: The maximum allowed percentage of
     upgrade domain nodes health degradation allowed during cluster upgrades. The delta is measured
     between the state of the upgrade domain nodes at the beginning of upgrade and the state of the
     upgrade domain nodes at the time of the health evaluation. The check is performed after every
     upgrade domain upgrade completion for all completed upgrade domains to make sure the state of
     the upgrade domains is within tolerated limits. Required.
    :vartype max_percent_upgrade_domain_delta_unhealthy_nodes: int
    :ivar max_percent_delta_unhealthy_applications: The maximum allowed percentage of applications
     health degradation allowed during cluster upgrades. The delta is measured between the state of
     the applications at the beginning of upgrade and the state of the applications at the time of
     the health evaluation. The check is performed after every upgrade domain upgrade completion to
     make sure the global state of the cluster is within tolerated limits. System services are not
     included in this. Required.
    :vartype max_percent_delta_unhealthy_applications: int
    :ivar application_delta_health_policies: Defines the application delta health policy map used
     to evaluate the health of an application or one of its child entities when upgrading the
     cluster.
    :vartype application_delta_health_policies: dict[str,
     ~azure.mgmt.servicefabric.models.ApplicationDeltaHealthPolicy]
    """

    max_percent_delta_unhealthy_nodes: int = rest_field(
        name="maxPercentDeltaUnhealthyNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of nodes health degradation allowed during cluster upgrades. The
     delta is measured between the state of the nodes at the beginning of upgrade and the state of
     the nodes at the time of the health evaluation. The check is performed after every upgrade
     domain upgrade completion to make sure the global state of the cluster is within tolerated
     limits. Required."""
    max_percent_upgrade_domain_delta_unhealthy_nodes: int = rest_field(
        name="maxPercentUpgradeDomainDeltaUnhealthyNodes", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of upgrade domain nodes health degradation allowed during
     cluster upgrades. The delta is measured between the state of the upgrade domain nodes at the
     beginning of upgrade and the state of the upgrade domain nodes at the time of the health
     evaluation. The check is performed after every upgrade domain upgrade completion for all
     completed upgrade domains to make sure the state of the upgrade domains is within tolerated
     limits. Required."""
    max_percent_delta_unhealthy_applications: int = rest_field(
        name="maxPercentDeltaUnhealthyApplications", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of applications health degradation allowed during cluster
     upgrades. The delta is measured between the state of the applications at the beginning of
     upgrade and the state of the applications at the time of the health evaluation. The check is
     performed after every upgrade domain upgrade completion to make sure the global state of the
     cluster is within tolerated limits. System services are not included in this. Required."""
    application_delta_health_policies: Optional[dict[str, "_models.ApplicationDeltaHealthPolicy"]] = rest_field(
        name="applicationDeltaHealthPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """Defines the application delta health policy map used to evaluate the health of an application
     or one of its child entities when upgrading the cluster."""

    @overload
    def __init__(
        self,
        *,
        max_percent_delta_unhealthy_nodes: int,
        max_percent_upgrade_domain_delta_unhealthy_nodes: int,
        max_percent_delta_unhealthy_applications: int,
        application_delta_health_policies: Optional[dict[str, "_models.ApplicationDeltaHealthPolicy"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterUpgradePolicy(_Model):
    """Describes the policy used when upgrading the cluster.

    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar upgrade_replica_set_check_timeout: The maximum amount of time to block processing of an
     upgrade domain and prevent loss of availability when there are unexpected issues. When this
     timeout expires, processing of the upgrade domain will proceed regardless of availability loss
     issues. The timeout is reset at the start of each upgrade domain. The timeout can be in either
     hh:mm:ss or in d.hh:mm:ss.ms format. Required.
    :vartype upgrade_replica_set_check_timeout: str
    :ivar health_check_wait_duration: The length of time to wait after completing an upgrade domain
     before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     format. Required.
    :vartype health_check_wait_duration: str
    :ivar health_check_stable_duration: The amount of time that the application or cluster must
     remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in
     either hh:mm:ss or in d.hh:mm:ss.ms format. Required.
    :vartype health_check_stable_duration: str
    :ivar health_check_retry_timeout: The amount of time to retry health evaluation when the
     application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either
     hh:mm:ss or in d.hh:mm:ss.ms format. Required.
    :vartype health_check_retry_timeout: str
    :ivar upgrade_timeout: The amount of time the overall upgrade has to complete before the
     upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format. Required.
    :vartype upgrade_timeout: str
    :ivar upgrade_domain_timeout: The amount of time each upgrade domain has to complete before the
     upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format. Required.
    :vartype upgrade_domain_timeout: str
    :ivar health_policy: The cluster health policy used when upgrading the cluster. Required.
    :vartype health_policy: ~azure.mgmt.servicefabric.models.ClusterHealthPolicy
    :ivar delta_health_policy: The cluster delta health policy used when upgrading the cluster.
    :vartype delta_health_policy: ~azure.mgmt.servicefabric.models.ClusterUpgradeDeltaHealthPolicy
    """

    force_restart: Optional[bool] = rest_field(
        name="forceRestart", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, then processes are forcefully restarted during upgrade even when the code version has
     not changed (the upgrade only changes configuration or data)."""
    upgrade_replica_set_check_timeout: str = rest_field(
        name="upgradeReplicaSetCheckTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum amount of time to block processing of an upgrade domain and prevent loss of
     availability when there are unexpected issues. When this timeout expires, processing of the
     upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the
     start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
     Required."""
    health_check_wait_duration: str = rest_field(
        name="healthCheckWaitDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The length of time to wait after completing an upgrade domain before performing health checks.
     The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format. Required."""
    health_check_stable_duration: str = rest_field(
        name="healthCheckStableDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time that the application or cluster must remain healthy before the upgrade
     proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms
     format. Required."""
    health_check_retry_timeout: str = rest_field(
        name="healthCheckRetryTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time to retry health evaluation when the application or cluster is unhealthy
     before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
     format. Required."""
    upgrade_timeout: str = rest_field(name="upgradeTimeout", visibility=["read", "create", "update", "delete", "query"])
    """The amount of time the overall upgrade has to complete before the upgrade rolls back. The
     timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format. Required."""
    upgrade_domain_timeout: str = rest_field(
        name="upgradeDomainTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The amount of time each upgrade domain has to complete before the upgrade rolls back. The
     timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format. Required."""
    health_policy: "_models.ClusterHealthPolicy" = rest_field(
        name="healthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The cluster health policy used when upgrading the cluster. Required."""
    delta_health_policy: Optional["_models.ClusterUpgradeDeltaHealthPolicy"] = rest_field(
        name="deltaHealthPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The cluster delta health policy used when upgrading the cluster."""

    @overload
    def __init__(
        self,
        *,
        upgrade_replica_set_check_timeout: str,
        health_check_wait_duration: str,
        health_check_stable_duration: str,
        health_check_retry_timeout: str,
        upgrade_timeout: str,
        upgrade_domain_timeout: str,
        health_policy: "_models.ClusterHealthPolicy",
        force_restart: Optional[bool] = None,
        delta_health_policy: Optional["_models.ClusterUpgradeDeltaHealthPolicy"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterVersionDetails(_Model):
    """The detail of the Service Fabric runtime version result.

    :ivar code_version: The Service Fabric runtime version of the cluster.
    :vartype code_version: str
    :ivar support_expiry_utc: The date of expiry of support of the version.
    :vartype support_expiry_utc: str
    :ivar environment: Indicates if this version is for Windows or Linux operating system. Known
     values are: "Windows" and "Linux".
    :vartype environment: str or ~azure.mgmt.servicefabric.models.ClusterEnvironment
    """

    code_version: Optional[str] = rest_field(
        name="codeVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Service Fabric runtime version of the cluster."""
    support_expiry_utc: Optional[str] = rest_field(
        name="supportExpiryUtc", visibility=["read", "create", "update", "delete", "query"]
    )
    """The date of expiry of support of the version."""
    environment: Optional[Union[str, "_models.ClusterEnvironment"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if this version is for Windows or Linux operating system. Known values are:
     \"Windows\" and \"Linux\"."""

    @overload
    def __init__(
        self,
        *,
        code_version: Optional[str] = None,
        support_expiry_utc: Optional[str] = None,
        environment: Optional[Union[str, "_models.ClusterEnvironment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiagnosticsStorageAccountConfig(_Model):
    """The storage account information for storing Service Fabric diagnostic logs.

    :ivar storage_account_name: The Azure storage account name. Required.
    :vartype storage_account_name: str
    :ivar protected_account_key_name: The protected diagnostics storage key name. Required.
    :vartype protected_account_key_name: str
    :ivar protected_account_key_name2: The secondary protected diagnostics storage key name. If one
     of the storage account keys is rotated the cluster will fallback to using the other.
    :vartype protected_account_key_name2: str
    :ivar blob_endpoint: The blob endpoint of the azure storage account. Required.
    :vartype blob_endpoint: str
    :ivar queue_endpoint: The queue endpoint of the azure storage account. Required.
    :vartype queue_endpoint: str
    :ivar table_endpoint: The table endpoint of the azure storage account. Required.
    :vartype table_endpoint: str
    """

    storage_account_name: str = rest_field(
        name="storageAccountName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Azure storage account name. Required."""
    protected_account_key_name: str = rest_field(
        name="protectedAccountKeyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The protected diagnostics storage key name. Required."""
    protected_account_key_name2: Optional[str] = rest_field(
        name="protectedAccountKeyName2", visibility=["read", "create", "update", "delete", "query"]
    )
    """The secondary protected diagnostics storage key name. If one of the storage account keys is
     rotated the cluster will fallback to using the other."""
    blob_endpoint: str = rest_field(name="blobEndpoint", visibility=["read", "create", "update", "delete", "query"])
    """The blob endpoint of the azure storage account. Required."""
    queue_endpoint: str = rest_field(name="queueEndpoint", visibility=["read", "create", "update", "delete", "query"])
    """The queue endpoint of the azure storage account. Required."""
    table_endpoint: str = rest_field(name="tableEndpoint", visibility=["read", "create", "update", "delete", "query"])
    """The table endpoint of the azure storage account. Required."""

    @overload
    def __init__(
        self,
        *,
        storage_account_name: str,
        protected_account_key_name: str,
        blob_endpoint: str,
        queue_endpoint: str,
        table_endpoint: str,
        protected_account_key_name2: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointRangeDescription(_Model):
    """Port range details.

    :ivar start_port: Starting port of a range of ports. Required.
    :vartype start_port: int
    :ivar end_port: End port of a range of ports. Required.
    :vartype end_port: int
    """

    start_port: int = rest_field(name="startPort", visibility=["read", "create", "update", "delete", "query"])
    """Starting port of a range of ports. Required."""
    end_port: int = rest_field(name="endPort", visibility=["read", "create", "update", "delete", "query"])
    """End port of a range of ports. Required."""

    @overload
    def __init__(
        self,
        *,
        start_port: int,
        end_port: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorAdditionalInfo(_Model):
    """The resource management error additional info.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    type: Optional[str] = rest_field(visibility=["read"])
    """The additional info type."""
    info: Optional[Any] = rest_field(visibility=["read"])
    """The additional info."""


class ErrorDetail(_Model):
    """The error detail.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.mgmt.servicefabric.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.mgmt.servicefabric.models.ErrorAdditionalInfo]
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """The error code."""
    message: Optional[str] = rest_field(visibility=["read"])
    """The error message."""
    target: Optional[str] = rest_field(visibility=["read"])
    """The error target."""
    details: Optional[list["_models.ErrorDetail"]] = rest_field(visibility=["read"])
    """The error details."""
    additional_info: Optional[list["_models.ErrorAdditionalInfo"]] = rest_field(
        name="additionalInfo", visibility=["read"]
    )
    """The error additional info."""


class ErrorResponse(_Model):
    """Error response.

    :ivar error: The error object.
    :vartype error: ~azure.mgmt.servicefabric.models.ErrorDetail
    """

    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error object."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedServiceIdentity(_Model):
    """Managed service identity (system assigned and/or user assigned identities).

    :ivar principal_id: The service principal ID of the system assigned identity. This property
     will only be provided for a system assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
     provided for a system assigned identity.
    :vartype tenant_id: str
    :ivar type: The type of managed identity assigned to this resource. Required. Known values are:
     "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
    :vartype type: str or ~azure.mgmt.servicefabric.models.ManagedServiceIdentityType
    :ivar user_assigned_identities: The identities assigned to this resource by the user.
    :vartype user_assigned_identities: dict[str,
     ~azure.mgmt.servicefabric.models.UserAssignedIdentity]
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The service principal ID of the system assigned identity. This property will only be provided
     for a system assigned identity."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant ID of the system assigned identity. This property will only be provided for a system
     assigned identity."""
    type: Union[str, "_models.ManagedServiceIdentityType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of managed identity assigned to this resource. Required. Known values are: \"None\",
     \"SystemAssigned\", \"UserAssigned\", and \"SystemAssigned,UserAssigned\"."""
    user_assigned_identities: Optional[dict[str, "_models.UserAssignedIdentity"]] = rest_field(
        name="userAssignedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identities assigned to this resource by the user."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ManagedServiceIdentityType"],
        user_assigned_identities: Optional[dict[str, "_models.UserAssignedIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartitionSchemeDescription(_Model):
    """Describes how the service is partitioned.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    NamedPartitionSchemeDescription, SingletonPartitionSchemeDescription,
    UniformInt64RangePartitionSchemeDescription

    :ivar partition_scheme: Specifies how the service is partitioned. Required. Known values are:
     "Invalid", "Singleton", "UniformInt64Range", and "Named".
    :vartype partition_scheme: str or ~azure.mgmt.servicefabric.models.PartitionScheme
    """

    __mapping__: dict[str, _Model] = {}
    partition_scheme: str = rest_discriminator(
        name="partitionScheme", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies how the service is partitioned. Required. Known values are: \"Invalid\",
     \"Singleton\", \"UniformInt64Range\", and \"Named\"."""

    @overload
    def __init__(
        self,
        *,
        partition_scheme: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NamedPartitionSchemeDescription(PartitionSchemeDescription, discriminator="Named"):
    """Describes the named partition scheme of the service.

    :ivar count: The number of partitions. Required.
    :vartype count: int
    :ivar names: Array of size specified by the count parameter, for the names of the partitions.
     Required.
    :vartype names: list[str]
    :ivar partition_scheme: Specifies how the service is partitioned. Required. Indicates that the
     partition is based on string names, and is a NamedPartitionSchemeDescription object. The value
     is 3.
    :vartype partition_scheme: str or ~azure.mgmt.servicefabric.models.NAMED
    """

    count: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of partitions. Required."""
    names: list[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of size specified by the count parameter, for the names of the partitions. Required."""
    partition_scheme: Literal[PartitionScheme.NAMED] = rest_discriminator(name="partitionScheme", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Specifies how the service is partitioned. Required. Indicates that the partition is based on
     string names, and is a NamedPartitionSchemeDescription object. The value is 3."""

    @overload
    def __init__(
        self,
        *,
        count: int,
        names: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.partition_scheme = PartitionScheme.NAMED  # type: ignore


class NodeTypeDescription(_Model):
    """Describes a node type in the cluster, each node type represents sub set of nodes in the
    cluster.

    :ivar name: The name of the node type. Required.
    :vartype name: str
    :ivar placement_properties: The placement tags applied to nodes in the node type, which can be
     used to indicate where certain services (workload) should run.
    :vartype placement_properties: dict[str, str]
    :ivar capacities: The capacity tags applied to the nodes in the node type, the cluster resource
     manager uses these tags to understand how much resource a node has.
    :vartype capacities: dict[str, str]
    :ivar client_connection_endpoint_port: The TCP cluster management endpoint port. Required.
    :vartype client_connection_endpoint_port: int
    :ivar http_gateway_endpoint_port: The HTTP cluster management endpoint port. Required.
    :vartype http_gateway_endpoint_port: int
    :ivar durability_level: The durability level of the node type. Learn about `DurabilityLevel
     <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.

     * Bronze - No privileges. This is the default.
     * Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
     * Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold
       durability can be enabled only on full node VM skus like D15_V2, G5 etc. Known values are:
       "Bronze", "Silver", and "Gold".
    :vartype durability_level: str or ~azure.mgmt.servicefabric.models.DurabilityLevel
    :ivar application_ports: The range of ports from which cluster assigned port to Service Fabric
     applications.
    :vartype application_ports: ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :ivar ephemeral_ports: The range of ephemeral ports that nodes in this node type should be
     configured with.
    :vartype ephemeral_ports: ~azure.mgmt.servicefabric.models.EndpointRangeDescription
    :ivar is_primary: The node type on which system services will run. Only one node type should be
     marked as primary. Primary node type cannot be deleted or changed for existing clusters.
     Required.
    :vartype is_primary: bool
    :ivar vm_instance_count: VMInstanceCount should be 1 to n, where n indicates the number of VM
     instances corresponding to this nodeType. VMInstanceCount = 0 can be done only in these
     scenarios: NodeType is a secondary nodeType. Durability = Bronze or Durability >= Bronze and
     InfrastructureServiceManager = true. If VMInstanceCount = 0, implies the VMs for this nodeType
     will not be used for the initial cluster size computation. Required.
    :vartype vm_instance_count: int
    :ivar reverse_proxy_endpoint_port: The endpoint used by reverse proxy.
    :vartype reverse_proxy_endpoint_port: int
    :ivar is_stateless: Indicates if the node type can only host Stateless workloads.
    :vartype is_stateless: bool
    :ivar multiple_availability_zones: Indicates if the node type is enabled to support multiple
     zones.
    :vartype multiple_availability_zones: bool
    :ivar http_gateway_token_auth_endpoint_port: The port used for token-auth based HTTPS
     connections to the cluster. Cannot be set to the same port as HttpGatewayEndpoint.
    :vartype http_gateway_token_auth_endpoint_port: int
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the node type. Required."""
    placement_properties: Optional[dict[str, str]] = rest_field(
        name="placementProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """The placement tags applied to nodes in the node type, which can be used to indicate where
     certain services (workload) should run."""
    capacities: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The capacity tags applied to the nodes in the node type, the cluster resource manager uses
     these tags to understand how much resource a node has."""
    client_connection_endpoint_port: int = rest_field(
        name="clientConnectionEndpointPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """The TCP cluster management endpoint port. Required."""
    http_gateway_endpoint_port: int = rest_field(
        name="httpGatewayEndpointPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """The HTTP cluster management endpoint port. Required."""
    durability_level: Optional[Union[str, "_models.DurabilityLevel"]] = rest_field(
        name="durabilityLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The durability level of the node type. Learn about `DurabilityLevel
      <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity>`_.
 
      * Bronze - No privileges. This is the default.
      * Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
      * Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold
        durability can be enabled only on full node VM skus like D15_V2, G5 etc. Known values are:
        \"Bronze\", \"Silver\", and \"Gold\"."""
    application_ports: Optional["_models.EndpointRangeDescription"] = rest_field(
        name="applicationPorts", visibility=["read", "create", "update", "delete", "query"]
    )
    """The range of ports from which cluster assigned port to Service Fabric applications."""
    ephemeral_ports: Optional["_models.EndpointRangeDescription"] = rest_field(
        name="ephemeralPorts", visibility=["read", "create", "update", "delete", "query"]
    )
    """The range of ephemeral ports that nodes in this node type should be configured with."""
    is_primary: bool = rest_field(name="isPrimary", visibility=["read", "create", "update", "delete", "query"])
    """The node type on which system services will run. Only one node type should be marked as
     primary. Primary node type cannot be deleted or changed for existing clusters. Required."""
    vm_instance_count: int = rest_field(
        name="vmInstanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """VMInstanceCount should be 1 to n, where n indicates the number of VM instances corresponding to
     this nodeType. VMInstanceCount = 0 can be done only in these scenarios: NodeType is a secondary
     nodeType. Durability = Bronze or Durability >= Bronze and InfrastructureServiceManager = true.
     If VMInstanceCount = 0, implies the VMs for this nodeType will not be used for the initial
     cluster size computation. Required."""
    reverse_proxy_endpoint_port: Optional[int] = rest_field(
        name="reverseProxyEndpointPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """The endpoint used by reverse proxy."""
    is_stateless: Optional[bool] = rest_field(
        name="isStateless", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the node type can only host Stateless workloads."""
    multiple_availability_zones: Optional[bool] = rest_field(
        name="multipleAvailabilityZones", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the node type is enabled to support multiple zones."""
    http_gateway_token_auth_endpoint_port: Optional[int] = rest_field(
        name="httpGatewayTokenAuthEndpointPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """The port used for token-auth based HTTPS connections to the cluster. Cannot be set to the same
     port as HttpGatewayEndpoint."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        client_connection_endpoint_port: int,
        http_gateway_endpoint_port: int,
        is_primary: bool,
        vm_instance_count: int,
        placement_properties: Optional[dict[str, str]] = None,
        capacities: Optional[dict[str, str]] = None,
        durability_level: Optional[Union[str, "_models.DurabilityLevel"]] = None,
        application_ports: Optional["_models.EndpointRangeDescription"] = None,
        ephemeral_ports: Optional["_models.EndpointRangeDescription"] = None,
        reverse_proxy_endpoint_port: Optional[int] = None,
        is_stateless: Optional[bool] = None,
        multiple_availability_zones: Optional[bool] = None,
        http_gateway_token_auth_endpoint_port: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Notification(_Model):
    """Describes the notification channel for cluster events.

    :ivar is_enabled: Indicates if the notification is enabled. Required.
    :vartype is_enabled: bool
    :ivar notification_category: The category of notification. Required. "WaveProgress"
    :vartype notification_category: str or ~azure.mgmt.servicefabric.models.NotificationCategory
    :ivar notification_level: The level of notification. Required. Known values are: "Critical" and
     "All".
    :vartype notification_level: str or ~azure.mgmt.servicefabric.models.NotificationLevel
    :ivar notification_targets: List of targets that subscribe to the notification. Required.
    :vartype notification_targets: list[~azure.mgmt.servicefabric.models.NotificationTarget]
    """

    is_enabled: bool = rest_field(name="isEnabled", visibility=["read", "create", "update", "delete", "query"])
    """Indicates if the notification is enabled. Required."""
    notification_category: Union[str, "_models.NotificationCategory"] = rest_field(
        name="notificationCategory", visibility=["read", "create", "update", "delete", "query"]
    )
    """The category of notification. Required. \"WaveProgress\""""
    notification_level: Union[str, "_models.NotificationLevel"] = rest_field(
        name="notificationLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The level of notification. Required. Known values are: \"Critical\" and \"All\"."""
    notification_targets: list["_models.NotificationTarget"] = rest_field(
        name="notificationTargets", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of targets that subscribe to the notification. Required."""

    @overload
    def __init__(
        self,
        *,
        is_enabled: bool,
        notification_category: Union[str, "_models.NotificationCategory"],
        notification_level: Union[str, "_models.NotificationLevel"],
        notification_targets: list["_models.NotificationTarget"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NotificationTarget(_Model):
    """Describes the notification target properties.

    :ivar notification_channel: The notification channel indicates the type of receivers subscribed
     to the notification, either user or subscription. Required. Known values are: "EmailUser" and
     "EmailSubscription".
    :vartype notification_channel: str or ~azure.mgmt.servicefabric.models.NotificationChannel
    :ivar receivers: List of targets that subscribe to the notification. Required.
    :vartype receivers: list[str]
    """

    notification_channel: Union[str, "_models.NotificationChannel"] = rest_field(
        name="notificationChannel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The notification channel indicates the type of receivers subscribed to the notification, either
     user or subscription. Required. Known values are: \"EmailUser\" and \"EmailSubscription\"."""
    receivers: list[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """List of targets that subscribe to the notification. Required."""

    @overload
    def __init__(
        self,
        *,
        notification_channel: Union[str, "_models.NotificationChannel"],
        receivers: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Operation(_Model):
    """REST API Operation.

    :ivar name: The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action".
    :vartype name: str
    :ivar is_data_action: Whether the operation applies to data-plane. This is "true" for
     data-plane operations and "false" for Azure Resource Manager/control-plane operations.
    :vartype is_data_action: bool
    :ivar display: Localized display information for this particular operation.
    :vartype display: ~azure.mgmt.servicefabric.models.OperationDisplay
    :ivar origin: The intended executor of the operation; as in Resource Based Access Control
     (RBAC) and audit logs UX. Default value is "user,system". Known values are: "user", "system",
     and "user,system".
    :vartype origin: str or ~azure.mgmt.servicefabric.models.Origin
    :ivar action_type: Extensible enum. Indicates the action type. "Internal" refers to actions
     that are for internal only APIs. "Internal"
    :vartype action_type: str or ~azure.mgmt.servicefabric.models.ActionType
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     \"Microsoft.Compute/virtualMachines/write\",
     \"Microsoft.Compute/virtualMachines/capture/action\"."""
    is_data_action: Optional[bool] = rest_field(name="isDataAction", visibility=["read"])
    """Whether the operation applies to data-plane. This is \"true\" for data-plane operations and
     \"false\" for Azure Resource Manager/control-plane operations."""
    display: Optional["_models.OperationDisplay"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Localized display information for this particular operation."""
    origin: Optional[Union[str, "_models.Origin"]] = rest_field(visibility=["read"])
    """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is \"user,system\". Known values are: \"user\", \"system\", and
     \"user,system\"."""
    action_type: Optional[Union[str, "_models.ActionType"]] = rest_field(name="actionType", visibility=["read"])
    """Extensible enum. Indicates the action type. \"Internal\" refers to actions that are for
     internal only APIs. \"Internal\""""

    @overload
    def __init__(
        self,
        *,
        display: Optional["_models.OperationDisplay"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OperationDisplay(_Model):
    """Localized display information for an operation.

    :ivar provider: The localized friendly form of the resource provider name, e.g. "Microsoft
     Monitoring Insights" or "Microsoft Compute".
    :vartype provider: str
    :ivar resource: The localized friendly name of the resource type related to this operation.
     E.g. "Virtual Machines" or "Job Schedule Collections".
    :vartype resource: str
    :ivar operation: The concise, localized friendly name for the operation; suitable for
     dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
    :vartype operation: str
    :ivar description: The short, localized friendly description of the operation; suitable for
     tool tips and detailed views.
    :vartype description: str
    """

    provider: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly form of the resource provider name, e.g. \"Microsoft Monitoring
     Insights\" or \"Microsoft Compute\"."""
    resource: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly name of the resource type related to this operation. E.g. \"Virtual
     Machines\" or \"Job Schedule Collections\"."""
    operation: Optional[str] = rest_field(visibility=["read"])
    """The concise, localized friendly name for the operation; suitable for dropdowns. E.g. \"Create
     or Update Virtual Machine\", \"Restart Virtual Machine\"."""
    description: Optional[str] = rest_field(visibility=["read"])
    """The short, localized friendly description of the operation; suitable for tool tips and detailed
     views."""


class ServerCertificateCommonName(_Model):
    """Describes the server certificate details using common name.

    :ivar certificate_common_name: The common name of the server certificate. Required.
    :vartype certificate_common_name: str
    :ivar certificate_issuer_thumbprint: The issuer thumbprint of the server certificate. Required.
    :vartype certificate_issuer_thumbprint: str
    """

    certificate_common_name: str = rest_field(
        name="certificateCommonName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The common name of the server certificate. Required."""
    certificate_issuer_thumbprint: str = rest_field(
        name="certificateIssuerThumbprint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The issuer thumbprint of the server certificate. Required."""

    @overload
    def __init__(
        self,
        *,
        certificate_common_name: str,
        certificate_issuer_thumbprint: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerCertificateCommonNames(_Model):
    """Describes a list of server certificates referenced by common name that are used to secure the
    cluster.

    :ivar common_names: The list of server certificates referenced by common name that are used to
     secure the cluster.
    :vartype common_names: list[~azure.mgmt.servicefabric.models.ServerCertificateCommonName]
    :ivar x509_store_name: The local certificate store location. Known values are: "AddressBook",
     "AuthRoot", "CertificateAuthority", "Disallowed", "My", "Root", "TrustedPeople", and
     "TrustedPublisher".
    :vartype x509_store_name: str or ~azure.mgmt.servicefabric.models.StoreName
    """

    common_names: Optional[list["_models.ServerCertificateCommonName"]] = rest_field(
        name="commonNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of server certificates referenced by common name that are used to secure the cluster."""
    x509_store_name: Optional[Union[str, "_models.StoreName"]] = rest_field(
        name="x509StoreName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The local certificate store location. Known values are: \"AddressBook\", \"AuthRoot\",
     \"CertificateAuthority\", \"Disallowed\", \"My\", \"Root\", \"TrustedPeople\", and
     \"TrustedPublisher\"."""

    @overload
    def __init__(
        self,
        *,
        common_names: Optional[list["_models.ServerCertificateCommonName"]] = None,
        x509_store_name: Optional[Union[str, "_models.StoreName"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceCorrelationDescription(_Model):
    """Creates a particular correlation between services.

    :ivar scheme: The ServiceCorrelationScheme which describes the relationship between this
     service and the service specified via ServiceName. Required. Known values are: "Invalid",
     "Affinity", "AlignedAffinity", and "NonAlignedAffinity".
    :vartype scheme: str or ~azure.mgmt.servicefabric.models.ServiceCorrelationScheme
    :ivar service_name: The name of the service that the correlation relationship is established
     with. Required.
    :vartype service_name: str
    """

    scheme: Union[str, "_models.ServiceCorrelationScheme"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The ServiceCorrelationScheme which describes the relationship between this service and the
     service specified via ServiceName. Required. Known values are: \"Invalid\", \"Affinity\",
     \"AlignedAffinity\", and \"NonAlignedAffinity\"."""
    service_name: str = rest_field(name="serviceName", visibility=["read", "create", "update", "delete", "query"])
    """The name of the service that the correlation relationship is established with. Required."""

    @overload
    def __init__(
        self,
        *,
        scheme: Union[str, "_models.ServiceCorrelationScheme"],
        service_name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceLoadMetricDescription(_Model):
    """Specifies a metric to load balance a service during runtime.

    :ivar name: The name of the metric. If the service chooses to report load during runtime, the
     load metric name should match the name that is specified in Name exactly. Note that metric
     names are case sensitive. Required.
    :vartype name: str
    :ivar weight: The service load metric relative weight, compared to other metrics configured for
     this service, as a number. Known values are: "Zero", "Low", "Medium", and "High".
    :vartype weight: str or ~azure.mgmt.servicefabric.models.ServiceLoadMetricWeight
    :ivar primary_default_load: Used only for Stateful services. The default amount of load, as a
     number, that this service creates for this metric when it is a Primary replica.
    :vartype primary_default_load: int
    :ivar secondary_default_load: Used only for Stateful services. The default amount of load, as a
     number, that this service creates for this metric when it is a Secondary replica.
    :vartype secondary_default_load: int
    :ivar default_load: Used only for Stateless services. The default amount of load, as a number,
     that this service creates for this metric.
    :vartype default_load: int
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the metric. If the service chooses to report load during runtime, the load metric
     name should match the name that is specified in Name exactly. Note that metric names are case
     sensitive. Required."""
    weight: Optional[Union[str, "_models.ServiceLoadMetricWeight"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The service load metric relative weight, compared to other metrics configured for this service,
     as a number. Known values are: \"Zero\", \"Low\", \"Medium\", and \"High\"."""
    primary_default_load: Optional[int] = rest_field(
        name="primaryDefaultLoad", visibility=["read", "create", "update", "delete", "query"]
    )
    """Used only for Stateful services. The default amount of load, as a number, that this service
     creates for this metric when it is a Primary replica."""
    secondary_default_load: Optional[int] = rest_field(
        name="secondaryDefaultLoad", visibility=["read", "create", "update", "delete", "query"]
    )
    """Used only for Stateful services. The default amount of load, as a number, that this service
     creates for this metric when it is a Secondary replica."""
    default_load: Optional[int] = rest_field(
        name="defaultLoad", visibility=["read", "create", "update", "delete", "query"]
    )
    """Used only for Stateless services. The default amount of load, as a number, that this service
     creates for this metric."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        weight: Optional[Union[str, "_models.ServiceLoadMetricWeight"]] = None,
        primary_default_load: Optional[int] = None,
        secondary_default_load: Optional[int] = None,
        default_load: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServicePlacementPolicyDescription(_Model):
    """Describes the policy to be used for placement of a Service Fabric service.

    :ivar type: The type of placement policy for a service fabric service. Following are the
     possible values. Required. Known values are: "Invalid", "InvalidDomain", "RequiredDomain",
     "PreferredPrimaryDomain", "RequiredDomainDistribution", and "NonPartiallyPlaceService".
    :vartype type: str or ~azure.mgmt.servicefabric.models.ServicePlacementPolicyType
    """

    type: Union[str, "_models.ServicePlacementPolicyType"] = rest_discriminator(
        name="type", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of placement policy for a service fabric service. Following are the possible values.
     Required. Known values are: \"Invalid\", \"InvalidDomain\", \"RequiredDomain\",
     \"PreferredPrimaryDomain\", \"RequiredDomainDistribution\", and \"NonPartiallyPlaceService\"."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceResource(Resource):
    """The service resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The service resource properties.
    :vartype properties: ~azure.mgmt.servicefabric.models.ServiceResourceProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    """

    properties: Optional["_models.ServiceResourceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The service resource properties."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ServiceResourceProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceResourcePropertiesBase(_Model):
    """The common service resource properties.

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    """

    placement_constraints: Optional[str] = rest_field(
        name="placementConstraints", visibility=["read", "create", "update", "delete", "query"]
    )
    """The placement constraints as a string. Placement constraints are boolean expressions on node
     properties and allow for restricting a service to particular nodes based on the service
     requirements. For example, to place a service on nodes where NodeType is blue specify the
     following: \"NodeColor == blue)\"."""
    correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = rest_field(
        name="correlationScheme", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list that describes the correlation of the service with other services."""
    service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = rest_field(
        name="serviceLoadMetrics", visibility=["read", "create", "update", "delete", "query"]
    )
    """The service load metrics is given as an array of ServiceLoadMetricDescription objects."""
    service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = rest_field(
        name="servicePlacementPolicies", visibility=["read", "create", "update", "delete", "query"]
    )
    """A list that describes the correlation of the service with other services."""
    default_move_cost: Optional[Union[str, "_models.MoveCost"]] = rest_field(
        name="defaultMoveCost", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the move cost for the service. Known values are: \"Zero\", \"Low\", \"Medium\", and
     \"High\"."""

    @overload
    def __init__(
        self,
        *,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceResourceProperties(ServiceResourcePropertiesBase):
    """The service resource properties.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    StatefulServiceProperties, StatelessServiceProperties

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Known values are:
     "Invalid", "Stateless", and "Stateful".
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.ServiceKind
    :ivar service_type_name: The name of the service type.
    :vartype service_type_name: str
    :ivar partition_description: Describes how the service is partitioned.
    :vartype partition_description: ~azure.mgmt.servicefabric.models.PartitionSchemeDescription
    :ivar service_package_activation_mode: The activation Mode of the service package. Known values
     are: "SharedProcess" and "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.mgmt.servicefabric.models.ArmServicePackageActivationMode
    :ivar service_dns_name: Dns name used for the service. If this is specified, then the DNS name
     can be used to return the IP addresses of service endpoints for application layer protocols
     (e.g., HTTP). When updating serviceDnsName, old name may be temporarily resolvable. However,
     rely on new name. When removing serviceDnsName, removed name may temporarily be resolvable. Do
     not rely on the name being unresolvable.
    :vartype service_dns_name: str
    """

    __mapping__: dict[str, _Model] = {}
    provisioning_state: Optional[str] = rest_field(name="provisioningState", visibility=["read"])
    """The current deployment or provisioning state, which only appears in the response."""
    service_kind: str = rest_discriminator(
        name="serviceKind", visibility=["read", "create", "update", "delete", "query"]
    )
    """The kind of service (Stateless or Stateful). Required. Known values are: \"Invalid\",
     \"Stateless\", and \"Stateful\"."""
    service_type_name: Optional[str] = rest_field(
        name="serviceTypeName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the service type."""
    partition_description: Optional["_models.PartitionSchemeDescription"] = rest_field(
        name="partitionDescription", visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes how the service is partitioned."""
    service_package_activation_mode: Optional[Union[str, "_models.ArmServicePackageActivationMode"]] = rest_field(
        name="servicePackageActivationMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The activation Mode of the service package. Known values are: \"SharedProcess\" and
     \"ExclusiveProcess\"."""
    service_dns_name: Optional[str] = rest_field(
        name="serviceDnsName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Dns name used for the service. If this is specified, then the DNS name can be used to return
     the IP addresses of service endpoints for application layer protocols (e.g., HTTP). When
     updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
     When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the
     name being unresolvable."""

    @overload
    def __init__(
        self,
        *,
        service_kind: str,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
        service_type_name: Optional[str] = None,
        partition_description: Optional["_models.PartitionSchemeDescription"] = None,
        service_package_activation_mode: Optional[Union[str, "_models.ArmServicePackageActivationMode"]] = None,
        service_dns_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceResourceUpdate(Resource):
    """The service resource for patch operations.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: The RP-specific properties for this resource.
    :vartype properties: ~azure.mgmt.servicefabric.models.ServiceResourceUpdateProperties
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives.
    :vartype location: str
    :ivar e_tag: If eTag is provided in the response body, it may also be provided as a header per
     the normal etag convention.  Entity tags are used for comparing two or more entities from the
     same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match
     (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
    :vartype e_tag: str
    """

    properties: Optional["_models.ServiceResourceUpdateProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The RP-specific properties for this resource."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """If eTag is provided in the response body, it may also be provided as a header per the normal
     etag convention.  Entity tags are used for comparing two or more entities from the same
     requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section
     14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ServiceResourceUpdateProperties"] = None,
        tags: Optional[dict[str, str]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceResourceUpdateProperties(ServiceResourcePropertiesBase):
    """The service resource properties for patch operations.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    StatefulServiceUpdateProperties, StatelessServiceUpdateProperties

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Known values are:
     "Invalid", "Stateless", and "Stateful".
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.ServiceKind
    """

    __mapping__: dict[str, _Model] = {}
    service_kind: str = rest_discriminator(
        name="serviceKind", visibility=["read", "create", "update", "delete", "query"]
    )
    """The kind of service (Stateless or Stateful). Required. Known values are: \"Invalid\",
     \"Stateless\", and \"Stateful\"."""

    @overload
    def __init__(
        self,
        *,
        service_kind: str,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceTypeDeltaHealthPolicy(_Model):
    """Represents the delta health policy used to evaluate the health of services belonging to a
    service type when upgrading the cluster.

    :ivar max_percent_delta_unhealthy_services: The maximum allowed percentage of services health
     degradation allowed during cluster upgrades. The delta is measured between the state of the
     services at the beginning of upgrade and the state of the services at the time of the health
     evaluation. The check is performed after every upgrade domain upgrade completion to make sure
     the global state of the cluster is within tolerated limits.
    :vartype max_percent_delta_unhealthy_services: int
    """

    max_percent_delta_unhealthy_services: Optional[int] = rest_field(
        name="maxPercentDeltaUnhealthyServices", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum allowed percentage of services health degradation allowed during cluster upgrades.
     The delta is measured between the state of the services at the beginning of upgrade and the
     state of the services at the time of the health evaluation. The check is performed after every
     upgrade domain upgrade completion to make sure the global state of the cluster is within
     tolerated limits."""

    @overload
    def __init__(
        self,
        *,
        max_percent_delta_unhealthy_services: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceTypeHealthPolicy(_Model):
    """Represents the health policy used to evaluate the health of services belonging to a service
    type.

    :ivar max_percent_unhealthy_services: The maximum percentage of services allowed to be
     unhealthy before your application is considered in error.
    :vartype max_percent_unhealthy_services: int
    """

    max_percent_unhealthy_services: Optional[int] = rest_field(
        name="maxPercentUnhealthyServices", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum percentage of services allowed to be unhealthy before your application is
     considered in error."""

    @overload
    def __init__(
        self,
        *,
        max_percent_unhealthy_services: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SettingsParameterDescription(_Model):
    """Describes a parameter in fabric settings of the cluster.

    :ivar name: The parameter name of fabric setting. Required.
    :vartype name: str
    :ivar value: The parameter value of fabric setting. Required.
    :vartype value: str
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The parameter name of fabric setting. Required."""
    value: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The parameter value of fabric setting. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        value: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SettingsSectionDescription(_Model):
    """Describes a section in the fabric settings of the cluster.

    :ivar name: The section name of the fabric settings. Required.
    :vartype name: str
    :ivar parameters: The collection of parameters in the section. Required.
    :vartype parameters: list[~azure.mgmt.servicefabric.models.SettingsParameterDescription]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The section name of the fabric settings. Required."""
    parameters: list["_models.SettingsParameterDescription"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The collection of parameters in the section. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        parameters: list["_models.SettingsParameterDescription"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SingletonPartitionSchemeDescription(PartitionSchemeDescription, discriminator="Singleton"):
    """Describes the partition scheme of a singleton-partitioned, or non-partitioned service.

    :ivar partition_scheme: Specifies how the service is partitioned. Required. Indicates that the
     partition is based on string names, and is a SingletonPartitionSchemeDescription object, The
     value is 1.
    :vartype partition_scheme: str or ~azure.mgmt.servicefabric.models.SINGLETON
    """

    partition_scheme: Literal[PartitionScheme.SINGLETON] = rest_discriminator(name="partitionScheme", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Specifies how the service is partitioned. Required. Indicates that the partition is based on
     string names, and is a SingletonPartitionSchemeDescription object, The value is 1."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.partition_scheme = PartitionScheme.SINGLETON  # type: ignore


class StatefulServiceProperties(ServiceResourceProperties, discriminator="Stateful"):
    """The properties of a stateful service resource.

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    :ivar service_type_name: The name of the service type.
    :vartype service_type_name: str
    :ivar partition_description: Describes how the service is partitioned.
    :vartype partition_description: ~azure.mgmt.servicefabric.models.PartitionSchemeDescription
    :ivar service_package_activation_mode: The activation Mode of the service package. Known values
     are: "SharedProcess" and "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.mgmt.servicefabric.models.ArmServicePackageActivationMode
    :ivar service_dns_name: Dns name used for the service. If this is specified, then the DNS name
     can be used to return the IP addresses of service endpoints for application layer protocols
     (e.g., HTTP). When updating serviceDnsName, old name may be temporarily resolvable. However,
     rely on new name. When removing serviceDnsName, removed name may temporarily be resolvable. Do
     not rely on the name being unresolvable.
    :vartype service_dns_name: str
    :ivar has_persisted_state: A flag indicating whether this is a persistent service which stores
     states on the local disk. If it is then the value of this property is true, if not it is false.
    :vartype has_persisted_state: bool
    :ivar target_replica_set_size: The target replica set size as a number.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: The minimum replica set size as a number.
    :vartype min_replica_set_size: int
    :ivar replica_restart_wait_duration: The duration between when a replica goes down and when a
     new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype replica_restart_wait_duration: ~datetime.datetime
    :ivar quorum_loss_wait_duration: The maximum duration for which a partition is allowed to be in
     a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype quorum_loss_wait_duration: ~datetime.datetime
    :ivar stand_by_replica_keep_duration: The definition on how long StandBy replicas should be
     maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype stand_by_replica_keep_duration: ~datetime.datetime
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Uses Service Fabric
     to make its state or part of its state highly available and reliable. The value is 2.
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.STATEFUL
    """

    has_persisted_state: Optional[bool] = rest_field(
        name="hasPersistedState", visibility=["read", "create", "update", "delete", "query"]
    )
    """A flag indicating whether this is a persistent service which stores states on the local disk.
     If it is then the value of this property is true, if not it is false."""
    target_replica_set_size: Optional[int] = rest_field(
        name="targetReplicaSetSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The target replica set size as a number."""
    min_replica_set_size: Optional[int] = rest_field(
        name="minReplicaSetSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum replica set size as a number."""
    replica_restart_wait_duration: Optional[datetime.datetime] = rest_field(
        name="replicaRestartWaitDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The duration between when a replica goes down and when a new replica is created, represented in
     ISO 8601 format (hh:mm:ss.s)."""
    quorum_loss_wait_duration: Optional[datetime.datetime] = rest_field(
        name="quorumLossWaitDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The maximum duration for which a partition is allowed to be in a state of quorum loss,
     represented in ISO 8601 format (hh:mm:ss.s)."""
    stand_by_replica_keep_duration: Optional[datetime.datetime] = rest_field(
        name="standByReplicaKeepDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The definition on how long StandBy replicas should be maintained before being removed,
     represented in ISO 8601 format (hh:mm:ss.s)."""
    service_kind: Literal[ServiceKind.STATEFUL] = rest_discriminator(name="serviceKind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of service (Stateless or Stateful). Required. Uses Service Fabric to make its state or
     part of its state highly available and reliable. The value is 2."""

    @overload
    def __init__(
        self,
        *,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
        service_type_name: Optional[str] = None,
        partition_description: Optional["_models.PartitionSchemeDescription"] = None,
        service_package_activation_mode: Optional[Union[str, "_models.ArmServicePackageActivationMode"]] = None,
        service_dns_name: Optional[str] = None,
        has_persisted_state: Optional[bool] = None,
        target_replica_set_size: Optional[int] = None,
        min_replica_set_size: Optional[int] = None,
        replica_restart_wait_duration: Optional[datetime.datetime] = None,
        quorum_loss_wait_duration: Optional[datetime.datetime] = None,
        stand_by_replica_keep_duration: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.service_kind = ServiceKind.STATEFUL  # type: ignore


class StatefulServiceUpdateProperties(ServiceResourceUpdateProperties, discriminator="Stateful"):
    """The properties of a stateful service resource for patch operations.

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar target_replica_set_size: The target replica set size as a number.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: The minimum replica set size as a number.
    :vartype min_replica_set_size: int
    :ivar replica_restart_wait_duration: The duration between when a replica goes down and when a
     new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype replica_restart_wait_duration: ~datetime.datetime
    :ivar quorum_loss_wait_duration: The maximum duration for which a partition is allowed to be in
     a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype quorum_loss_wait_duration: ~datetime.datetime
    :ivar stand_by_replica_keep_duration: The definition on how long StandBy replicas should be
     maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
    :vartype stand_by_replica_keep_duration: ~datetime.datetime
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Uses Service Fabric
     to make its state or part of its state highly available and reliable. The value is 2.
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.STATEFUL
    """

    target_replica_set_size: Optional[int] = rest_field(
        name="targetReplicaSetSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The target replica set size as a number."""
    min_replica_set_size: Optional[int] = rest_field(
        name="minReplicaSetSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum replica set size as a number."""
    replica_restart_wait_duration: Optional[datetime.datetime] = rest_field(
        name="replicaRestartWaitDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The duration between when a replica goes down and when a new replica is created, represented in
     ISO 8601 format (hh:mm:ss.s)."""
    quorum_loss_wait_duration: Optional[datetime.datetime] = rest_field(
        name="quorumLossWaitDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The maximum duration for which a partition is allowed to be in a state of quorum loss,
     represented in ISO 8601 format (hh:mm:ss.s)."""
    stand_by_replica_keep_duration: Optional[datetime.datetime] = rest_field(
        name="standByReplicaKeepDuration", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The definition on how long StandBy replicas should be maintained before being removed,
     represented in ISO 8601 format (hh:mm:ss.s)."""
    service_kind: Literal[ServiceKind.STATEFUL] = rest_discriminator(name="serviceKind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of service (Stateless or Stateful). Required. Uses Service Fabric to make its state or
     part of its state highly available and reliable. The value is 2."""

    @overload
    def __init__(
        self,
        *,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
        target_replica_set_size: Optional[int] = None,
        min_replica_set_size: Optional[int] = None,
        replica_restart_wait_duration: Optional[datetime.datetime] = None,
        quorum_loss_wait_duration: Optional[datetime.datetime] = None,
        stand_by_replica_keep_duration: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.service_kind = ServiceKind.STATEFUL  # type: ignore


class StatelessServiceProperties(ServiceResourceProperties, discriminator="Stateless"):
    """The properties of a stateless service resource.

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar provisioning_state: The current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    :ivar service_type_name: The name of the service type.
    :vartype service_type_name: str
    :ivar partition_description: Describes how the service is partitioned.
    :vartype partition_description: ~azure.mgmt.servicefabric.models.PartitionSchemeDescription
    :ivar service_package_activation_mode: The activation Mode of the service package. Known values
     are: "SharedProcess" and "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.mgmt.servicefabric.models.ArmServicePackageActivationMode
    :ivar service_dns_name: Dns name used for the service. If this is specified, then the DNS name
     can be used to return the IP addresses of service endpoints for application layer protocols
     (e.g., HTTP). When updating serviceDnsName, old name may be temporarily resolvable. However,
     rely on new name. When removing serviceDnsName, removed name may temporarily be resolvable. Do
     not rely on the name being unresolvable.
    :vartype service_dns_name: str
    :ivar instance_count: The instance count.
    :vartype instance_count: int
    :ivar instance_close_delay_duration: Delay duration for RequestDrain feature to ensures that
     the endpoint advertised by the stateless instance is removed before the delay starts prior to
     closing the instance. This delay enables existing requests to drain gracefully before the
     instance actually goes down
     (`https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview
     <https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview>`_).
     It is represented in ISO 8601 format (hh:mm:ss.s).
    :vartype instance_close_delay_duration: str
    :ivar min_instance_count: MinInstanceCount is the minimum number of instances that must be up
     to meet the EnsureAvailability safety check during operations like upgrade or deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1
     is first converted into the number of nodes on which the instances are allowed to be placed
     according to the placement constraints on the service.
    :vartype min_instance_count: int
    :ivar min_instance_percentage: MinInstancePercentage is the minimum percentage of InstanceCount
     that must be up to meet the EnsureAvailability safety check during operations like upgrade or
     deactivate node. The actual number that is used is max( MinInstanceCount, ceil(
     MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during
     MinInstancePercentage computation, -1 is first converted into the number of nodes on which the
     instances are allowed to be placed according to the placement constraints on the service.
    :vartype min_instance_percentage: bytes
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Does not use Service
     Fabric to make its state highly available or reliable. The value is 1.
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.STATELESS
    """

    instance_count: Optional[int] = rest_field(
        name="instanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """The instance count."""
    instance_close_delay_duration: Optional[str] = rest_field(
        name="instanceCloseDelayDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Delay duration for RequestDrain feature to ensures that the endpoint advertised by the
     stateless instance is removed before the delay starts prior to closing the instance. This delay
     enables existing requests to drain gracefully before the instance actually goes down
     (`https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview
     <https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview>`_).
     It is represented in ISO 8601 format (hh:mm:ss.s)."""
    min_instance_count: Optional[int] = rest_field(
        name="minInstanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """MinInstanceCount is the minimum number of instances that must be up to meet the
     EnsureAvailability safety check during operations like upgrade or deactivate node. The actual
     number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1
     is first converted into the number of nodes on which the instances are allowed to be placed
     according to the placement constraints on the service."""
    min_instance_percentage: Optional[bytes] = rest_field(
        name="minInstancePercentage", visibility=["read", "create", "update", "delete", "query"], format="base64"
    )
    """MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the
     EnsureAvailability safety check during operations like upgrade or deactivate node. The actual
     number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage
     computation, -1 is first converted into the number of nodes on which the instances are allowed
     to be placed according to the placement constraints on the service."""
    service_kind: Literal[ServiceKind.STATELESS] = rest_discriminator(name="serviceKind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of service (Stateless or Stateful). Required. Does not use Service Fabric to make its
     state highly available or reliable. The value is 1."""

    @overload
    def __init__(
        self,
        *,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
        service_type_name: Optional[str] = None,
        partition_description: Optional["_models.PartitionSchemeDescription"] = None,
        service_package_activation_mode: Optional[Union[str, "_models.ArmServicePackageActivationMode"]] = None,
        service_dns_name: Optional[str] = None,
        instance_count: Optional[int] = None,
        instance_close_delay_duration: Optional[str] = None,
        min_instance_count: Optional[int] = None,
        min_instance_percentage: Optional[bytes] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.service_kind = ServiceKind.STATELESS  # type: ignore


class StatelessServiceUpdateProperties(ServiceResourceUpdateProperties, discriminator="Stateless"):
    """The properties of a stateless service resource for patch operations.

    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: A list that describes the correlation of the service with other
     services.
    :vartype correlation_scheme:
     list[~azure.mgmt.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype service_load_metrics:
     list[~azure.mgmt.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: A list that describes the correlation of the service with
     other services.
    :vartype service_placement_policies:
     list[~azure.mgmt.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: Specifies the move cost for the service. Known values are: "Zero",
     "Low", "Medium", and "High".
    :vartype default_move_cost: str or ~azure.mgmt.servicefabric.models.MoveCost
    :ivar instance_count: The instance count.
    :vartype instance_count: int
    :ivar instance_close_delay_duration: Delay duration for RequestDrain feature to ensures that
     the endpoint advertised by the stateless instance is removed before the delay starts prior to
     closing the instance. This delay enables existing requests to drain gracefully before the
     instance actually goes down
     (`https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview
     <https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview>`_).
     It is represented in ISO 8601 format (hh:mm:ss.s).
    :vartype instance_close_delay_duration: str
    :ivar service_kind: The kind of service (Stateless or Stateful). Required. Does not use Service
     Fabric to make its state highly available or reliable. The value is 1.
    :vartype service_kind: str or ~azure.mgmt.servicefabric.models.STATELESS
    """

    instance_count: Optional[int] = rest_field(
        name="instanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """The instance count."""
    instance_close_delay_duration: Optional[str] = rest_field(
        name="instanceCloseDelayDuration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Delay duration for RequestDrain feature to ensures that the endpoint advertised by the
     stateless instance is removed before the delay starts prior to closing the instance. This delay
     enables existing requests to drain gracefully before the instance actually goes down
     (`https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview
     <https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview>`_).
     It is represented in ISO 8601 format (hh:mm:ss.s)."""
    service_kind: Literal[ServiceKind.STATELESS] = rest_discriminator(name="serviceKind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The kind of service (Stateless or Stateful). Required. Does not use Service Fabric to make its
     state highly available or reliable. The value is 1."""

    @overload
    def __init__(
        self,
        *,
        placement_constraints: Optional[str] = None,
        correlation_scheme: Optional[list["_models.ServiceCorrelationDescription"]] = None,
        service_load_metrics: Optional[list["_models.ServiceLoadMetricDescription"]] = None,
        service_placement_policies: Optional[list["_models.ServicePlacementPolicyDescription"]] = None,
        default_move_cost: Optional[Union[str, "_models.MoveCost"]] = None,
        instance_count: Optional[int] = None,
        instance_close_delay_duration: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.service_kind = ServiceKind.STATELESS  # type: ignore


class SystemData(_Model):
    """Metadata pertaining to creation and last modification of the resource.

    :ivar created_by: The identity that created the resource.
    :vartype created_by: str
    :ivar created_by_type: The type of identity that created the resource. Known values are:
     "User", "Application", "ManagedIdentity", and "Key".
    :vartype created_by_type: str or ~azure.mgmt.servicefabric.models.CreatedByType
    :ivar created_at: The timestamp of resource creation (UTC).
    :vartype created_at: ~datetime.datetime
    :ivar last_modified_by: The identity that last modified the resource.
    :vartype last_modified_by: str
    :ivar last_modified_by_type: The type of identity that last modified the resource. Known values
     are: "User", "Application", "ManagedIdentity", and "Key".
    :vartype last_modified_by_type: str or ~azure.mgmt.servicefabric.models.CreatedByType
    :ivar last_modified_at: The timestamp of resource last modification (UTC).
    :vartype last_modified_at: ~datetime.datetime
    """

    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read", "create", "update", "delete", "query"])
    """The identity that created the resource."""
    created_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="createdByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that created the resource. Known values are: \"User\", \"Application\",
     \"ManagedIdentity\", and \"Key\"."""
    created_at: Optional[datetime.datetime] = rest_field(
        name="createdAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource creation (UTC)."""
    last_modified_by: Optional[str] = rest_field(
        name="lastModifiedBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity that last modified the resource."""
    last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="lastModifiedByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that last modified the resource. Known values are: \"User\",
     \"Application\", \"ManagedIdentity\", and \"Key\"."""
    last_modified_at: Optional[datetime.datetime] = rest_field(
        name="lastModifiedAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource last modification (UTC)."""

    @overload
    def __init__(
        self,
        *,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        created_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UniformInt64RangePartitionSchemeDescription(
    PartitionSchemeDescription, discriminator="UniformInt64Range"
):  # pylint: disable=name-too-long
    """Describes a partitioning scheme where an integer range is allocated evenly across a number of
    partitions.

    :ivar count: The number of partitions. Required.
    :vartype count: int
    :ivar low_key: String indicating the lower bound of the partition key range that should be
     split between the partition count. Required.
    :vartype low_key: str
    :ivar high_key: String indicating the upper bound of the partition key range that should be
     split between the partition count. Required.
    :vartype high_key: str
    :ivar partition_scheme: Specifies how the service is partitioned. Required. Indicates that the
     partition is based on Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription
     object. The value is 2.
    :vartype partition_scheme: str or ~azure.mgmt.servicefabric.models.UNIFORM_INT64_RANGE
    """

    count: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of partitions. Required."""
    low_key: str = rest_field(name="lowKey", visibility=["read", "create", "update", "delete", "query"])
    """String indicating the lower bound of the partition key range that should be split between the
     partition count. Required."""
    high_key: str = rest_field(name="highKey", visibility=["read", "create", "update", "delete", "query"])
    """String indicating the upper bound of the partition key range that should be split between the
     partition count. Required."""
    partition_scheme: Literal[PartitionScheme.UNIFORM_INT64_RANGE] = rest_discriminator(name="partitionScheme", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Specifies how the service is partitioned. Required. Indicates that the partition is based on
     Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription object. The value is 2."""

    @overload
    def __init__(
        self,
        *,
        count: int,
        low_key: str,
        high_key: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.partition_scheme = PartitionScheme.UNIFORM_INT64_RANGE  # type: ignore


class UpgradableVersionPathResult(_Model):
    """The list of intermediate cluster code versions for an upgrade or downgrade, or minimum and
    maximum upgradable version if no target was given.

    :ivar supported_path: The list of intermediate cluster code versions for an upgrade or
     downgrade.
    :vartype supported_path: list[str]
    """

    supported_path: Optional[list[str]] = rest_field(
        name="supportedPath", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of intermediate cluster code versions for an upgrade or downgrade."""

    @overload
    def __init__(
        self,
        *,
        supported_path: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpgradableVersionsDescription(_Model):
    """The upgrade path description with target version.

    :ivar target_version: The target code version. Required.
    :vartype target_version: str
    """

    target_version: str = rest_field(name="targetVersion", visibility=["read", "create", "update", "delete", "query"])
    """The target code version. Required."""

    @overload
    def __init__(
        self,
        *,
        target_version: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserAssignedIdentity(_Model):
    """User assigned identity properties.

    :ivar principal_id: The principal ID of the assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client ID of the assigned identity.
    :vartype client_id: str
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The principal ID of the assigned identity."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read"])
    """The client ID of the assigned identity."""


class VMSize(_Model):
    """VM Sizes properties.

    :ivar size: VM Size name.
    :vartype size: str
    """

    size: Optional[str] = rest_field(visibility=["read"])
    """VM Size name."""


class VMSizeResource(ProxyResource):
    """Describes a VM Sizes.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.servicefabric.models.SystemData
    :ivar properties: VM Size properties.
    :vartype properties: ~azure.mgmt.servicefabric.models.VMSize
    """

    properties: Optional["_models.VMSize"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """VM Size properties."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.VMSize"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
