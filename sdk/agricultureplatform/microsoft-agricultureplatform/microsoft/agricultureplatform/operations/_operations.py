# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterable, List, Optional, TypeVar, Union, overload
import urllib.parse

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._configuration import AgriculturePlatformClientConfiguration
from .._model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from .._serialization import Deserializer, Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
_Unset: Any = object()

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_catalogs_operations_list_request(
    *,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    max_page_size: Optional[int] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_catalogs_operations_get_request(catalog_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_catalogs_operations_create_or_update_request(  # pylint: disable=name-too-long
    catalog_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_catalogs_operations_delete_request(catalog_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_collections_operations_list_request(  # pylint: disable=name-too-long
    catalog_id: str,
    *,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    max_page_size: Optional[int] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_collections_operations_get_request(catalog_id: str, collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_collections_operations_create_or_update_request(  # pylint: disable=name-too-long
    catalog_id: str, collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_collections_operations_delete_request(  # pylint: disable=name-too-long
    catalog_id: str, collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_operations_delete_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/file:delete"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_operations_download_request(
    *, accept: Union[str, _models.AcceptHeaderEnum], **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    # Construct URL
    _url = "/file:download"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_operations_upload_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/file:upload"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_create_request(catalog_id: str, collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}/items:create"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_get_request(catalog_id: str, collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_create_or_update_request(  # pylint: disable=name-too-long
    catalog_id: str, collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_delete_request(
    catalog_id: str, collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_get_all_under_collection_request(  # pylint: disable=name-too-long
    catalog_id: str, collection_id: str, *, maximum_page_size: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/collections/{collectionId}/items:search"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if maximum_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("maximum_page_size", maximum_page_size, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_operations_search_across_collection_request(  # pylint: disable=name-too-long
    catalog_id: str, *, maximum_page_size: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/catalogs/{catalogId}/items:search"
    path_format_arguments = {
        "catalogId": _SERIALIZER.url("catalog_id", catalog_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if maximum_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("maximum_page_size", maximum_page_size, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_satellite_operations_fetch_items_request(  # pylint: disable=name-too-long
    *, maxpagesize: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/satellite:fetch"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if maxpagesize is not None:
        _params["maxpagesize"] = _SERIALIZER.query("maxpagesize", maxpagesize, "int")
    if skip is not None:
        _params["skip"] = _SERIALIZER.query("skip", skip, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_satellite_operations_search_items_request(  # pylint: disable=name-too-long
    *, maxpagesize: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/satellite:stac"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if maxpagesize is not None:
        _params["maxpagesize"] = _SERIALIZER.query("maxpagesize", maxpagesize, "int")
    if skip is not None:
        _params["skip"] = _SERIALIZER.query("skip", skip, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_operations_list_request(
    *,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    max_page_size: Optional[int] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/schemas"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if max_page_size is not None:
        _params["maxPageSize"] = _SERIALIZER.query("max_page_size", max_page_size, "int")
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_operations_get_request(schema_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/schemas/{schemaId}"
    path_format_arguments = {
        "schemaId": _SERIALIZER.url("schema_id", schema_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_operations_create_or_update_request(  # pylint: disable=name-too-long
    schema_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/schemas/{schemaId}"
    path_format_arguments = {
        "schemaId": _SERIALIZER.url("schema_id", schema_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_operations_delete_request(schema_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/schemas/{schemaId}"
    path_format_arguments = {
        "schemaId": _SERIALIZER.url("schema_id", schema_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_solutions_operations_cancel_job_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/solutions:cancel-job"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solutions_operations_create_job_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/solutions:create-job"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solutions_operations_get_data_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/solutions:get-data"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solutions_operations_get_job_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/solutions:get-job"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_operations_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-11-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/external/weather:fetch"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class CatalogsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`catalogs_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable["_models.Catalog"]:
        """Returns a paginated list of Catalog resources.

        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of Catalog
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.agricultureplatform.models.Catalog]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Catalog]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_catalogs_operations_list_request(
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    ids=ids,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    max_page_size=max_page_size,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Catalog], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, catalog_id: str, **kwargs: Any) -> _models.Catalog:
        """Gets a specified Catalog resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :return: Catalog. The Catalog is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Catalog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)

        _request = build_catalogs_operations_get_request(
            catalog_id=catalog_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Catalog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        body: _models.Catalog,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Catalog:
        """Creates or updates a Catalog resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: The resource instance. Required.
        :type body: ~microsoft.agricultureplatform.models.Catalog
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Catalog. The Catalog is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Catalog
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self, catalog_id: str, body: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Catalog:
        """Creates or updates a Catalog resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: The resource instance. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Catalog. The Catalog is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Catalog
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self, catalog_id: str, body: IO[bytes], *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Catalog:
        """Creates or updates a Catalog resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: The resource instance. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Catalog. The Catalog is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Catalog
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_update(
        self, catalog_id: str, body: Union[_models.Catalog, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Catalog:
        """Creates or updates a Catalog resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: The resource instance. Is one of the following types: Catalog, JSON, IO[bytes]
         Required.
        :type body: ~microsoft.agricultureplatform.models.Catalog or JSON or IO[bytes]
        :return: Catalog. The Catalog is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Catalog
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_catalogs_operations_create_or_update_request(
            catalog_id=catalog_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Catalog, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, catalog_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes Catalog for given Catalog id.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_catalogs_operations_delete_request(
            catalog_id=catalog_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CollectionsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`collections_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        catalog_id: str,
        *,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable["_models.Collection"]:
        """Returns a paginated list of Collection resources.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of Collection
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.agricultureplatform.models.Collection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Collection]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_collections_operations_list_request(
                    catalog_id=catalog_id,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    ids=ids,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    max_page_size=max_page_size,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Collection], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, catalog_id: str, collection_id: str, **kwargs: Any) -> _models.Collection:
        """Gets a specified Collection resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Collection] = kwargs.pop("cls", None)

        _request = build_collections_operations_get_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Collection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        body: _models.Collection,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Collection:
        """Creates or updates a Collection resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: The resource instance. Required.
        :type body: ~microsoft.agricultureplatform.models.Collection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        body: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Collection:
        """Creates or updates a Collection resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: The resource instance. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Collection:
        """Creates or updates a Collection resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: The resource instance. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_update(
        self, catalog_id: str, collection_id: str, body: Union[_models.Collection, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Collection:
        """Creates or updates a Collection resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: The resource instance. Is one of the following types: Collection, JSON, IO[bytes]
         Required.
        :type body: ~microsoft.agricultureplatform.models.Collection or JSON or IO[bytes]
        :return: Collection. The Collection is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Collection] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_collections_operations_create_or_update_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Collection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, catalog_id: str, collection_id: str, **kwargs: Any
    ) -> None:
        """Deletes Collection for given Collection id.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_collections_operations_delete_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class FileOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`file_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def delete(self, *, file_path: str, content_type: str = "application/json", **kwargs: Any) -> None:
        """Deletes file.

        :keyword file_path: FilePath. Required.
        :paramtype file_path: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def delete(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> None:
        """Deletes file.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def delete(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> None:
        """Deletes file.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]] = _Unset, *, file_path: str = _Unset, **kwargs: Any
    ) -> None:
        """Deletes file.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword file_path: FilePath. Required.
        :paramtype file_path: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            if file_path is _Unset:
                raise TypeError("missing required argument: file_path")
            body = {"filePath": file_path}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_file_operations_delete_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def download(
        self,
        *,
        accept: Union[str, _models.AcceptHeaderEnum],
        file_path: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> bytes:
        """Downloads and returns file Stream as response for the given input filePath.

        :keyword accept: Accept header. Known values are: "application/json" and
         "application/octet-stream". Required.
        :paramtype accept: str or ~microsoft.agricultureplatform.models.AcceptHeaderEnum
        :keyword file_path: FilePath. Required.
        :paramtype file_path: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def download(
        self,
        body: JSON,
        *,
        accept: Union[str, _models.AcceptHeaderEnum],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> bytes:
        """Downloads and returns file Stream as response for the given input filePath.

        :param body: Required.
        :type body: JSON
        :keyword accept: Accept header. Known values are: "application/json" and
         "application/octet-stream". Required.
        :paramtype accept: str or ~microsoft.agricultureplatform.models.AcceptHeaderEnum
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def download(
        self,
        body: IO[bytes],
        *,
        accept: Union[str, _models.AcceptHeaderEnum],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> bytes:
        """Downloads and returns file Stream as response for the given input filePath.

        :param body: Required.
        :type body: IO[bytes]
        :keyword accept: Accept header. Known values are: "application/json" and
         "application/octet-stream". Required.
        :paramtype accept: str or ~microsoft.agricultureplatform.models.AcceptHeaderEnum
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def download(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        accept: Union[str, _models.AcceptHeaderEnum],
        file_path: str = _Unset,
        **kwargs: Any
    ) -> bytes:
        """Downloads and returns file Stream as response for the given input filePath.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword accept: Accept header. Known values are: "application/json" and
         "application/octet-stream". Required.
        :paramtype accept: str or ~microsoft.agricultureplatform.models.AcceptHeaderEnum
        :keyword file_path: FilePath. Required.
        :paramtype file_path: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[bytes] = kwargs.pop("cls", None)

        if body is _Unset:
            if file_path is _Unset:
                raise TypeError("missing required argument: file_path")
            body = {"filePath": file_path}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_file_operations_download_request(
            accept=accept,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def upload(self, **kwargs: Any) -> _models.FileModel:
        """Uploads a file.

        :return: FileModel. The FileModel is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.FileModel
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FileModel] = kwargs.pop("cls", None)

        _request = build_file_operations_upload_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FileModel, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ItemsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`items_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(
        self,
        catalog_id: str,
        collection_id: str,
        *,
        data: Dict[str, Any],
        content_type: str = "application/json",
        links: Optional[List[_models.Link]] = None,
        status: Optional[str] = None,
        source: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, Any]] = None,
        owner_item_id: Optional[str] = None,
        assets: Optional[List[_models.Asset]] = None,
        **kwargs: Any
    ) -> _models.ItemResponse:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :keyword data: Schema for records under the dataset. Required.
        :paramtype data: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword links: Links for referencing other objects. Default value is None.
        :paramtype links: list[~microsoft.agricultureplatform.models.Link]
        :keyword status: Status of the resource. Default value is None.
        :paramtype status: str
        :keyword source: Source of the resource. Default value is None.
        :paramtype source: str
        :keyword name: Name to identify resource. Default value is None.
        :paramtype name: str
        :keyword description: Textual description of the resource. Default value is None.
        :paramtype description: str
        :keyword properties: A collection of key value pairs that belongs to the resource.
         Each pair must not have a key greater than 50 characters
         and must not have a value greater than 150 characters.
         Note: A maximum of 25 key value pairs can be provided for a resource and only
         string,
         numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported. Default value is None.
        :paramtype properties: dict[str, any]
        :keyword owner_item_id: OwnerItemId. Default value is None.
        :paramtype owner_item_id: str
        :keyword assets: Assets. Default value is None.
        :paramtype assets: list[~microsoft.agricultureplatform.models.Asset]
        :return: ItemResponse. The ItemResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, catalog_id: str, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ItemResponse:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemResponse. The ItemResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self,
        catalog_id: str,
        collection_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ItemResponse:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemResponse. The ItemResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self,
        catalog_id: str,
        collection_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        data: Dict[str, Any] = _Unset,
        links: Optional[List[_models.Link]] = None,
        status: Optional[str] = None,
        source: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, Any]] = None,
        owner_item_id: Optional[str] = None,
        assets: Optional[List[_models.Asset]] = None,
        **kwargs: Any
    ) -> _models.ItemResponse:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword data: Schema for records under the dataset. Required.
        :paramtype data: dict[str, any]
        :keyword links: Links for referencing other objects. Default value is None.
        :paramtype links: list[~microsoft.agricultureplatform.models.Link]
        :keyword status: Status of the resource. Default value is None.
        :paramtype status: str
        :keyword source: Source of the resource. Default value is None.
        :paramtype source: str
        :keyword name: Name to identify resource. Default value is None.
        :paramtype name: str
        :keyword description: Textual description of the resource. Default value is None.
        :paramtype description: str
        :keyword properties: A collection of key value pairs that belongs to the resource.
         Each pair must not have a key greater than 50 characters
         and must not have a value greater than 150 characters.
         Note: A maximum of 25 key value pairs can be provided for a resource and only
         string,
         numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported. Default value is None.
        :paramtype properties: dict[str, any]
        :keyword owner_item_id: OwnerItemId. Default value is None.
        :paramtype owner_item_id: str
        :keyword assets: Assets. Default value is None.
        :paramtype assets: list[~microsoft.agricultureplatform.models.Asset]
        :return: ItemResponse. The ItemResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ItemResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if data is _Unset:
                raise TypeError("missing required argument: data")
            body = {
                "assets": assets,
                "data": data,
                "description": description,
                "links": links,
                "name": name,
                "ownerItemId": owner_item_id,
                "properties": properties,
                "source": source,
                "status": status,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_operations_create_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ItemResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, catalog_id: str, collection_id: str, item_id: str, **kwargs: Any) -> _models.Item:
        """Gets a specified Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :return: Item. The Item is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Item] = kwargs.pop("cls", None)

        _request = build_items_operations_get_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Item, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        item_id: str,
        body: _models.Item,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Item:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :param body: The resource instance. Required.
        :type body: ~microsoft.agricultureplatform.models.Item
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Item. The Item is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Item:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :param body: The resource instance. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Item. The Item is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Item:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :param body: The resource instance. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Item. The Item is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_update(
        self,
        catalog_id: str,
        collection_id: str,
        item_id: str,
        body: Union[_models.Item, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Item:
        """Creates or updates a Item resource.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :param body: The resource instance. Is one of the following types: Item, JSON, IO[bytes]
         Required.
        :type body: ~microsoft.agricultureplatform.models.Item or JSON or IO[bytes]
        :return: Item. The Item is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Item] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_operations_create_or_update_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Item, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, catalog_id: str, collection_id: str, item_id: str, **kwargs: Any
    ) -> None:
        """Deletes Item for given Item id.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param item_id: Id of the Item. Required.
        :type item_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_items_operations_delete_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def get_all_under_collection(
        self,
        catalog_id: str,
        collection_id: str,
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        owner_item_ids: Optional[List[str]] = None,
        data_filters: Optional[List[str]] = None,
        intersects_with_geometry: Optional[_models.GeoJsonObject] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all parties by intersecting geometry.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword owner_item_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype owner_item_ids: list[str]
        :keyword data_filters: Filters on key-value pairs within the Data object.
         e.g. "{testKey} eq {testValue}". Default value is None.
        :paramtype data_filters: list[str]
        :keyword intersects_with_geometry: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects_with_geometry: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_all_under_collection(
        self,
        catalog_id: str,
        collection_id: str,
        body: JSON,
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all parties by intersecting geometry.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: JSON
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_all_under_collection(
        self,
        catalog_id: str,
        collection_id: str,
        body: IO[bytes],
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all parties by intersecting geometry.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_all_under_collection(
        self,
        catalog_id: str,
        collection_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        maximum_page_size: Optional[int] = None,
        owner_item_ids: Optional[List[str]] = None,
        data_filters: Optional[List[str]] = None,
        intersects_with_geometry: Optional[_models.GeoJsonObject] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all parties by intersecting geometry.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param collection_id: Unique resource ID. Required.
        :type collection_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword owner_item_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype owner_item_ids: list[str]
        :keyword data_filters: Filters on key-value pairs within the Data object.
         e.g. "{testKey} eq {testValue}". Default value is None.
        :paramtype data_filters: list[str]
        :keyword intersects_with_geometry: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects_with_geometry: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ItemListResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "dataFilters": data_filters,
                "ids": ids,
                "intersectsWithGeometry": intersects_with_geometry,
                "maxCreatedDateTime": max_created_date_time,
                "maxLastModifiedDateTime": max_last_modified_date_time,
                "maxPageSize": max_page_size,
                "minCreatedDateTime": min_created_date_time,
                "minLastModifiedDateTime": min_last_modified_date_time,
                "ownerItemIds": owner_item_ids,
                "skipToken": skip_token,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_operations_get_all_under_collection_request(
            catalog_id=catalog_id,
            collection_id=collection_id,
            maximum_page_size=maximum_page_size,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ItemListResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def search_across_collection(
        self,
        catalog_id: str,
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        owner_item_ids: Optional[List[str]] = None,
        data_filters: Optional[List[str]] = None,
        intersects_with_geometry: Optional[_models.GeoJsonObject] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        collection_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all collections.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword owner_item_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype owner_item_ids: list[str]
        :keyword data_filters: Filters on key-value pairs within the Data object.
         e.g. "{testKey} eq {testValue}". Default value is None.
        :paramtype data_filters: list[str]
        :keyword intersects_with_geometry: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects_with_geometry: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :keyword collection_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype collection_ids: list[str]
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_across_collection(
        self,
        catalog_id: str,
        body: JSON,
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all collections.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: Required.
        :type body: JSON
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_across_collection(
        self,
        catalog_id: str,
        body: IO[bytes],
        *,
        maximum_page_size: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all collections.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def search_across_collection(
        self,
        catalog_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        maximum_page_size: Optional[int] = None,
        owner_item_ids: Optional[List[str]] = None,
        data_filters: Optional[List[str]] = None,
        intersects_with_geometry: Optional[_models.GeoJsonObject] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        collection_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.ItemListResponse:
        """Search for Items across all collections.

        :param catalog_id: Id of the Catalog. Required.
        :type catalog_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword maximum_page_size: Maximum number of items needed (inclusive). Minimum = 10, Maximum =
         1000,
         Default Value = 50. Default value is None.
        :paramtype maximum_page_size: int
        :keyword owner_item_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype owner_item_ids: list[str]
        :keyword data_filters: Filters on key-value pairs within the Data object.
         e.g. "{testKey} eq {testValue}". Default value is None.
        :paramtype data_filters: list[str]
        :keyword intersects_with_geometry: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects_with_geometry: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :keyword collection_ids: Owner Item Ids of the resource. Default value is None.
        :paramtype collection_ids: list[str]
        :return: ItemListResponse. The ItemListResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.ItemListResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ItemListResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "collectionIds": collection_ids,
                "dataFilters": data_filters,
                "ids": ids,
                "intersectsWithGeometry": intersects_with_geometry,
                "maxCreatedDateTime": max_created_date_time,
                "maxLastModifiedDateTime": max_last_modified_date_time,
                "maxPageSize": max_page_size,
                "minCreatedDateTime": min_created_date_time,
                "minLastModifiedDateTime": min_last_modified_date_time,
                "ownerItemIds": owner_item_ids,
                "skipToken": skip_token,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_operations_search_across_collection_request(
            catalog_id=catalog_id,
            maximum_page_size=maximum_page_size,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ItemListResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SatelliteOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`satellite_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def fetch_items(
        self,
        *,
        credentials: _models.OauthClientCredentials,
        provider: str,
        item_uri: str,
        data: _models.SatelliteData,
        provider_collection_id: str,
        skip: Optional[int] = None,
        content_type: str = "application/json",
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        feature_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SatelliteFetchResponse:
        """Fetches Satellite data.

        :keyword credentials: OAuthClientCredentials for clientId clientSecret auth. Required.
        :paramtype credentials: ~microsoft.agricultureplatform.models.OauthClientCredentials
        :keyword provider: Provider of satellite data. Available Value: SentinelHub. Required.
        :paramtype provider: str
        :keyword item_uri: ItemUri. Required.
        :paramtype item_uri: str
        :keyword data: Data Model for SatelliteIngestionJobRequest. Required.
        :paramtype data: ~microsoft.agricultureplatform.models.SatelliteData
        :keyword provider_collection_id: Collection of satellite data. Available Value: sentinel-2-l2a,
         sentinel-2-l1c. Required.
        :paramtype provider_collection_id: str
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date_time: Start Date. Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: End Date. Default value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword feature_id: Feature Id. Default value is None.
        :paramtype feature_id: str
        :return: SatelliteFetchResponse. The SatelliteFetchResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SatelliteFetchResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def fetch_items(
        self, body: JSON, *, skip: Optional[int] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SatelliteFetchResponse:
        """Fetches Satellite data.

        :param body: Required.
        :type body: JSON
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SatelliteFetchResponse. The SatelliteFetchResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SatelliteFetchResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def fetch_items(
        self, body: IO[bytes], *, skip: Optional[int] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SatelliteFetchResponse:
        """Fetches Satellite data.

        :param body: Required.
        :type body: IO[bytes]
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SatelliteFetchResponse. The SatelliteFetchResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SatelliteFetchResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def fetch_items(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        credentials: _models.OauthClientCredentials = _Unset,
        provider: str = _Unset,
        item_uri: str = _Unset,
        data: _models.SatelliteData = _Unset,
        provider_collection_id: str = _Unset,
        skip: Optional[int] = None,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        feature_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SatelliteFetchResponse:
        """Fetches Satellite data.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword credentials: OAuthClientCredentials for clientId clientSecret auth. Required.
        :paramtype credentials: ~microsoft.agricultureplatform.models.OauthClientCredentials
        :keyword provider: Provider of satellite data. Available Value: SentinelHub. Required.
        :paramtype provider: str
        :keyword item_uri: ItemUri. Required.
        :paramtype item_uri: str
        :keyword data: Data Model for SatelliteIngestionJobRequest. Required.
        :paramtype data: ~microsoft.agricultureplatform.models.SatelliteData
        :keyword provider_collection_id: Collection of satellite data. Available Value: sentinel-2-l2a,
         sentinel-2-l1c. Required.
        :paramtype provider_collection_id: str
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword start_date_time: Start Date. Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: End Date. Default value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword feature_id: Feature Id. Default value is None.
        :paramtype feature_id: str
        :return: SatelliteFetchResponse. The SatelliteFetchResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SatelliteFetchResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[_models.SatelliteFetchResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if credentials is _Unset:
                raise TypeError("missing required argument: credentials")
            if provider is _Unset:
                raise TypeError("missing required argument: provider")
            if item_uri is _Unset:
                raise TypeError("missing required argument: item_uri")
            if data is _Unset:
                raise TypeError("missing required argument: data")
            if provider_collection_id is _Unset:
                raise TypeError("missing required argument: provider_collection_id")
            body = {
                "credentials": credentials,
                "data": data,
                "endDateTime": end_date_time,
                "featureId": feature_id,
                "itemUri": item_uri,
                "provider": provider,
                "providerCollectionId": provider_collection_id,
                "startDateTime": start_date_time,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_satellite_operations_fetch_items_request(
            maxpagesize=maxpagesize,
            skip=skip,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SatelliteFetchResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def search_items(
        self,
        *,
        credentials: _models.OauthClientCredentials,
        provider: str,
        provider_collection_id: str,
        skip: Optional[int] = None,
        content_type: str = "application/json",
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        intersects: Optional[_models.GeoJsonObject] = None,
        bbox: Optional[List[float]] = None,
        feature_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.SearchFeaturesResponse:
        """Searches for STAC items by collection id, bbox, intersecting geometry, start
        and end datetime.

        :keyword credentials: OAuthClientCredentials for clientId clientSecret auth. Required.
        :paramtype credentials: ~microsoft.agricultureplatform.models.OauthClientCredentials
        :keyword provider: Provider of satellite data. Available Value: SentinelHub. Required.
        :paramtype provider: str
        :keyword provider_collection_id: Collection of satellite data. Available Value: sentinel-2-l2a,
         sentinel-2-l1c. Required.
        :paramtype provider_collection_id: str
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date_time: Start datetime of the time interval in which to search for Items.
         Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: End datetime of the time interval in which to search for Items. Default
         value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword intersects: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword bbox: Only items that have a geometry that intersects the bounding box are selected.
         The bounding box is provided as four numbers. The coordinate reference system
         of the values is WGS84 longitude/latitude. Default value is None.
        :paramtype bbox: list[float]
        :keyword feature_ids: Array of feature ids to return. Default value is None.
        :paramtype feature_ids: list[str]
        :return: SearchFeaturesResponse. The SearchFeaturesResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SearchFeaturesResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_items(
        self, body: JSON, *, skip: Optional[int] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchFeaturesResponse:
        """Searches for STAC items by collection id, bbox, intersecting geometry, start
        and end datetime.

        :param body: Required.
        :type body: JSON
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchFeaturesResponse. The SearchFeaturesResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SearchFeaturesResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_items(
        self, body: IO[bytes], *, skip: Optional[int] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchFeaturesResponse:
        """Searches for STAC items by collection id, bbox, intersecting geometry, start
        and end datetime.

        :param body: Required.
        :type body: IO[bytes]
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchFeaturesResponse. The SearchFeaturesResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SearchFeaturesResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def search_items(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        credentials: _models.OauthClientCredentials = _Unset,
        provider: str = _Unset,
        provider_collection_id: str = _Unset,
        skip: Optional[int] = None,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        intersects: Optional[_models.GeoJsonObject] = None,
        bbox: Optional[List[float]] = None,
        feature_ids: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.SearchFeaturesResponse:
        """Searches for STAC items by collection id, bbox, intersecting geometry, start
        and end datetime.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword credentials: OAuthClientCredentials for clientId clientSecret auth. Required.
        :paramtype credentials: ~microsoft.agricultureplatform.models.OauthClientCredentials
        :keyword provider: Provider of satellite data. Available Value: SentinelHub. Required.
        :paramtype provider: str
        :keyword provider_collection_id: Collection of satellite data. Available Value: sentinel-2-l2a,
         sentinel-2-l1c. Required.
        :paramtype provider_collection_id: str
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword start_date_time: Start datetime of the time interval in which to search for Items.
         Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: End datetime of the time interval in which to search for Items. Default
         value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword intersects: GeoJSON (For more details: `https://geojson.org/
         <https://geojson.org/>`_). Note: Coordinates are
         expected in [Longitude, Latitude] format. Default value is None.
        :paramtype intersects: ~microsoft.agricultureplatform.models.GeoJsonObject
        :keyword bbox: Only items that have a geometry that intersects the bounding box are selected.
         The bounding box is provided as four numbers. The coordinate reference system
         of the values is WGS84 longitude/latitude. Default value is None.
        :paramtype bbox: list[float]
        :keyword feature_ids: Array of feature ids to return. Default value is None.
        :paramtype feature_ids: list[str]
        :return: SearchFeaturesResponse. The SearchFeaturesResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SearchFeaturesResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        maxpagesize = kwargs.pop("maxpagesize", None)
        cls: ClsType[_models.SearchFeaturesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if credentials is _Unset:
                raise TypeError("missing required argument: credentials")
            if provider is _Unset:
                raise TypeError("missing required argument: provider")
            if provider_collection_id is _Unset:
                raise TypeError("missing required argument: provider_collection_id")
            body = {
                "bbox": bbox,
                "credentials": credentials,
                "endDateTime": end_date_time,
                "featureIds": feature_ids,
                "intersects": intersects,
                "provider": provider,
                "providerCollectionId": provider_collection_id,
                "startDateTime": start_date_time,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_satellite_operations_search_items_request(
            maxpagesize=maxpagesize,
            skip=skip,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchFeaturesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SchemasOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`schemas_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable["_models.Schema"]:
        """Returns a paginated list of Schema resources.

        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50. Default value is None.
        :paramtype max_page_size: int
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of Schema
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.agricultureplatform.models.Schema]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Schema]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_schemas_operations_list_request(
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    ids=ids,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    max_page_size=max_page_size,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Schema], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, schema_id: str, **kwargs: Any) -> _models.Schema:
        """Gets a specified Schema resource.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :return: Schema. The Schema is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Schema
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Schema] = kwargs.pop("cls", None)

        _request = build_schemas_operations_get_request(
            schema_id=schema_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Schema, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_update(
        self, schema_id: str, body: _models.Schema, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Schema:
        """Creates or updates a Schema resource.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :param body: The resource instance. Required.
        :type body: ~microsoft.agricultureplatform.models.Schema
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Schema. The Schema is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Schema
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self, schema_id: str, body: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Schema:
        """Creates or updates a Schema resource.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :param body: The resource instance. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Schema. The Schema is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Schema
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update(
        self, schema_id: str, body: IO[bytes], *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Schema:
        """Creates or updates a Schema resource.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :param body: The resource instance. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Schema. The Schema is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Schema
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_update(
        self, schema_id: str, body: Union[_models.Schema, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Schema:
        """Creates or updates a Schema resource.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :param body: The resource instance. Is one of the following types: Schema, JSON, IO[bytes]
         Required.
        :type body: ~microsoft.agricultureplatform.models.Schema or JSON or IO[bytes]
        :return: Schema. The Schema is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.Schema
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Schema] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_schemas_operations_create_or_update_request(
            schema_id=schema_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Schema, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, schema_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes Schema for given Schema id.

        :param schema_id: Id of the Schema. Required.
        :type schema_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_schemas_operations_delete_request(
            schema_id=schema_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class SolutionsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`solutions_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def cancel_job(
        self,
        *,
        solution_id: str,
        request_path: str,
        partner_request_body: Dict[str, Any],
        partner_request_headers: Dict[str, Any],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Cancel Solution job Async.

        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def cancel_job(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Cancel Solution job Async.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def cancel_job(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Cancel Solution job Async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def cancel_job(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        solution_id: str = _Unset,
        request_path: str = _Unset,
        partner_request_body: Dict[str, Any] = _Unset,
        partner_request_headers: Dict[str, Any] = _Unset,
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Cancel Solution job Async.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SamplePartnerResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if solution_id is _Unset:
                raise TypeError("missing required argument: solution_id")
            if request_path is _Unset:
                raise TypeError("missing required argument: request_path")
            if partner_request_body is _Unset:
                raise TypeError("missing required argument: partner_request_body")
            if partner_request_headers is _Unset:
                raise TypeError("missing required argument: partner_request_headers")
            body = {
                "partnerRequestBody": partner_request_body,
                "partnerRequestHeaders": partner_request_headers,
                "requestPath": request_path,
                "solutionId": solution_id,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solutions_operations_cancel_job_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SamplePartnerResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_job(
        self,
        *,
        solution_id: str,
        request_path: str,
        partner_request_body: Dict[str, Any],
        partner_request_headers: Dict[str, Any],
        input_data: Dict[str, Any],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Creates solution job async.

        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword input_data: Input Data. Required.
        :paramtype input_data: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_job(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Creates solution job async.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_job(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Creates solution job async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_job(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        solution_id: str = _Unset,
        request_path: str = _Unset,
        partner_request_body: Dict[str, Any] = _Unset,
        partner_request_headers: Dict[str, Any] = _Unset,
        input_data: Dict[str, Any] = _Unset,
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Creates solution job async.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword input_data: Input Data. Required.
        :paramtype input_data: dict[str, any]
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SamplePartnerResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if solution_id is _Unset:
                raise TypeError("missing required argument: solution_id")
            if request_path is _Unset:
                raise TypeError("missing required argument: request_path")
            if partner_request_body is _Unset:
                raise TypeError("missing required argument: partner_request_body")
            if partner_request_headers is _Unset:
                raise TypeError("missing required argument: partner_request_headers")
            if input_data is _Unset:
                raise TypeError("missing required argument: input_data")
            body = {
                "inputData": input_data,
                "partnerRequestBody": partner_request_body,
                "partnerRequestHeaders": partner_request_headers,
                "requestPath": request_path,
                "solutionId": solution_id,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solutions_operations_create_job_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SamplePartnerResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def get_data(
        self,
        *,
        solution_id: str,
        request_path: str,
        partner_request_body: Dict[str, Any],
        partner_request_headers: Dict[str, Any],
        input_data: Dict[str, Any],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets solution Data async.

        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword input_data: Input Data. Required.
        :paramtype input_data: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_data(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets solution Data async.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_data(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets solution Data async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_data(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        solution_id: str = _Unset,
        request_path: str = _Unset,
        partner_request_body: Dict[str, Any] = _Unset,
        partner_request_headers: Dict[str, Any] = _Unset,
        input_data: Dict[str, Any] = _Unset,
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets solution Data async.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword input_data: Input Data. Required.
        :paramtype input_data: dict[str, any]
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SamplePartnerResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if solution_id is _Unset:
                raise TypeError("missing required argument: solution_id")
            if request_path is _Unset:
                raise TypeError("missing required argument: request_path")
            if partner_request_body is _Unset:
                raise TypeError("missing required argument: partner_request_body")
            if partner_request_headers is _Unset:
                raise TypeError("missing required argument: partner_request_headers")
            if input_data is _Unset:
                raise TypeError("missing required argument: input_data")
            body = {
                "inputData": input_data,
                "partnerRequestBody": partner_request_body,
                "partnerRequestHeaders": partner_request_headers,
                "requestPath": request_path,
                "solutionId": solution_id,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solutions_operations_get_data_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SamplePartnerResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def get_job(
        self,
        *,
        solution_id: str,
        request_path: str,
        partner_request_body: Dict[str, Any],
        partner_request_headers: Dict[str, Any],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets Solution get job response async.

        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_job(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets Solution get job response async.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_job(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets Solution get job response async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_job(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        solution_id: str = _Unset,
        request_path: str = _Unset,
        partner_request_body: Dict[str, Any] = _Unset,
        partner_request_headers: Dict[str, Any] = _Unset,
        **kwargs: Any
    ) -> _models.SamplePartnerResponse:
        """Gets Solution get job response async.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword solution_id: SolutionId. Required.
        :paramtype solution_id: str
        :keyword request_path: RequestPath. Required.
        :paramtype request_path: str
        :keyword partner_request_body: Properties. Required.
        :paramtype partner_request_body: dict[str, any]
        :keyword partner_request_headers: Properties. Required.
        :paramtype partner_request_headers: dict[str, any]
        :return: SamplePartnerResponse. The SamplePartnerResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.SamplePartnerResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SamplePartnerResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if solution_id is _Unset:
                raise TypeError("missing required argument: solution_id")
            if request_path is _Unset:
                raise TypeError("missing required argument: request_path")
            if partner_request_body is _Unset:
                raise TypeError("missing required argument: partner_request_body")
            if partner_request_headers is _Unset:
                raise TypeError("missing required argument: partner_request_headers")
            body = {
                "partnerRequestBody": partner_request_body,
                "partnerRequestHeaders": partner_request_headers,
                "requestPath": request_path,
                "solutionId": solution_id,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_solutions_operations_get_job_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SamplePartnerResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WeatherOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agricultureplatform.AgriculturePlatformClient`'s
        :attr:`weather_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AgriculturePlatformClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def get(
        self,
        *,
        provider_name: str,
        provider_api_name: str,
        units: str,
        content_type: str = "application/json",
        language: Optional[str] = None,
        credentials: Optional[_models.ApiKeyAuthCredentials] = None,
        locations: Optional[List[_models.WeatherLocation]] = None,
        **kwargs: Any
    ) -> _models.WeatherResponse:
        """Returns a list of WeatherData.

        :keyword provider_name: Weather provider name. Required.
        :paramtype provider_name: str
        :keyword provider_api_name: Provider's api name to which request is to be made. Required.
        :paramtype provider_api_name: str
        :keyword units: Units for which request to data provider is to be sent. Supported values are
         'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's'
         for Metric SI units. Required.
        :paramtype units: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword language: Language (IETF BCP 47 language tag) in which search results should be
         returned
         by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'. Default value is None.
        :paramtype language: str
        :keyword credentials: Api Key Auth Credentials class for API Key based Auth. Default value is
         None.
        :paramtype credentials: ~microsoft.agricultureplatform.models.ApiKeyAuthCredentials
        :keyword locations: List of locations for which weather data need to be fetched from the
         provider. Default value is None.
        :paramtype locations: list[~microsoft.agricultureplatform.models.WeatherLocation]
        :return: WeatherResponse. The WeatherResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.WeatherResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.WeatherResponse:
        """Returns a list of WeatherData.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WeatherResponse. The WeatherResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.WeatherResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> _models.WeatherResponse:
        """Returns a list of WeatherData.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WeatherResponse. The WeatherResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.WeatherResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        provider_name: str = _Unset,
        provider_api_name: str = _Unset,
        units: str = _Unset,
        language: Optional[str] = None,
        credentials: Optional[_models.ApiKeyAuthCredentials] = None,
        locations: Optional[List[_models.WeatherLocation]] = None,
        **kwargs: Any
    ) -> _models.WeatherResponse:
        """Returns a list of WeatherData.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword provider_name: Weather provider name. Required.
        :paramtype provider_name: str
        :keyword provider_api_name: Provider's api name to which request is to be made. Required.
        :paramtype provider_api_name: str
        :keyword units: Units for which request to data provider is to be sent. Supported values are
         'e' for English units, 'm' for Metric units, 'h' for Hybrid units (UK) and 's'
         for Metric SI units. Required.
        :paramtype units: str
        :keyword language: Language (IETF BCP 47 language tag) in which search results should be
         returned
         by the data provider. Examples: 'en-US', 'es', 'es-MX', 'fr-FR'. Default value is None.
        :paramtype language: str
        :keyword credentials: Api Key Auth Credentials class for API Key based Auth. Default value is
         None.
        :paramtype credentials: ~microsoft.agricultureplatform.models.ApiKeyAuthCredentials
        :keyword locations: List of locations for which weather data need to be fetched from the
         provider. Default value is None.
        :paramtype locations: list[~microsoft.agricultureplatform.models.WeatherLocation]
        :return: WeatherResponse. The WeatherResponse is compatible with MutableMapping
        :rtype: ~microsoft.agricultureplatform.models.WeatherResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WeatherResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if provider_name is _Unset:
                raise TypeError("missing required argument: provider_name")
            if provider_api_name is _Unset:
                raise TypeError("missing required argument: provider_api_name")
            if units is _Unset:
                raise TypeError("missing required argument: units")
            body = {
                "credentials": credentials,
                "language": language,
                "locations": locations,
                "providerApiName": provider_api_name,
                "providerName": provider_name,
                "units": units,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_weather_operations_get_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WeatherResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
