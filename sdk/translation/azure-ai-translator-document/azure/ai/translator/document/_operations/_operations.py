# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import _model_base, models as _models
from .._model_base import _deserialize
from .._serialization import Serializer
from .._vendor import (
    DocumentTranslationClientMixinABC,
    handle_multipart_form_data_model,
    multipart_data,
    multipart_file,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_document_translation_document_translate_request(  # pylint: disable=name-too-long
    *,
    target_language: str,
    source_language: Optional[str] = None,
    category: Optional[str] = None,
    allow_fallback: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-11-01-preview"))
    accept = _headers.pop("Accept", "application/octet-stream")

    # Construct URL
    _url = "/document:translate"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if source_language is not None:
        _params["sourceLanguage"] = _SERIALIZER.query("source_language", source_language, "str")
    _params["targetLanguage"] = _SERIALIZER.query("target_language", target_language, "str")
    if category is not None:
        _params["category"] = _SERIALIZER.query("category", category, "str")
    if allow_fallback is not None:
        _params["allowFallback"] = _SERIALIZER.query("allow_fallback", allow_fallback, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class DocumentTranslationClientOperationsMixin(DocumentTranslationClientMixinABC):
    @overload
    def document_translate(
        self,
        body: _models.DocumentTranslateContent,
        *,
        target_language: str,
        source_language: Optional[str] = None,
        category: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """API to translate a document.

        :param body: Required.
        :type body: ~azure.ai.translator.document.models.DocumentTranslateContent
        :keyword target_language: Specifies the language of the output document.
         The target language must be one of the supported languages included in the translation scope.
         For example if you want to translate the document in German language, then use
         targetLanguage=de. Required.
        :paramtype target_language: str
        :keyword source_language: Specifies source language of the input document.
         If this parameter isn't specified, automatic language detection is applied to determine the
         source language.
         For example if the source document is written in English, then use sourceLanguage=en. Default
         value is None.
        :paramtype source_language: str
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
             from a customized system built with Custom Translator. Add the Category ID from your
         Custom Translator
             project details to this parameter to use your deployed customized system. Default value
         is: general. Default value is None.
        :paramtype category: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
             Possible values are: true (default) or false. Default value is None.
        :paramtype allow_fallback: bool
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "document": bytes("bytes", encoding="utf-8"),  # Document to be translated in
                      the form. Required.
                    "glossary": [
                        bytes("bytes", encoding="utf-8")  # Optional. Glossary / translation
                          memory will be used during translation in the form.
                    ]
                }
        """

    @overload
    def document_translate(
        self,
        body: JSON,
        *,
        target_language: str,
        source_language: Optional[str] = None,
        category: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        **kwargs: Any
    ) -> bytes:
        """API to translate a document.

        :param body: Required.
        :type body: JSON
        :keyword target_language: Specifies the language of the output document.
         The target language must be one of the supported languages included in the translation scope.
         For example if you want to translate the document in German language, then use
         targetLanguage=de. Required.
        :paramtype target_language: str
        :keyword source_language: Specifies source language of the input document.
         If this parameter isn't specified, automatic language detection is applied to determine the
         source language.
         For example if the source document is written in English, then use sourceLanguage=en. Default
         value is None.
        :paramtype source_language: str
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
             from a customized system built with Custom Translator. Add the Category ID from your
         Custom Translator
             project details to this parameter to use your deployed customized system. Default value
         is: general. Default value is None.
        :paramtype category: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
             Possible values are: true (default) or false. Default value is None.
        :paramtype allow_fallback: bool
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def document_translate(
        self,
        body: Union[_models.DocumentTranslateContent, JSON],
        *,
        target_language: str,
        source_language: Optional[str] = None,
        category: Optional[str] = None,
        allow_fallback: Optional[bool] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """API to translate a document.

        :param body: Is either a DocumentTranslateContent type or a JSON type. Required.
        :type body: ~azure.ai.translator.document.models.DocumentTranslateContent or JSON
        :keyword target_language: Specifies the language of the output document.
         The target language must be one of the supported languages included in the translation scope.
         For example if you want to translate the document in German language, then use
         targetLanguage=de. Required.
        :paramtype target_language: str
        :keyword source_language: Specifies source language of the input document.
         If this parameter isn't specified, automatic language detection is applied to determine the
         source language.
         For example if the source document is written in English, then use sourceLanguage=en. Default
         value is None.
        :paramtype source_language: str
        :keyword category: A string specifying the category (domain) of the translation. This parameter
         is used to get translations
             from a customized system built with Custom Translator. Add the Category ID from your
         Custom Translator
             project details to this parameter to use your deployed customized system. Default value
         is: general. Default value is None.
        :paramtype category: str
        :keyword allow_fallback: Specifies that the service is allowed to fall back to a general system
         when a custom system doesn't exist.
             Possible values are: true (default) or false. Default value is None.
        :paramtype allow_fallback: bool
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "document": bytes("bytes", encoding="utf-8"),  # Document to be translated in
                      the form. Required.
                    "glossary": [
                        bytes("bytes", encoding="utf-8")  # Optional. Glossary / translation
                          memory will be used during translation in the form.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop("cls", None)

        if isinstance(body, _model_base.Model):
            _body = handle_multipart_form_data_model(body)
        else:
            _body = body
        _files = {k: multipart_file(v) for k, v in _body.items() if isinstance(v, (IOBase, bytes))}
        _data = {k: multipart_data(v) for k, v in _body.items() if not isinstance(v, (IOBase, bytes))}

        _request = build_document_translation_document_translate_request(
            target_language=target_language,
            source_language=source_language,
            category=category,
            allow_fallback=allow_fallback,
            api_version=self._config.api_version,
            data=_data,
            files=_files,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        response.read()
        deserialized = response.content

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
