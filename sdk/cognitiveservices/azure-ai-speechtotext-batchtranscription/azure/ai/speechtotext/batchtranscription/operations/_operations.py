# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._configuration import SpeechToTextClientConfiguration
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Deserializer, Serializer
from .._validation import api_version_validation
from .._vendor import raise_if_not_implemented

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_batch_transcription_submit_transcription_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    service_api_versions_query_parameter: str = kwargs.pop(
        "service_api_versions_query_parameter", _params.pop("api-version", "2024-11-15")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/transcriptions:submit"

    # Construct parameters
    if service_api_versions_query_parameter is not None:
        _params["api-version"] = _SERIALIZER.query(
            "service_api_versions_query_parameter", service_api_versions_query_parameter, "str"
        )

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_batch_transcription_get_transcriptions_request(  # pylint: disable=name-too-long
    *, skip: Optional[int] = None, top: Optional[int] = None, filter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    service_api_versions_query_parameter: str = kwargs.pop(
        "service_api_versions_query_parameter", _params.pop("api-version", "2024-11-15")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/transcriptions"

    # Construct parameters
    if skip is not None:
        _params["skip"] = _SERIALIZER.query("skip", skip, "int")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if filter is not None:
        _params["filter"] = _SERIALIZER.query("filter", filter, "str")
    if service_api_versions_query_parameter is not None:
        _params["api-version"] = _SERIALIZER.query(
            "service_api_versions_query_parameter", service_api_versions_query_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_batch_transcription_get_transcription_files_request(  # pylint: disable=name-too-long
    id: str,
    *,
    skip: Optional[int] = None,
    top: Optional[int] = None,
    sas_lifetime_minutes: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    service_api_versions_query_parameter: str = kwargs.pop(
        "service_api_versions_query_parameter", _params.pop("api-version", "2024-11-15")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/transcriptions/{id}/files"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if skip is not None:
        _params["skip"] = _SERIALIZER.query("skip", skip, "int")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if sas_lifetime_minutes is not None:
        _params["sasLifetimeMinutes"] = _SERIALIZER.query("sas_lifetime_minutes", sas_lifetime_minutes, "int")
    if service_api_versions_query_parameter is not None:
        _params["api-version"] = _SERIALIZER.query(
            "service_api_versions_query_parameter", service_api_versions_query_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_batch_transcription_get_transcription_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    service_api_versions_query_parameter: str = kwargs.pop(
        "service_api_versions_query_parameter", _params.pop("api-version", "2024-11-15")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/transcriptions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if service_api_versions_query_parameter is not None:
        _params["api-version"] = _SERIALIZER.query(
            "service_api_versions_query_parameter", service_api_versions_query_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_batch_transcription_delete_transcription_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    service_api_versions_query_parameter: str = kwargs.pop(
        "service_api_versions_query_parameter", _params.pop("api-version", "2024-11-15")
    )
    # Construct URL
    _url = "/transcriptions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if service_api_versions_query_parameter is not None:
        _params["api-version"] = _SERIALIZER.query(
            "service_api_versions_query_parameter", service_api_versions_query_parameter, "str"
        )

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


class ClientCustomizationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.speechtotext.batchtranscription.SpeechToTextClient`'s
        :attr:`client_customizations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: SpeechToTextClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class BatchTranscriptionOperations:  # pylint: disable=abstract-class-instantiated
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.speechtotext.batchtranscription.SpeechToTextClient`'s
        :attr:`batch_transcription` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: SpeechToTextClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        raise_if_not_implemented(
            self.__class__,
            [
                "patch_transcription",
            ],
        )

    @overload
    def submit_transcription(
        self, transcription: _models.Transcription, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Transcription:
        """Submits a new transcription job.

        :param transcription: Transcription. Required.
        :type transcription: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Transcription. The Transcription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def submit_transcription(
        self, transcription: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Transcription:
        """Submits a new transcription job.

        :param transcription: Transcription. Required.
        :type transcription: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Transcription. The Transcription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def submit_transcription(
        self, transcription: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Transcription:
        """Submits a new transcription job.

        :param transcription: Transcription. Required.
        :type transcription: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Transcription. The Transcription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def submit_transcription(
        self, transcription: Union[_models.Transcription, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Transcription:
        """Submits a new transcription job.

        :param transcription: Transcription. Is one of the following types: Transcription, JSON,
         IO[bytes] Required.
        :type transcription: ~azure.ai.speechtotext.batchtranscription.models.Transcription or JSON or
         IO[bytes]
        :return: Transcription. The Transcription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Transcription] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(transcription, (IOBase, bytes)):
            _content = transcription
        else:
            _content = json.dumps(transcription, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_batch_transcription_submit_transcription_request(
            content_type=content_type,
            service_api_versions_query_parameter=self._config.service_api_versions_query_parameter,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Transcription, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_transcriptions(
        self, *, skip: Optional[int] = None, top: Optional[int] = None, filter: Optional[str] = None, **kwargs: Any
    ) -> _models.PageableTranscription:
        """Gets a list of transcriptions for the authenticated subscription.

        :keyword skip: Number of transcriptions that will be skipped. Default value is None.
        :paramtype skip: int
        :keyword top: Number of transcriptions that will be included after skipping. Default value is
         None.
        :paramtype top: int
        :keyword filter: A filtering expression for selecting a subset of the available transcriptions.

         .. code-block::

                    - Supported properties: displayName, description, createdDateTime,
         lastActionDateTime, status, locale.
                    - Operators:
                      - eq, ne are supported for all properties.
                      - gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.
                      - and, or, not are supported.
                    - Example:
                      filter=createdDateTime gt 2022-02-01T11:00:00Z. Default value is None.
        :paramtype filter: str
        :return: PageableTranscription. The PageableTranscription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.PageableTranscription
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PageableTranscription] = kwargs.pop("cls", None)

        _request = build_batch_transcription_get_transcriptions_request(
            skip=skip,
            top=top,
            filter=filter,
            service_api_versions_query_parameter=self._config.service_api_versions_query_parameter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PageableTranscription, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    @api_version_validation(
        params_added_on={"2024-11-15": ["sas_lifetime_minutes"]},
    )
    def get_transcription_files(
        self,
        id: str,
        *,
        skip: Optional[int] = None,
        top: Optional[int] = None,
        sas_lifetime_minutes: Optional[int] = None,
        **kwargs: Any,
    ) -> _models.PageableFile:
        """Gets the files of the transcription identified by the given ID.

        :param id: The identifier of the transcription. Required.
        :type id: str
        :keyword skip: Number of transcription files that will be skipped. Default value is None.
        :paramtype skip: int
        :keyword top: Number of transcription files that will be included after skipping. Default value
         is None.
        :paramtype top: int
        :keyword sas_lifetime_minutes: This parameter defines the duration in minutes for which an SAS
         url should be valid.
                     The parameter can only be used for operations on speech resources that don't have
         BYOS enabled and transcriptions without a destinationContainerUrl. For speech resources
                     that don't have BYOS enabled, the default SAS validity duration is 12 hours.
                     For speech resources with BYOS and transcriptions with a destinationContainerUrl,
         returned urls do not contain an SAS token. Default value is None.
        :paramtype sas_lifetime_minutes: int
        :return: PageableFile. The PageableFile is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.PageableFile
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PageableFile] = kwargs.pop("cls", None)

        _request = build_batch_transcription_get_transcription_files_request(
            id=id,
            skip=skip,
            top=top,
            sas_lifetime_minutes=sas_lifetime_minutes,
            service_api_versions_query_parameter=self._config.service_api_versions_query_parameter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PageableFile, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_transcription(self, id: str, **kwargs: Any) -> _models.Transcription:
        """Gets the transcription identified by the given ID.

        :param id: The identifier of the transcription. Required.
        :type id: str
        :return: Transcription. The Transcription is compatible with MutableMapping
        :rtype: ~azure.ai.speechtotext.batchtranscription.models.Transcription
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Transcription] = kwargs.pop("cls", None)

        _request = build_batch_transcription_get_transcription_request(
            id=id,
            service_api_versions_query_parameter=self._config.service_api_versions_query_parameter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Transcription, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_transcription(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes the specified transcription task.

        :param id: The identifier of the transcription. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_batch_transcription_delete_transcription_request(
            id=id,
            service_api_versions_query_parameter=self._config.service_api_versions_query_parameter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
