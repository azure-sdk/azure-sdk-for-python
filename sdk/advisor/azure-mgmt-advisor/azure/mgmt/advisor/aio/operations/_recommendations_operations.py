# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models as _models
from ..._utils.serialization import Deserializer, Serializer
from ...operations._recommendations_operations import (
    build_generate_request,
    build_get_generate_status_request,
    build_get_request,
    build_list_request,
    build_patch_request,
)
from .._configuration import AdvisorManagementClientConfiguration

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class RecommendationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.advisor.aio.AdvisorManagementClient`'s
        :attr:`recommendations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AdvisorManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def generate(self, **kwargs: Any) -> None:
        """Initiates the recommendation generation or computation process for a subscription. This
        operation is asynchronous. The generated recommendations are stored in a cache in the Advisor
        service.

        :return: None or the result of cls(response)
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_generate_request(
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ArmErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_generate_status(self, operation_id: str, **kwargs: Any) -> None:
        """Retrieves the status of the recommendation computation or generation process. Invoke this API
        after calling the generation recommendation. The URI of this API is returned in the Location
        field of the response header.

        :param operation_id: The operation ID, which can be found from the Location field in the
         generate recommendation response header. Required.
        :type operation_id: str
        :return: None or the result of cls(response)
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_generate_status_request(
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ArmErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, filter: Optional[str] = None, top: Optional[int] = None, skip_token: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.ResourceRecommendationBase"]:
        """Obtains cached recommendations for a subscription. The recommendations are generated or
        computed by invoking generateRecommendations.

        :param filter: The filter to apply to the recommendations.\\ :code:`<br>`Filter can be applied
         to properties ['ResourceId', 'ResourceGroup', 'RecommendationTypeGuid', '\\ `Category
         <#category>`_\\ '] with operators ['eq', 'and', 'or'].\\ :code:`<br>`Example:\\ :code:`<br>`-
         $filter=Category eq 'Cost' and ResourceGroup eq 'MyResourceGroup'. Default value is None.
        :type filter: str
        :param top: The number of recommendations per page if a paged version of this API is being
         used. Default value is None.
        :type top: int
        :param skip_token: The page-continuation token to use with a paged version of this API. Default
         value is None.
        :type skip_token: str
        :return: An iterator like instance of either ResourceRecommendationBase or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.advisor.models.ResourceRecommendationBase]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[_models.ResourceRecommendationBaseListResult] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    top=top,
                    skip_token=skip_token,
                    api_version=api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)
                _request.method = "GET"
            return _request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ResourceRecommendationBaseListResult", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ArmErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_uri: str, recommendation_id: str, **kwargs: Any) -> _models.ResourceRecommendationBase:
        """Obtains details of a cached recommendation.

        :param resource_uri: The fully qualified Azure Resource Manager identifier of the resource to
         which the recommendation applies. Required.
        :type resource_uri: str
        :param recommendation_id: The recommendation ID. Required.
        :type recommendation_id: str
        :return: ResourceRecommendationBase or the result of cls(response)
        :rtype: ~azure.mgmt.advisor.models.ResourceRecommendationBase
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        cls: ClsType[_models.ResourceRecommendationBase] = kwargs.pop("cls", None)

        _request = build_get_request(
            resource_uri=resource_uri,
            recommendation_id=recommendation_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ArmErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ResourceRecommendationBase", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def patch(
        self,
        resource_uri: str,
        recommendation_id: str,
        tracked_properties: _models.TrackedRecommendationPropertiesPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ResourceRecommendationBase:
        """Update the tracked properties of a Recommendation.

        :param resource_uri: The fully qualified Azure Resource Manager identifier of the resource to
         which the tracked recommendation applies. Required.
        :type resource_uri: str
        :param recommendation_id: The RecommendationId ID. Required.
        :type recommendation_id: str
        :param tracked_properties: The properties to update on the recommendation. Required.
        :type tracked_properties: ~azure.mgmt.advisor.models.TrackedRecommendationPropertiesPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResourceRecommendationBase or the result of cls(response)
        :rtype: ~azure.mgmt.advisor.models.ResourceRecommendationBase
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def patch(
        self,
        resource_uri: str,
        recommendation_id: str,
        tracked_properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ResourceRecommendationBase:
        """Update the tracked properties of a Recommendation.

        :param resource_uri: The fully qualified Azure Resource Manager identifier of the resource to
         which the tracked recommendation applies. Required.
        :type resource_uri: str
        :param recommendation_id: The RecommendationId ID. Required.
        :type recommendation_id: str
        :param tracked_properties: The properties to update on the recommendation. Required.
        :type tracked_properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResourceRecommendationBase or the result of cls(response)
        :rtype: ~azure.mgmt.advisor.models.ResourceRecommendationBase
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def patch(
        self,
        resource_uri: str,
        recommendation_id: str,
        tracked_properties: Union[_models.TrackedRecommendationPropertiesPayload, IO[bytes]],
        **kwargs: Any
    ) -> _models.ResourceRecommendationBase:
        """Update the tracked properties of a Recommendation.

        :param resource_uri: The fully qualified Azure Resource Manager identifier of the resource to
         which the tracked recommendation applies. Required.
        :type resource_uri: str
        :param recommendation_id: The RecommendationId ID. Required.
        :type recommendation_id: str
        :param tracked_properties: The properties to update on the recommendation. Is either a
         TrackedRecommendationPropertiesPayload type or a IO[bytes] type. Required.
        :type tracked_properties: ~azure.mgmt.advisor.models.TrackedRecommendationPropertiesPayload or
         IO[bytes]
        :return: ResourceRecommendationBase or the result of cls(response)
        :rtype: ~azure.mgmt.advisor.models.ResourceRecommendationBase
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ResourceRecommendationBase] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(tracked_properties, (IOBase, bytes)):
            _content = tracked_properties
        else:
            _json = self._serialize.body(tracked_properties, "TrackedRecommendationPropertiesPayload")

        _request = build_patch_request(
            resource_uri=resource_uri,
            recommendation_id=recommendation_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ArmErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ResourceRecommendationBase", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
