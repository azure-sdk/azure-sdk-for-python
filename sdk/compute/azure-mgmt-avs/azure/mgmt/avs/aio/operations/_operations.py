# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, Type, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_addons_create_or_update_request,
    build_addons_delete_request,
    build_addons_get_request,
    build_addons_list_request,
    build_authorizations_create_or_update_request,
    build_authorizations_delete_request,
    build_authorizations_get_request,
    build_authorizations_list_request,
    build_cloud_links_create_or_update_request,
    build_cloud_links_delete_request,
    build_cloud_links_get_request,
    build_cloud_links_list_request,
    build_clusters_create_or_update_request,
    build_clusters_delete_request,
    build_clusters_get_request,
    build_clusters_list_request,
    build_clusters_list_zones_request,
    build_clusters_update_request,
    build_datastores_create_or_update_request,
    build_datastores_delete_request,
    build_datastores_get_request,
    build_datastores_list_request,
    build_global_reach_connections_create_or_update_request,
    build_global_reach_connections_delete_request,
    build_global_reach_connections_get_request,
    build_global_reach_connections_list_request,
    build_hcx_enterprise_sites_create_or_update_request,
    build_hcx_enterprise_sites_delete_request,
    build_hcx_enterprise_sites_get_request,
    build_hcx_enterprise_sites_list_request,
    build_iscsi_paths_create_or_update_request,
    build_iscsi_paths_delete_request,
    build_iscsi_paths_get_request,
    build_iscsi_paths_list_by_private_cloud_request,
    build_locations_check_quota_availability_request,
    build_locations_check_trial_availability_request,
    build_operations_list_request,
    build_placement_policies_create_or_update_request,
    build_placement_policies_delete_request,
    build_placement_policies_get_request,
    build_placement_policies_list_request,
    build_placement_policies_update_request,
    build_private_clouds_create_or_update_request,
    build_private_clouds_delete_request,
    build_private_clouds_get_request,
    build_private_clouds_list_admin_credentials_request,
    build_private_clouds_list_by_resource_group_request,
    build_private_clouds_list_in_subscription_request,
    build_private_clouds_rotate_nsxt_password_request,
    build_private_clouds_rotate_vcenter_password_request,
    build_private_clouds_update_request,
    build_script_cmdlets_get_request,
    build_script_cmdlets_list_request,
    build_script_executions_create_or_update_request,
    build_script_executions_delete_request,
    build_script_executions_get_execution_logs_request,
    build_script_executions_get_request,
    build_script_executions_list_request,
    build_script_packages_get_request,
    build_script_packages_list_request,
    build_virtual_machines_get_request,
    build_virtual_machines_list_request,
    build_virtual_machines_restrict_movement_request,
    build_workload_network_dhcp_configurations_create_request,
    build_workload_network_dhcp_configurations_delete_request,
    build_workload_network_dhcp_configurations_get_request,
    build_workload_network_dhcp_configurations_list_by_workload_network_request,
    build_workload_network_dhcp_configurations_update_request,
    build_workload_network_dns_services_create_request,
    build_workload_network_dns_services_delete_request,
    build_workload_network_dns_services_get_request,
    build_workload_network_dns_services_list_by_workload_network_request,
    build_workload_network_dns_services_update_request,
    build_workload_network_dns_zones_create_request,
    build_workload_network_dns_zones_delete_request,
    build_workload_network_dns_zones_get_request,
    build_workload_network_dns_zones_list_by_workload_network_request,
    build_workload_network_dns_zones_update_request,
    build_workload_network_gateways_get_request,
    build_workload_network_gateways_list_by_workload_network_request,
    build_workload_network_port_mirroring_profiles_create_request,
    build_workload_network_port_mirroring_profiles_delete_request,
    build_workload_network_port_mirroring_profiles_get_request,
    build_workload_network_port_mirroring_profiles_list_by_workload_network_request,
    build_workload_network_port_mirroring_profiles_update_request,
    build_workload_network_public_ips_create_request,
    build_workload_network_public_ips_delete_request,
    build_workload_network_public_ips_get_request,
    build_workload_network_public_ips_list_by_workload_network_request,
    build_workload_network_segments_create_request,
    build_workload_network_segments_delete_segment_request,
    build_workload_network_segments_get_request,
    build_workload_network_segments_list_by_workload_network_request,
    build_workload_network_segments_update_request,
    build_workload_network_virtual_machines_get_request,
    build_workload_network_virtual_machines_list_by_workload_network_request,
    build_workload_network_vm_groups_create_request,
    build_workload_network_vm_groups_delete_request,
    build_workload_network_vm_groups_get_request,
    build_workload_network_vm_groups_list_by_workload_network_request,
    build_workload_network_vm_groups_update_request,
    build_workload_networks_get_request,
    build_workload_networks_list_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
        # pylint: disable=line-too-long
        """List the operations for the provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Extensible enum. Indicates the action type.
                      "Internal" refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for Azure
                      Resource Manager/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class LocationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`locations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def check_trial_availability(
        self, location: str, sku: Optional[_models.Sku] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Trial:
        # pylint: disable=line-too-long
        """Return trial status for subscription by region.

        :param location: A location in a subscription. Required.
        :type location: str
        :param sku: Optionally, check for a specific SKU. Default value is None.
        :type sku: ~azure.mgmt.avs.models.Sku
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Trial. The Trial is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Trial
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sku = {
                    "name": "str",  # The name of the SKU, usually a combination of letters and
                      numbers, for example, 'P3'. Required.
                    "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                      capacity integer should be included. If scale out/in is not possible for the
                      resource this may be omitted.
                    "family": "str",  # Optional. If the service has different generations of
                      hardware, for the same SKU, then that can be captured here.
                    "size": "str",  # Optional. The SKU size. When the name field is the
                      combination of tier and some other value, this would be the standalone code.
                    "tier": "str"  # Optional. This field is required to be implemented by the
                      Resource Provider if the service has more than one tier, but is not required on a
                      PUT. Known values are: "Free", "Basic", "Standard", and "Premium".
                }

                # response body for status code(s): 200
                response == {
                    "availableHosts": 0,  # Optional. Number of trial hosts available.
                    "status": "str"  # Optional. Trial status. Known values are:
                      "TrialAvailable", "TrialUsed", and "TrialDisabled".
                }
        """

    @overload
    async def check_trial_availability(
        self, location: str, sku: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Trial:
        """Return trial status for subscription by region.

        :param location: A location in a subscription. Required.
        :type location: str
        :param sku: Optionally, check for a specific SKU. Default value is None.
        :type sku: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Trial. The Trial is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Trial
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "availableHosts": 0,  # Optional. Number of trial hosts available.
                    "status": "str"  # Optional. Trial status. Known values are:
                      "TrialAvailable", "TrialUsed", and "TrialDisabled".
                }
        """

    @overload
    async def check_trial_availability(
        self, location: str, sku: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Trial:
        """Return trial status for subscription by region.

        :param location: A location in a subscription. Required.
        :type location: str
        :param sku: Optionally, check for a specific SKU. Default value is None.
        :type sku: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Trial. The Trial is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Trial
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "availableHosts": 0,  # Optional. Number of trial hosts available.
                    "status": "str"  # Optional. Trial status. Known values are:
                      "TrialAvailable", "TrialUsed", and "TrialDisabled".
                }
        """

    @distributed_trace_async
    async def check_trial_availability(
        self, location: str, sku: Optional[Union[_models.Sku, JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.Trial:
        # pylint: disable=line-too-long
        """Return trial status for subscription by region.

        :param location: A location in a subscription. Required.
        :type location: str
        :param sku: Optionally, check for a specific SKU. Is one of the following types: Sku, JSON,
         IO[bytes] Default value is None.
        :type sku: ~azure.mgmt.avs.models.Sku or JSON or IO[bytes]
        :return: Trial. The Trial is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Trial
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sku = {
                    "name": "str",  # The name of the SKU, usually a combination of letters and
                      numbers, for example, 'P3'. Required.
                    "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                      capacity integer should be included. If scale out/in is not possible for the
                      resource this may be omitted.
                    "family": "str",  # Optional. If the service has different generations of
                      hardware, for the same SKU, then that can be captured here.
                    "size": "str",  # Optional. The SKU size. When the name field is the
                      combination of tier and some other value, this would be the standalone code.
                    "tier": "str"  # Optional. This field is required to be implemented by the
                      Resource Provider if the service has more than one tier, but is not required on a
                      PUT. Known values are: "Free", "Basic", "Standard", and "Premium".
                }

                # response body for status code(s): 200
                response == {
                    "availableHosts": 0,  # Optional. Number of trial hosts available.
                    "status": "str"  # Optional. Trial status. Known values are:
                      "TrialAvailable", "TrialUsed", and "TrialDisabled".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Trial] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(sku, (IOBase, bytes)):
            _content = sku
        else:
            if sku is not None:
                _content = json.dumps(sku, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_locations_check_trial_availability_request(
            location=location,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Trial, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def check_quota_availability(self, location: str, **kwargs: Any) -> _models.Quota:
        # pylint: disable=line-too-long
        """Return quota for subscription by region.

        :param location: A location in a subscription. Required.
        :type location: str
        :return: Quota. The Quota is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Quota
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "hostsRemaining": {
                        "str": 0  # Optional. Remaining hosts quota by sku type.
                    },
                    "quotaEnabled": "str"  # Optional. Host quota is active for current
                      subscription. Known values are: "Enabled" and "Disabled".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Quota] = kwargs.pop("cls", None)

        _request = build_locations_check_quota_availability_request(
            location=location,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Quota, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PrivateCloudsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`private_clouds` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.PrivateCloud"]:
        # pylint: disable=line-too-long
        """List PrivateCloud resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of PrivateCloud
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PrivateCloud]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_private_clouds_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PrivateCloud], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_in_subscription(self, **kwargs: Any) -> AsyncIterable["_models.PrivateCloud"]:
        # pylint: disable=line-too-long
        """List PrivateCloud resources by subscription ID.

        :return: An iterator like instance of PrivateCloud
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PrivateCloud]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_private_clouds_list_in_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PrivateCloud], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, private_cloud_name: str, **kwargs: Any) -> _models.PrivateCloud:
        # pylint: disable=line-too-long
        """Get a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: PrivateCloud. The PrivateCloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PrivateCloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrivateCloud] = kwargs.pop("cls", None)

        _request = build_private_clouds_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PrivateCloud, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud: Union[_models.PrivateCloud, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_cloud, (IOBase, bytes)):
            _content = private_cloud
        else:
            _content = json.dumps(private_cloud, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_private_clouds_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud: _models.PrivateCloud,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PrivateCloud]:
        # pylint: disable=line-too-long
        """Create a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud: Resource create parameters. Required.
        :type private_cloud: ~azure.mgmt.avs.models.PrivateCloud
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PrivateCloud. The PrivateCloud is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                private_cloud = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PrivateCloud]:
        # pylint: disable=line-too-long
        """Create a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud: Resource create parameters. Required.
        :type private_cloud: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PrivateCloud. The PrivateCloud is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PrivateCloud]:
        # pylint: disable=line-too-long
        """Create a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud: Resource create parameters. Required.
        :type private_cloud: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PrivateCloud. The PrivateCloud is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud: Union[_models.PrivateCloud, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PrivateCloud]:
        # pylint: disable=line-too-long
        """Create a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud: Resource create parameters. Is one of the following types: PrivateCloud,
         JSON, IO[bytes] Required.
        :type private_cloud: ~azure.mgmt.avs.models.PrivateCloud or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns PrivateCloud. The PrivateCloud is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PrivateCloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                private_cloud = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PrivateCloud] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                private_cloud=private_cloud,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.PrivateCloud, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.PrivateCloud].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.PrivateCloud](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud_update: _models.PrivateCloudUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateCloud:
        # pylint: disable=line-too-long
        """Update a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud_update: The private cloud properties to be updated. Required.
        :type private_cloud_update: ~azure.mgmt.avs.models.PrivateCloudUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateCloud. The PrivateCloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PrivateCloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                private_cloud_update = {
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "properties": {
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        }
                    },
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud_update: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateCloud:
        # pylint: disable=line-too-long
        """Update a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud_update: The private cloud properties to be updated. Required.
        :type private_cloud_update: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateCloud. The PrivateCloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PrivateCloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud_update: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PrivateCloud:
        # pylint: disable=line-too-long
        """Update a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud_update: The private cloud properties to be updated. Required.
        :type private_cloud_update: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PrivateCloud. The PrivateCloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PrivateCloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        private_cloud_update: Union[_models.PrivateCloudUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PrivateCloud:
        # pylint: disable=line-too-long
        """Update a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param private_cloud_update: The private cloud properties to be updated. Is one of the
         following types: PrivateCloudUpdate, JSON, IO[bytes] Required.
        :type private_cloud_update: ~azure.mgmt.avs.models.PrivateCloudUpdate or JSON or IO[bytes]
        :return: PrivateCloud. The PrivateCloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PrivateCloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                private_cloud_update = {
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "properties": {
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        }
                    },
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The type of managed identity assigned to this
                          resource. Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The active directory identifier of
                          this principal.
                        "tenantId": "str"  # Optional. The Active Directory tenant id of the
                          principal.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "managementCluster": {
                            "clusterId": 0,  # Optional. The identity.
                            "clusterSize": 0,  # Optional. The cluster size.
                            "hosts": [
                                "str"  # Optional. The hosts.
                            ],
                            "provisioningState": "str",  # Optional. The state of the
                              cluster provisioning. Known values are: "Succeeded", "Failed",
                              "Canceled", "Cancelled", "Deleting", and "Updating".
                            "vsanDatastoreName": "str"  # Optional. Name of the vsan
                              datastore associated with the cluster.
                        },
                        "networkBlock": "str",  # The block of addresses should be unique
                          across VNet in your subscription as well as on-premise. Make sure the CIDR
                          format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X
                          is between 0 and 22. Required.
                        "availability": {
                            "secondaryZone": 0,  # Optional. The secondary availability
                              zone for the private cloud.
                            "strategy": "str",  # Optional. The availability strategy for
                              the private cloud. Known values are: "SingleZone" and "DualZone".
                            "zone": 0  # Optional. The primary availability zone for the
                              private cloud.
                        },
                        "circuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "dnsZoneType": "str",  # Optional. The type of DNS zone to use. Known
                          values are: "Public" and "Private".
                        "encryption": {
                            "keyVaultProperties": {
                                "autoDetectedKeyVersion": "str",  # Optional. The
                                  auto-detected version of the key if versionType is auto-detected.
                                "keyName": "str",  # Optional. The name of the key.
                                "keyState": "str",  # Optional. The state of key
                                  provided. Known values are: "Connected" and "AccessDenied".
                                "keyVaultUrl": "str",  # Optional. The URL of the
                                  vault.
                                "keyVersion": "str",  # Optional. The version of the
                                  key.
                                "versionType": "str"  # Optional. Property of the key
                                  if user provided or auto detected. Known values are: "Fixed" and
                                  "AutoDetected".
                            },
                            "status": "str"  # Optional. Status of customer managed
                              encryption key. Known values are: "Enabled" and "Disabled".
                        },
                        "endpoints": {
                            "hcxCloudManager": "str",  # Optional. Endpoint FQDN for the
                              HCX Cloud Manager.
                            "hcxCloudManagerIp": "str",  # Optional. Endpoint IP for the
                              HCX Cloud Manager.
                            "nsxtManager": "str",  # Optional. Endpoint FQDN for the
                              NSX-T Data Center manager.
                            "nsxtManagerIp": "str",  # Optional. Endpoint IP for the
                              NSX-T Data Center manager.
                            "vcenterIp": "str",  # Optional. Endpoint IP for Virtual
                              Center Server Appliance.
                            "vcsa": "str"  # Optional. Endpoint FQDN for Virtual Center
                              Server Appliance.
                        },
                        "extendedNetworkBlocks": [
                            "str"  # Optional. Array of additional networks noncontiguous
                              with networkBlock. Networks must be unique and non-overlapping across
                              VNet in your subscription, on-premise, and this privateCloud networkBlock
                              attribute. Make sure the CIDR format conforms to (A.B.C.D/X).
                        ],
                        "externalCloudLinks": [
                            "str"  # Optional. Array of cloud link IDs from other clouds
                              that connect to this one.
                        ],
                        "identitySources": [
                            {
                                "alias": "str",  # Optional. The domain's NetBIOS
                                  name.
                                "baseGroupDN": "str",  # Optional. The base
                                  distinguished name for groups.
                                "baseUserDN": "str",  # Optional. The base
                                  distinguished name for users.
                                "domain": "str",  # Optional. The domain's dns name.
                                "name": "str",  # Optional. The name of the identity
                                  source.
                                "password": "str",  # Optional. The password of the
                                  Active Directory user with a minimum of read-only access to Base DN
                                  for users and groups.
                                "primaryServer": "str",  # Optional. Primary server
                                  URL.
                                "secondaryServer": "str",  # Optional. Secondary
                                  server URL.
                                "ssl": "str",  # Optional. Protect LDAP communication
                                  using SSL certificate (LDAPS). Known values are: "Enabled" and
                                  "Disabled".
                                "username": "str"  # Optional. The ID of an Active
                                  Directory user with a minimum of read-only access to Base DN for
                                  users and group.
                            }
                        ],
                        "internet": "str",  # Optional. Connectivity to internet is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "managementNetwork": "str",  # Optional. Network used to access
                          vCenter Server and NSX-T Manager.
                        "nsxPublicIpQuotaRaised": "str",  # Optional. Flag to indicate
                          whether the private cloud has the quota for provisioned NSX Public IP count
                          raised from 64 to 1024. Known values are: "Enabled" and "Disabled".
                        "nsxtCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          NSX-T Manager SSL certificate.
                        "nsxtPassword": "str",  # Optional. Optionally, set the NSX-T Manager
                          password when the private cloud is created.
                        "provisioningNetwork": "str",  # Optional. Used for virtual machine
                          cold migration, cloning, and snapshot migration.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Pending",
                          "Building", "Deleting", and "Updating".
                        "secondaryCircuit": {
                            "expressRouteID": "str",  # Optional. Identifier of the
                              ExpressRoute Circuit (Microsoft Colo only).
                            "expressRoutePrivatePeeringID": "str",  # Optional.
                              ExpressRoute Circuit private peering identifier.
                            "primarySubnet": "str",  # Optional. CIDR of primary subnet.
                            "secondarySubnet": "str"  # Optional. CIDR of secondary
                              subnet.
                        },
                        "vcenterCertificateThumbprint": "str",  # Optional. Thumbprint of the
                          vCenter Server SSL certificate.
                        "vcenterPassword": "str",  # Optional. Optionally, set the vCenter
                          admin password when the private cloud is created.
                        "virtualNetworkId": "str",  # Optional. Azure resource ID of the
                          virtual network.
                        "vmotionNetwork": "str"  # Optional. Used for live migration of
                          virtual machines.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PrivateCloud] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(private_cloud_update, (IOBase, bytes)):
            _content = private_cloud_update
        else:
            _content = json.dumps(private_cloud_update, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_private_clouds_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PrivateCloud, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PrivateCloud, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_private_clouds_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _rotate_vcenter_password_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_private_clouds_rotate_vcenter_password_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_rotate_vcenter_password(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Rotate the vCenter password.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._rotate_vcenter_password_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    async def _rotate_nsxt_password_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_private_clouds_rotate_nsxt_password_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_rotate_nsxt_password(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Rotate the NSX-T Manager password.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._rotate_nsxt_password_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def list_admin_credentials(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> _models.AdminCredentials:
        """List the admin credentials for the private cloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: AdminCredentials. The AdminCredentials is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.AdminCredentials
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "nsxtPassword": "str",  # Optional. NSX-T Manager password.
                    "nsxtUsername": "str",  # Optional. NSX-T Manager username.
                    "vcenterPassword": "str",  # Optional. vCenter admin password.
                    "vcenterUsername": "str"  # Optional. vCenter admin username.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AdminCredentials] = kwargs.pop("cls", None)

        _request = build_private_clouds_list_admin_credentials_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AdminCredentials, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ClustersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`clusters` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.Cluster"]:
        # pylint: disable=line-too-long
        """List Cluster resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of Cluster
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.Cluster]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Cluster]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_clusters_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Cluster], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> _models.Cluster:
        # pylint: disable=line-too-long
        """Get a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: Cluster. The Cluster is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Cluster
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)

        _request = build_clusters_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Cluster, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster: Union[_models.Cluster, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(cluster, (IOBase, bytes)):
            _content = cluster
        else:
            _content = json.dumps(cluster, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_clusters_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster: _models.Cluster,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Cluster]:
        # pylint: disable=line-too-long
        """Create a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster: Resource create parameters. Required.
        :type cluster: ~azure.mgmt.avs.models.Cluster
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Cluster. The Cluster is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Cluster]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster = {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Cluster]:
        # pylint: disable=line-too-long
        """Create a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster: Resource create parameters. Required.
        :type cluster: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Cluster. The Cluster is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Cluster]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Cluster]:
        # pylint: disable=line-too-long
        """Create a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster: Resource create parameters. Required.
        :type cluster: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Cluster. The Cluster is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Cluster]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster: Union[_models.Cluster, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Cluster]:
        # pylint: disable=line-too-long
        """Create a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster: Resource create parameters. Is one of the following types: Cluster, JSON,
         IO[bytes] Required.
        :type cluster: ~azure.mgmt.avs.models.Cluster or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Cluster. The Cluster is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Cluster]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster = {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                cluster=cluster,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Cluster, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Cluster].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Cluster](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster_update: _models.ClusterUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Cluster:
        # pylint: disable=line-too-long
        """Update a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster_update: The cluster properties to be updated. Required.
        :type cluster_update: ~azure.mgmt.avs.models.ClusterUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Cluster. The Cluster is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Cluster
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_update = {
                    "properties": {
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ]
                    },
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster_update: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Cluster:
        # pylint: disable=line-too-long
        """Update a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster_update: The cluster properties to be updated. Required.
        :type cluster_update: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Cluster. The Cluster is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Cluster
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster_update: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Cluster:
        # pylint: disable=line-too-long
        """Update a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster_update: The cluster properties to be updated. Required.
        :type cluster_update: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Cluster. The Cluster is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Cluster
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        cluster_update: Union[_models.ClusterUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Cluster:
        # pylint: disable=line-too-long
        """Update a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param cluster_update: The cluster properties to be updated. Is one of the following types:
         ClusterUpdate, JSON, IO[bytes] Required.
        :type cluster_update: ~azure.mgmt.avs.models.ClusterUpdate or JSON or IO[bytes]
        :return: Cluster. The Cluster is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Cluster
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_update = {
                    "properties": {
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ]
                    },
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "sku": {
                        "name": "str",  # The name of the SKU, usually a combination of
                          letters and numbers, for example, 'P3'. Required.
                        "capacity": 0,  # Optional. If the SKU supports scale out/in then the
                          capacity integer should be included. If scale out/in is not possible for the
                          resource this may be omitted.
                        "family": "str",  # Optional. If the service has different
                          generations of hardware, for the same SKU, then that can be captured here.
                        "size": "str",  # Optional. The SKU size. When the name field is the
                          combination of tier and some other value, this would be the standalone code.
                        "tier": "str"  # Optional. This field is required to be implemented
                          by the Resource Provider if the service has more than one tier, but is not
                          required on a PUT. Known values are: "Free", "Basic", "Standard", and
                          "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterId": 0,  # Optional. The identity.
                        "clusterSize": 0,  # Optional. The cluster size.
                        "hosts": [
                            "str"  # Optional. The hosts.
                        ],
                        "provisioningState": "str",  # Optional. The state of the cluster
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Deleting", and "Updating".
                        "vsanDatastoreName": "str"  # Optional. Name of the vsan datastore
                          associated with the cluster.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(cluster_update, (IOBase, bytes)):
            _content = cluster_update
        else:
            _content = json.dumps(cluster_update, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_clusters_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Cluster, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Cluster, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_clusters_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace_async
    async def list_zones(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> _models.ClusterZoneList:
        """List hosts by zone in a cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: ClusterZoneList. The ClusterZoneList is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ClusterZoneList
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "zones": [
                        {
                            "hosts": [
                                "str"  # Optional. List of hosts belonging to the
                                  availability zone in a cluster.
                            ],
                            "zone": "str"  # Optional. Availability zone identifier.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ClusterZoneList] = kwargs.pop("cls", None)

        _request = build_clusters_list_zones_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ClusterZoneList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DatastoresOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`datastores` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.Datastore"]:
        # pylint: disable=line-too-long
        """List Datastore resources by Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: An iterator like instance of Datastore
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.Datastore]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Datastore]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_datastores_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    cluster_name=cluster_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Datastore], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, datastore_name: str, **kwargs: Any
    ) -> _models.Datastore:
        # pylint: disable=line-too-long
        """Get a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :return: Datastore. The Datastore is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Datastore
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Datastore] = kwargs.pop("cls", None)

        _request = build_datastores_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Datastore, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        datastore_name: str,
        datastore: Union[_models.Datastore, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(datastore, (IOBase, bytes)):
            _content = datastore
        else:
            _content = json.dumps(datastore, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_datastores_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        datastore_name: str,
        datastore: _models.Datastore,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Datastore]:
        # pylint: disable=line-too-long
        """Create a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param datastore: Resource create parameters. Required.
        :type datastore: ~azure.mgmt.avs.models.Datastore
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Datastore. The Datastore is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Datastore]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                datastore = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        datastore_name: str,
        datastore: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Datastore]:
        # pylint: disable=line-too-long
        """Create a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param datastore: Resource create parameters. Required.
        :type datastore: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Datastore. The Datastore is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Datastore]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        datastore_name: str,
        datastore: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Datastore]:
        # pylint: disable=line-too-long
        """Create a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param datastore: Resource create parameters. Required.
        :type datastore: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Datastore. The Datastore is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Datastore]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        datastore_name: str,
        datastore: Union[_models.Datastore, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Datastore]:
        # pylint: disable=line-too-long
        """Create a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param datastore: Resource create parameters. Is one of the following types: Datastore, JSON,
         IO[bytes] Required.
        :type datastore: ~azure.mgmt.avs.models.Datastore or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Datastore. The Datastore is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Datastore]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                datastore = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diskPoolVolume": {
                            "lunName": "str",  # Name of the LUN to be used for
                              datastore. Required.
                            "targetId": "str",  # Azure resource ID of the iSCSI target.
                              Required.
                            "mountOption": "str",  # Optional. Mode that describes
                              whether the LUN has to be mounted as a datastore or attached as a LUN.
                              Known values are: "MOUNT" and "ATTACH".
                            "path": "str"  # Optional. Device path.
                        },
                        "elasticSanVolume": {
                            "targetId": "str"  # Azure resource ID of the Elastic SAN
                              Volume. Required.
                        },
                        "netAppVolume": {
                            "id": "str"  # Azure resource ID of the NetApp volume.
                              Required.
                        },
                        "provisioningState": "str",  # Optional. The state of the datastore
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled",
                          "Cancelled", "Pending", "Creating", "Updating", and "Deleting".
                        "status": "str"  # Optional. The operational status of the datastore.
                          Known values are: "Unknown", "Accessible", "Inaccessible", "Attached",
                          "Detached", "LostCommunication", and "DeadOrError".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Datastore] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                datastore_name=datastore_name,
                datastore=datastore,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Datastore, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Datastore].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Datastore](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, datastore_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datastores_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, datastore_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a Datastore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                datastore_name=datastore_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class HcxEnterpriseSitesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`hcx_enterprise_sites` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.HcxEnterpriseSite"]:
        # pylint: disable=line-too-long
        """List HcxEnterpriseSite resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of HcxEnterpriseSite
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.HcxEnterpriseSite]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.HcxEnterpriseSite]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_hcx_enterprise_sites_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.HcxEnterpriseSite], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, hcx_enterprise_site_name: str, **kwargs: Any
    ) -> _models.HcxEnterpriseSite:
        # pylint: disable=line-too-long
        """Get a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :return: HcxEnterpriseSite. The HcxEnterpriseSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.HcxEnterpriseSite] = kwargs.pop("cls", None)

        _request = build_hcx_enterprise_sites_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            hcx_enterprise_site_name=hcx_enterprise_site_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.HcxEnterpriseSite, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        hcx_enterprise_site_name: str,
        hcx_enterprise_site: _models.HcxEnterpriseSite,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HcxEnterpriseSite:
        # pylint: disable=line-too-long
        """Create a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :param hcx_enterprise_site: Resource create parameters. Required.
        :type hcx_enterprise_site: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HcxEnterpriseSite. The HcxEnterpriseSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                hcx_enterprise_site = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        hcx_enterprise_site_name: str,
        hcx_enterprise_site: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HcxEnterpriseSite:
        # pylint: disable=line-too-long
        """Create a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :param hcx_enterprise_site: Resource create parameters. Required.
        :type hcx_enterprise_site: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HcxEnterpriseSite. The HcxEnterpriseSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        hcx_enterprise_site_name: str,
        hcx_enterprise_site: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.HcxEnterpriseSite:
        # pylint: disable=line-too-long
        """Create a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :param hcx_enterprise_site: Resource create parameters. Required.
        :type hcx_enterprise_site: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: HcxEnterpriseSite. The HcxEnterpriseSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        hcx_enterprise_site_name: str,
        hcx_enterprise_site: Union[_models.HcxEnterpriseSite, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.HcxEnterpriseSite:
        # pylint: disable=line-too-long
        """Create a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :param hcx_enterprise_site: Resource create parameters. Is one of the following types:
         HcxEnterpriseSite, JSON, IO[bytes] Required.
        :type hcx_enterprise_site: ~azure.mgmt.avs.models.HcxEnterpriseSite or JSON or IO[bytes]
        :return: HcxEnterpriseSite. The HcxEnterpriseSite is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.HcxEnterpriseSite
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                hcx_enterprise_site = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "activationKey": "str",  # Optional. The activation key.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The status of the HCX Enterprise Site.
                          Known values are: "Available", "Consumed", "Deactivated", and "Deleted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.HcxEnterpriseSite] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(hcx_enterprise_site, (IOBase, bytes)):
            _content = hcx_enterprise_site
        else:
            _content = json.dumps(hcx_enterprise_site, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_hcx_enterprise_sites_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            hcx_enterprise_site_name=hcx_enterprise_site_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.HcxEnterpriseSite, response.json())

        if response.status_code == 201:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.HcxEnterpriseSite, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, hcx_enterprise_site_name: str, **kwargs: Any
    ) -> None:
        """Delete a HcxEnterpriseSite.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param hcx_enterprise_site_name: Name of the HCX Enterprise Site. Required.
        :type hcx_enterprise_site_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_hcx_enterprise_sites_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            hcx_enterprise_site_name=hcx_enterprise_site_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class AuthorizationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`authorizations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.ExpressRouteAuthorization"]:
        # pylint: disable=line-too-long
        """List ExpressRouteAuthorization resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of ExpressRouteAuthorization
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.ExpressRouteAuthorization]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExpressRouteAuthorization]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_authorizations_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExpressRouteAuthorization], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, authorization_name: str, **kwargs: Any
    ) -> _models.ExpressRouteAuthorization:
        # pylint: disable=line-too-long
        """Get a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :return: ExpressRouteAuthorization. The ExpressRouteAuthorization is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.avs.models.ExpressRouteAuthorization
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExpressRouteAuthorization] = kwargs.pop("cls", None)

        _request = build_authorizations_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExpressRouteAuthorization, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        authorization_name: str,
        authorization: Union[_models.ExpressRouteAuthorization, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(authorization, (IOBase, bytes)):
            _content = authorization
        else:
            _content = json.dumps(authorization, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_authorizations_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        authorization_name: str,
        authorization: _models.ExpressRouteAuthorization,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ExpressRouteAuthorization]:
        # pylint: disable=line-too-long
        """Create a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :param authorization: Resource create parameters. Required.
        :type authorization: ~azure.mgmt.avs.models.ExpressRouteAuthorization
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ExpressRouteAuthorization. The
         ExpressRouteAuthorization is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ExpressRouteAuthorization]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                authorization = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        authorization_name: str,
        authorization: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ExpressRouteAuthorization]:
        # pylint: disable=line-too-long
        """Create a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :param authorization: Resource create parameters. Required.
        :type authorization: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ExpressRouteAuthorization. The
         ExpressRouteAuthorization is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ExpressRouteAuthorization]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        authorization_name: str,
        authorization: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ExpressRouteAuthorization]:
        # pylint: disable=line-too-long
        """Create a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :param authorization: Resource create parameters. Required.
        :type authorization: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ExpressRouteAuthorization. The
         ExpressRouteAuthorization is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ExpressRouteAuthorization]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        authorization_name: str,
        authorization: Union[_models.ExpressRouteAuthorization, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ExpressRouteAuthorization]:
        # pylint: disable=line-too-long
        """Create a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :param authorization: Resource create parameters. Is one of the following types:
         ExpressRouteAuthorization, JSON, IO[bytes] Required.
        :type authorization: ~azure.mgmt.avs.models.ExpressRouteAuthorization or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns ExpressRouteAuthorization. The
         ExpressRouteAuthorization is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ExpressRouteAuthorization]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                authorization = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "expressRouteAuthorizationId": "str",  # Optional. The ID of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteAuthorizationKey": "str",  # Optional. The key of the
                          ExpressRoute Circuit Authorization.
                        "expressRouteId": "str",  # Optional. The ID of the ExpressRoute
                          Circuit.
                        "provisioningState": "str"  # Optional. The state of the ExpressRoute
                          Circuit Authorization provisioning. Known values are: "Succeeded", "Failed",
                          "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExpressRouteAuthorization] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                authorization_name=authorization_name,
                authorization=authorization,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.ExpressRouteAuthorization, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ExpressRouteAuthorization].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ExpressRouteAuthorization](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, authorization_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_authorizations_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, authorization_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a ExpressRouteAuthorization.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param authorization_name: Name of the ExpressRoute Circuit Authorization. Required.
        :type authorization_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                authorization_name=authorization_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class GlobalReachConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`global_reach_connections` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.GlobalReachConnection"]:
        # pylint: disable=line-too-long
        """List GlobalReachConnection resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of GlobalReachConnection
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.GlobalReachConnection]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.GlobalReachConnection]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_global_reach_connections_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.GlobalReachConnection], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, global_reach_connection_name: str, **kwargs: Any
    ) -> _models.GlobalReachConnection:
        # pylint: disable=line-too-long
        """Get a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :return: GlobalReachConnection. The GlobalReachConnection is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.GlobalReachConnection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GlobalReachConnection] = kwargs.pop("cls", None)

        _request = build_global_reach_connections_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            global_reach_connection_name=global_reach_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GlobalReachConnection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        global_reach_connection_name: str,
        global_reach_connection: Union[_models.GlobalReachConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(global_reach_connection, (IOBase, bytes)):
            _content = global_reach_connection
        else:
            _content = json.dumps(global_reach_connection, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_global_reach_connections_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            global_reach_connection_name=global_reach_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        global_reach_connection_name: str,
        global_reach_connection: _models.GlobalReachConnection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.GlobalReachConnection]:
        # pylint: disable=line-too-long
        """Create a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :param global_reach_connection: Resource create parameters. Required.
        :type global_reach_connection: ~azure.mgmt.avs.models.GlobalReachConnection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns GlobalReachConnection. The
         GlobalReachConnection is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.GlobalReachConnection]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                global_reach_connection = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        global_reach_connection_name: str,
        global_reach_connection: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.GlobalReachConnection]:
        # pylint: disable=line-too-long
        """Create a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :param global_reach_connection: Resource create parameters. Required.
        :type global_reach_connection: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns GlobalReachConnection. The
         GlobalReachConnection is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.GlobalReachConnection]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        global_reach_connection_name: str,
        global_reach_connection: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.GlobalReachConnection]:
        # pylint: disable=line-too-long
        """Create a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :param global_reach_connection: Resource create parameters. Required.
        :type global_reach_connection: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns GlobalReachConnection. The
         GlobalReachConnection is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.GlobalReachConnection]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        global_reach_connection_name: str,
        global_reach_connection: Union[_models.GlobalReachConnection, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.GlobalReachConnection]:
        # pylint: disable=line-too-long
        """Create a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :param global_reach_connection: Resource create parameters. Is one of the following types:
         GlobalReachConnection, JSON, IO[bytes] Required.
        :type global_reach_connection: ~azure.mgmt.avs.models.GlobalReachConnection or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns GlobalReachConnection. The
         GlobalReachConnection is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.GlobalReachConnection]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                global_reach_connection = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "addressPrefix": "str",  # Optional. The network used for global
                          reach carved out from the original network block provided for the private
                          cloud.
                        "authorizationKey": "str",  # Optional. Authorization key from the
                          peer express route used for the global reach connection.
                        "circuitConnectionStatus": "str",  # Optional. The connection status
                          of the global reach connection. Known values are: "Connected", "Connecting",
                          and "Disconnected".
                        "expressRouteId": "str",  # Optional. The ID of the Private Cloud's
                          ExpressRoute Circuit that is participating in the global reach connection.
                        "peerExpressRouteCircuit": "str",  # Optional. Identifier of the
                          ExpressRoute Circuit to peer with in the global reach connection.
                        "provisioningState": "str"  # Optional. The state of the
                          ExpressRoute Circuit Authorization provisioning. Known values are:
                          "Succeeded", "Failed", "Canceled", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GlobalReachConnection] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                global_reach_connection_name=global_reach_connection_name,
                global_reach_connection=global_reach_connection,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.GlobalReachConnection, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.GlobalReachConnection].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.GlobalReachConnection](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, global_reach_connection_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_global_reach_connections_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            global_reach_connection_name=global_reach_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, global_reach_connection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a GlobalReachConnection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param global_reach_connection_name: Name of the global reach connection. Required.
        :type global_reach_connection_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                global_reach_connection_name=global_reach_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_networks` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_group_name: str, private_cloud_name: str, **kwargs: Any) -> _models.WorkloadNetwork:
        # pylint: disable=line-too-long
        """Get a WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: WorkloadNetwork. The WorkloadNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetwork
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Building",
                          "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetwork] = kwargs.pop("cls", None)

        _request = build_workload_networks_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetwork"]:
        # pylint: disable=line-too-long
        """List WorkloadNetwork resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetwork
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Building",
                          "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetwork]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_networks_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetwork], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class WorkloadNetworkSegmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_segments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkSegment"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkSegment resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkSegment
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkSegment]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_segments_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkSegment], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, segment_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkSegment:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :return: WorkloadNetworkSegment. The WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkSegment
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkSegment] = kwargs.pop("cls", None)

        _request = build_workload_network_segments_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            segment_id=segment_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkSegment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        workload_network_segment: Union[_models.WorkloadNetworkSegment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_segment, (IOBase, bytes)):
            _content = workload_network_segment
        else:
            _content = json.dumps(workload_network_segment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_segments_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            segment_id=segment_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        workload_network_segment: _models.WorkloadNetworkSegment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param workload_network_segment: Resource create parameters. Required.
        :type workload_network_segment: ~azure.mgmt.avs.models.WorkloadNetworkSegment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_segment = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        workload_network_segment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param workload_network_segment: Resource create parameters. Required.
        :type workload_network_segment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        workload_network_segment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param workload_network_segment: Resource create parameters. Required.
        :type workload_network_segment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        workload_network_segment: Union[_models.WorkloadNetworkSegment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param workload_network_segment: Resource create parameters. Is one of the following types:
         WorkloadNetworkSegment, JSON, IO[bytes] Required.
        :type workload_network_segment: ~azure.mgmt.avs.models.WorkloadNetworkSegment or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_segment = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkSegment] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                segment_id=segment_id,
                workload_network_segment=workload_network_segment,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkSegment, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkSegment].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkSegment](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        properties: Union[_models.WorkloadNetworkSegmentUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_segments_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            segment_id=segment_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        properties: _models.WorkloadNetworkSegmentUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.avs.models.WorkloadNetworkSegmentUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        segment_id: str,
        properties: Union[_models.WorkloadNetworkSegmentUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkSegment]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :param properties: The resource properties to be updated. Is one of the following types:
         WorkloadNetworkSegmentUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.avs.models.WorkloadNetworkSegmentUpdate or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkSegment. The
         WorkloadNetworkSegment is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkSegment]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "connectedGateway": "str",  # Optional. Gateway which to connect
                          segment to.
                        "displayName": "str",  # Optional. Display name of the segment.
                        "portVif": [
                            {
                                "portName": "str"  # Optional. Name of port or VIF
                                  attached to segment.
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str",  # Optional. Segment status. Known values are:
                          "SUCCESS" and "FAILURE".
                        "subnet": {
                            "dhcpRanges": [
                                "str"  # Optional. DHCP Range assigned for subnet.
                            ],
                            "gatewayAddress": "str"  # Optional. Gateway address.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkSegment] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                segment_id=segment_id,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkSegment, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkSegment].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkSegment](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_segment_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, segment_id: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_segments_delete_segment_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            segment_id=segment_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete_segment(
        self, resource_group_name: str, private_cloud_name: str, segment_id: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkSegment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param segment_id: The ID of the NSX Segment. Required.
        :type segment_id: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_segment_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                segment_id=segment_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkDhcpConfigurationsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_dhcp_configurations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkDhcp"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkDhcp resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkDhcp
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkDhcp]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_dhcp_configurations_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkDhcp], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, dhcp_id: str, private_cloud_name: str, **kwargs: Any
    ) -> _models.WorkloadNetworkDhcp:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: WorkloadNetworkDhcp. The WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkDhcp
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkDhcp] = kwargs.pop("cls", None)

        _request = build_workload_network_dhcp_configurations_get_request(
            resource_group_name=resource_group_name,
            dhcp_id=dhcp_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkDhcp, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: Union[_models.WorkloadNetworkDhcp, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dhcp, (IOBase, bytes)):
            _content = workload_network_dhcp
        else:
            _content = json.dumps(workload_network_dhcp, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dhcp_configurations_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dhcp_id=dhcp_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: _models.WorkloadNetworkDhcp,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: Resource create parameters. Required.
        :type workload_network_dhcp: ~azure.mgmt.avs.models.WorkloadNetworkDhcp
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # JSON input template you can fill out and use as your body input.
                workload_network_dhcp = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: Resource create parameters. Required.
        :type workload_network_dhcp: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: Resource create parameters. Required.
        :type workload_network_dhcp: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: Union[_models.WorkloadNetworkDhcp, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: Resource create parameters. Is one of the following types:
         WorkloadNetworkDhcp, JSON, IO[bytes] Required.
        :type workload_network_dhcp: ~azure.mgmt.avs.models.WorkloadNetworkDhcp or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # JSON input template you can fill out and use as your body input.
                workload_network_dhcp = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDhcp] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dhcp_id=dhcp_id,
                workload_network_dhcp=workload_network_dhcp,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDhcp, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDhcp].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDhcp](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: Union[_models.WorkloadNetworkDhcpUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dhcp, (IOBase, bytes)):
            _content = workload_network_dhcp
        else:
            _content = json.dumps(workload_network_dhcp, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dhcp_configurations_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dhcp_id=dhcp_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: _models.WorkloadNetworkDhcpUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: The resource properties to be updated. Required.
        :type workload_network_dhcp: ~azure.mgmt.avs.models.WorkloadNetworkDhcpUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # JSON input template you can fill out and use as your body input.
                workload_network_dhcp = {
                    "properties": workload_network_dhcp_entity
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: The resource properties to be updated. Required.
        :type workload_network_dhcp: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: The resource properties to be updated. Required.
        :type workload_network_dhcp: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dhcp_id: str,
        workload_network_dhcp: Union[_models.WorkloadNetworkDhcpUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDhcp]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :param workload_network_dhcp: The resource properties to be updated. Is one of the following
         types: WorkloadNetworkDhcpUpdate, JSON, IO[bytes] Required.
        :type workload_network_dhcp: ~azure.mgmt.avs.models.WorkloadNetworkDhcpUpdate or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDhcp. The
         WorkloadNetworkDhcp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDhcp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # JSON input template you can fill out and use as your body input.
                workload_network_dhcp = {
                    "properties": workload_network_dhcp_entity
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dhcpType":

                # JSON input template for discriminator value "RELAY":
                workload_network_dhcp_entity = {
                    "dhcpType": "RELAY",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddresses": [
                        "str"  # Optional. DHCP Relay Addresses. Max 3.
                    ]
                }

                # JSON input template for discriminator value "SERVER":
                workload_network_dhcp_entity = {
                    "dhcpType": "SERVER",
                    "displayName": "str",  # Optional. Display name of the DHCP entity.
                    "leaseTime": 0,  # Optional. DHCP Server Lease Time.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "revision": 0,  # Optional. NSX revision number.
                    "segments": [
                        "str"  # Optional. NSX Segments consuming DHCP.
                    ],
                    "serverAddress": "str"  # Optional. DHCP Server Address.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": workload_network_dhcp_entity,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDhcp] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dhcp_id=dhcp_id,
                workload_network_dhcp=workload_network_dhcp,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDhcp, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDhcp].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDhcp](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, dhcp_id: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_dhcp_configurations_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dhcp_id=dhcp_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, dhcp_id: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkDhcp.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dhcp_id: The ID of the DHCP configuration. Required.
        :type dhcp_id: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dhcp_id=dhcp_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkGatewaysOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_gateways` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkGateway"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkGateway resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkGateway
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkGateway]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DHCP entity.
                        "path": "str",  # Optional. NSX Gateway Path.
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Building",
                          "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkGateway]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_gateways_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkGateway], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, gateway_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkGateway:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkGateway.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param gateway_id: The ID of the NSX Gateway. Required.
        :type gateway_id: str
        :return: WorkloadNetworkGateway. The WorkloadNetworkGateway is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkGateway
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DHCP entity.
                        "path": "str",  # Optional. NSX Gateway Path.
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Building",
                          "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkGateway] = kwargs.pop("cls", None)

        _request = build_workload_network_gateways_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            gateway_id=gateway_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkGateway, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkloadNetworkPortMirroringProfilesOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_port_mirroring_profiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkPortMirroring"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkPortMirroring resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkPortMirroring
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkPortMirroring]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_port_mirroring_profiles_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkPortMirroring], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, port_mirroring_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkPortMirroring:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :return: WorkloadNetworkPortMirroring. The WorkloadNetworkPortMirroring is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkPortMirroring
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkPortMirroring] = kwargs.pop("cls", None)

        _request = build_workload_network_port_mirroring_profiles_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            port_mirroring_id=port_mirroring_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkPortMirroring, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: Union[_models.WorkloadNetworkPortMirroring, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_port_mirroring, (IOBase, bytes)):
            _content = workload_network_port_mirroring
        else:
            _content = json.dumps(workload_network_port_mirroring, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_port_mirroring_profiles_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            port_mirroring_id=port_mirroring_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: _models.WorkloadNetworkPortMirroring,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: Resource create parameters. Required.
        :type workload_network_port_mirroring: ~azure.mgmt.avs.models.WorkloadNetworkPortMirroring
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_port_mirroring = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: Resource create parameters. Required.
        :type workload_network_port_mirroring: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: Resource create parameters. Required.
        :type workload_network_port_mirroring: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: Union[_models.WorkloadNetworkPortMirroring, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: Resource create parameters. Is one of the following
         types: WorkloadNetworkPortMirroring, JSON, IO[bytes] Required.
        :type workload_network_port_mirroring: ~azure.mgmt.avs.models.WorkloadNetworkPortMirroring or
         JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_port_mirroring = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkPortMirroring] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                port_mirroring_id=port_mirroring_id,
                workload_network_port_mirroring=workload_network_port_mirroring,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkPortMirroring, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkPortMirroring].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkPortMirroring](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: Union[_models.WorkloadNetworkPortMirroringUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_port_mirroring, (IOBase, bytes)):
            _content = workload_network_port_mirroring
        else:
            _content = json.dumps(workload_network_port_mirroring, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_port_mirroring_profiles_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            port_mirroring_id=port_mirroring_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: _models.WorkloadNetworkPortMirroringUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: The resource properties to be updated. Required.
        :type workload_network_port_mirroring:
         ~azure.mgmt.avs.models.WorkloadNetworkPortMirroringUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_port_mirroring = {
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: The resource properties to be updated. Required.
        :type workload_network_port_mirroring: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: The resource properties to be updated. Required.
        :type workload_network_port_mirroring: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        port_mirroring_id: str,
        workload_network_port_mirroring: Union[_models.WorkloadNetworkPortMirroringUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPortMirroring]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param workload_network_port_mirroring: The resource properties to be updated. Is one of the
         following types: WorkloadNetworkPortMirroringUpdate, JSON, IO[bytes] Required.
        :type workload_network_port_mirroring:
         ~azure.mgmt.avs.models.WorkloadNetworkPortMirroringUpdate or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPortMirroring. The
         WorkloadNetworkPortMirroring is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPortMirroring]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_port_mirroring = {
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destination": "str",  # Optional. Destination VM Group.
                        "direction": "str",  # Optional. Direction of port mirroring profile.
                          Known values are: "INGRESS", "EGRESS", and "BIDIRECTIONAL".
                        "displayName": "str",  # Optional. Display name of the port mirroring
                          profile.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "source": "str",  # Optional. Source VM Group.
                        "status": "str"  # Optional. Port Mirroring Status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkPortMirroring] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                port_mirroring_id=port_mirroring_id,
                workload_network_port_mirroring=workload_network_port_mirroring,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkPortMirroring, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkPortMirroring].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkPortMirroring](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, port_mirroring_id: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_port_mirroring_profiles_delete_request(
            resource_group_name=resource_group_name,
            port_mirroring_id=port_mirroring_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, port_mirroring_id: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkPortMirroring.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param port_mirroring_id: ID of the NSX port mirroring profile. Required.
        :type port_mirroring_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                port_mirroring_id=port_mirroring_id,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkVmGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_vm_groups` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkVMGroup"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkVMGroup resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkVMGroup
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkVMGroup]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_vm_groups_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkVMGroup], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, vm_group_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkVMGroup:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :return: WorkloadNetworkVMGroup. The WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkVMGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkVMGroup] = kwargs.pop("cls", None)

        _request = build_workload_network_vm_groups_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            vm_group_id=vm_group_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkVMGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        resource: Union[_models.WorkloadNetworkVMGroup, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_vm_groups_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            vm_group_id=vm_group_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        resource: _models.WorkloadNetworkVMGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.avs.models.WorkloadNetworkVMGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        resource: Union[_models.WorkloadNetworkVMGroup, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param resource: Resource create parameters. Is one of the following types:
         WorkloadNetworkVMGroup, JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.avs.models.WorkloadNetworkVMGroup or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkVMGroup] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                vm_group_id=vm_group_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkVMGroup, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkVMGroup].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkVMGroup](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        workload_network_v_m_group: Union[_models.WorkloadNetworkVMGroupUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_v_m_group, (IOBase, bytes)):
            _content = workload_network_v_m_group
        else:
            _content = json.dumps(workload_network_v_m_group, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_vm_groups_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            vm_group_id=vm_group_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        workload_network_v_m_group: _models.WorkloadNetworkVMGroupUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param workload_network_v_m_group: The resource properties to be updated. Required.
        :type workload_network_v_m_group: ~azure.mgmt.avs.models.WorkloadNetworkVMGroupUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_v_m_group = {
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        workload_network_v_m_group: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param workload_network_v_m_group: The resource properties to be updated. Required.
        :type workload_network_v_m_group: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        workload_network_v_m_group: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param workload_network_v_m_group: The resource properties to be updated. Required.
        :type workload_network_v_m_group: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        vm_group_id: str,
        workload_network_v_m_group: Union[_models.WorkloadNetworkVMGroupUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkVMGroup]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param workload_network_v_m_group: The resource properties to be updated. Is one of the
         following types: WorkloadNetworkVMGroupUpdate, JSON, IO[bytes] Required.
        :type workload_network_v_m_group: ~azure.mgmt.avs.models.WorkloadNetworkVMGroupUpdate or JSON
         or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkVMGroup. The
         WorkloadNetworkVMGroup is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkVMGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_v_m_group = {
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM group.
                        "members": [
                            "str"  # Optional. Virtual machine members of this group.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. VM Group status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkVMGroup] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                vm_group_id=vm_group_id,
                workload_network_v_m_group=workload_network_v_m_group,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkVMGroup, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkVMGroup].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkVMGroup](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, vm_group_id: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_vm_groups_delete_request(
            resource_group_name=resource_group_name,
            vm_group_id=vm_group_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, vm_group_id: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkVMGroup.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vm_group_id: ID of the VM group. Required.
        :type vm_group_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                vm_group_id=vm_group_id,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkVirtualMachinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_virtual_machines` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkVirtualMachine"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkVirtualMachine resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkVirtualMachine
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkVirtualMachine]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Building", "Deleting", and "Updating".
                        "vmType": "str"  # Optional. Virtual machine type. Known values are:
                          "REGULAR", "EDGE", and "SERVICE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkVirtualMachine]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_virtual_machines_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkVirtualMachine], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, virtual_machine_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkVirtualMachine:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkVirtualMachine.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :return: WorkloadNetworkVirtualMachine. The WorkloadNetworkVirtualMachine is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkVirtualMachine
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Building", "Deleting", and "Updating".
                        "vmType": "str"  # Optional. Virtual machine type. Known values are:
                          "REGULAR", "EDGE", and "SERVICE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkVirtualMachine] = kwargs.pop("cls", None)

        _request = build_workload_network_virtual_machines_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            virtual_machine_id=virtual_machine_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkVirtualMachine, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkloadNetworkDnsServicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_dns_services` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkDnsService"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkDnsService resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkDnsService
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkDnsService]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_dns_services_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkDnsService], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, dns_service_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkDnsService:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :return: WorkloadNetworkDnsService. The WorkloadNetworkDnsService is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkDnsService
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkDnsService] = kwargs.pop("cls", None)

        _request = build_workload_network_dns_services_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_service_id=dns_service_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkDnsService, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: Union[_models.WorkloadNetworkDnsService, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dns_service, (IOBase, bytes)):
            _content = workload_network_dns_service
        else:
            _content = json.dumps(workload_network_dns_service, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dns_services_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_service_id=dns_service_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: _models.WorkloadNetworkDnsService,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: Resource create parameters. Required.
        :type workload_network_dns_service: ~azure.mgmt.avs.models.WorkloadNetworkDnsService
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_service = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: Resource create parameters. Required.
        :type workload_network_dns_service: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: Resource create parameters. Required.
        :type workload_network_dns_service: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: Union[_models.WorkloadNetworkDnsService, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: Resource create parameters. Is one of the following types:
         WorkloadNetworkDnsService, JSON, IO[bytes] Required.
        :type workload_network_dns_service: ~azure.mgmt.avs.models.WorkloadNetworkDnsService or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_service = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDnsService] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dns_service_id=dns_service_id,
                workload_network_dns_service=workload_network_dns_service,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDnsService, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDnsService].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDnsService](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: Union[_models.WorkloadNetworkDnsServiceUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dns_service, (IOBase, bytes)):
            _content = workload_network_dns_service
        else:
            _content = json.dumps(workload_network_dns_service, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dns_services_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_service_id=dns_service_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: _models.WorkloadNetworkDnsServiceUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: The resource properties to be updated. Required.
        :type workload_network_dns_service: ~azure.mgmt.avs.models.WorkloadNetworkDnsServiceUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_service = {
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: The resource properties to be updated. Required.
        :type workload_network_dns_service: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: The resource properties to be updated. Required.
        :type workload_network_dns_service: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_service_id: str,
        workload_network_dns_service: Union[_models.WorkloadNetworkDnsServiceUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsService]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param workload_network_dns_service: The resource properties to be updated. Is one of the
         following types: WorkloadNetworkDnsServiceUpdate, JSON, IO[bytes] Required.
        :type workload_network_dns_service: ~azure.mgmt.avs.models.WorkloadNetworkDnsServiceUpdate or
         JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsService. The
         WorkloadNetworkDnsService is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsService]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_service = {
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultDnsZone": "str",  # Optional. Default DNS zone of the DNS
                          Service.
                        "displayName": "str",  # Optional. Display name of the DNS Service.
                        "dnsServiceIp": "str",  # Optional. DNS service IP of the DNS
                          Service.
                        "fqdnZones": [
                            "str"  # Optional. FQDN zones of the DNS Service.
                        ],
                        "logLevel": "str",  # Optional. DNS Service log level. Known values
                          are: "DEBUG", "INFO", "WARNING", "ERROR", and "FATAL".
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "status": "str"  # Optional. DNS Service status. Known values are:
                          "SUCCESS" and "FAILURE".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDnsService] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dns_service_id=dns_service_id,
                workload_network_dns_service=workload_network_dns_service,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDnsService, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDnsService].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDnsService](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, dns_service_id: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_dns_services_delete_request(
            resource_group_name=resource_group_name,
            dns_service_id=dns_service_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, dns_service_id: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkDnsService.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param dns_service_id: ID of the DNS service. Required.
        :type dns_service_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                dns_service_id=dns_service_id,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkDnsZonesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_dns_zones` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkDnsZone"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkDnsZone resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkDnsZone
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkDnsZone]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_dns_zones_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkDnsZone], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, dns_zone_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkDnsZone:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :return: WorkloadNetworkDnsZone. The WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkDnsZone
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkDnsZone] = kwargs.pop("cls", None)

        _request = build_workload_network_dns_zones_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_zone_id=dns_zone_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkDnsZone, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: Union[_models.WorkloadNetworkDnsZone, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dns_zone, (IOBase, bytes)):
            _content = workload_network_dns_zone
        else:
            _content = json.dumps(workload_network_dns_zone, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dns_zones_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_zone_id=dns_zone_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: _models.WorkloadNetworkDnsZone,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: Resource create parameters. Required.
        :type workload_network_dns_zone: ~azure.mgmt.avs.models.WorkloadNetworkDnsZone
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_zone = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: Resource create parameters. Required.
        :type workload_network_dns_zone: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: Resource create parameters. Required.
        :type workload_network_dns_zone: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: Union[_models.WorkloadNetworkDnsZone, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: Resource create parameters. Is one of the following types:
         WorkloadNetworkDnsZone, JSON, IO[bytes] Required.
        :type workload_network_dns_zone: ~azure.mgmt.avs.models.WorkloadNetworkDnsZone or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_zone = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDnsZone] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dns_zone_id=dns_zone_id,
                workload_network_dns_zone=workload_network_dns_zone,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDnsZone, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDnsZone].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDnsZone](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: Union[_models.WorkloadNetworkDnsZoneUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_dns_zone, (IOBase, bytes)):
            _content = workload_network_dns_zone
        else:
            _content = json.dumps(workload_network_dns_zone, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_dns_zones_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            dns_zone_id=dns_zone_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: _models.WorkloadNetworkDnsZoneUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: The resource properties to be updated. Required.
        :type workload_network_dns_zone: ~azure.mgmt.avs.models.WorkloadNetworkDnsZoneUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_zone = {
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: The resource properties to be updated. Required.
        :type workload_network_dns_zone: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: The resource properties to be updated. Required.
        :type workload_network_dns_zone: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        dns_zone_id: str,
        workload_network_dns_zone: Union[_models.WorkloadNetworkDnsZoneUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkDnsZone]:
        # pylint: disable=line-too-long
        """Update a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param workload_network_dns_zone: The resource properties to be updated. Is one of the
         following types: WorkloadNetworkDnsZoneUpdate, JSON, IO[bytes] Required.
        :type workload_network_dns_zone: ~azure.mgmt.avs.models.WorkloadNetworkDnsZoneUpdate or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkDnsZone. The
         WorkloadNetworkDnsZone is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkDnsZone]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_dns_zone = {
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the DNS Zone.
                        "dnsServerIps": [
                            "str"  # Optional. DNS Server IP array of the DNS Zone.
                        ],
                        "dnsServices": 0,  # Optional. Number of DNS Services using the DNS
                          zone.
                        "domain": [
                            "str"  # Optional. Domain names of the DNS Zone.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "revision": 0,  # Optional. NSX revision number.
                        "sourceIp": "str"  # Optional. Source IP of the DNS Zone.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkDnsZone] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                dns_zone_id=dns_zone_id,
                workload_network_dns_zone=workload_network_dns_zone,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkDnsZone, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkDnsZone].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkDnsZone](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, dns_zone_id: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_dns_zones_delete_request(
            resource_group_name=resource_group_name,
            dns_zone_id=dns_zone_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, dns_zone_id: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkDnsZone.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param dns_zone_id: ID of the DNS zone. Required.
        :type dns_zone_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                dns_zone_id=dns_zone_id,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WorkloadNetworkPublicIpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`workload_network_public_ips` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_workload_network(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.WorkloadNetworkPublicIp"]:
        # pylint: disable=line-too-long
        """List WorkloadNetworkPublicIP resources by WorkloadNetwork.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of WorkloadNetworkPublicIp
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.WorkloadNetworkPublicIp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkloadNetworkPublicIp]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workload_network_public_ips_list_by_workload_network_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.WorkloadNetworkPublicIp], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, public_i_p_id: str, **kwargs: Any
    ) -> _models.WorkloadNetworkPublicIp:
        # pylint: disable=line-too-long
        """Get a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :return: WorkloadNetworkPublicIp. The WorkloadNetworkPublicIp is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.WorkloadNetworkPublicIp
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkloadNetworkPublicIp] = kwargs.pop("cls", None)

        _request = build_workload_network_public_ips_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            public_i_p_id=public_i_p_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.WorkloadNetworkPublicIp, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        public_i_p_id: str,
        workload_network_public_i_p: Union[_models.WorkloadNetworkPublicIp, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(workload_network_public_i_p, (IOBase, bytes)):
            _content = workload_network_public_i_p
        else:
            _content = json.dumps(workload_network_public_i_p, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_workload_network_public_ips_create_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            public_i_p_id=public_i_p_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        public_i_p_id: str,
        workload_network_public_i_p: _models.WorkloadNetworkPublicIp,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPublicIp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :param workload_network_public_i_p: Resource create parameters. Required.
        :type workload_network_public_i_p: ~azure.mgmt.avs.models.WorkloadNetworkPublicIp
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPublicIp. The
         WorkloadNetworkPublicIp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPublicIp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_public_i_p = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        public_i_p_id: str,
        workload_network_public_i_p: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPublicIp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :param workload_network_public_i_p: Resource create parameters. Required.
        :type workload_network_public_i_p: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPublicIp. The
         WorkloadNetworkPublicIp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPublicIp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        public_i_p_id: str,
        workload_network_public_i_p: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPublicIp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :param workload_network_public_i_p: Resource create parameters. Required.
        :type workload_network_public_i_p: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPublicIp. The
         WorkloadNetworkPublicIp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPublicIp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        public_i_p_id: str,
        workload_network_public_i_p: Union[_models.WorkloadNetworkPublicIp, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.WorkloadNetworkPublicIp]:
        # pylint: disable=line-too-long
        """Create a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :param workload_network_public_i_p: Resource create parameters. Is one of the following types:
         WorkloadNetworkPublicIp, JSON, IO[bytes] Required.
        :type workload_network_public_i_p: ~azure.mgmt.avs.models.WorkloadNetworkPublicIp or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns WorkloadNetworkPublicIp. The
         WorkloadNetworkPublicIp is compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.WorkloadNetworkPublicIp]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload_network_public_i_p = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the Public IP
                          Block.
                        "numberOfPublicIPs": 0,  # Optional. Number of Public IPs requested.
                        "provisioningState": "str",  # Optional. The provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Building", "Deleting",
                          and "Updating".
                        "publicIPBlock": "str"  # Optional. CIDR Block of the Public IP
                          Block.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkloadNetworkPublicIp] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                public_i_p_id=public_i_p_id,
                workload_network_public_i_p=workload_network_public_i_p,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.WorkloadNetworkPublicIp, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.WorkloadNetworkPublicIp].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.WorkloadNetworkPublicIp](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, public_i_p_id: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workload_network_public_ips_delete_request(
            resource_group_name=resource_group_name,
            public_i_p_id=public_i_p_id,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, public_i_p_id: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a WorkloadNetworkPublicIP.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param public_i_p_id: ID of the DNS zone. Required.
        :type public_i_p_id: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                public_i_p_id=public_i_p_id,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class CloudLinksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`cloud_links` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.CloudLink"]:
        # pylint: disable=line-too-long
        """List CloudLink resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of CloudLink
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.CloudLink]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CloudLink]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_cloud_links_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CloudLink], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, cloud_link_name: str, **kwargs: Any
    ) -> _models.CloudLink:
        # pylint: disable=line-too-long
        """Get a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :return: CloudLink. The CloudLink is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.CloudLink
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CloudLink] = kwargs.pop("cls", None)

        _request = build_cloud_links_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cloud_link_name=cloud_link_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CloudLink, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cloud_link_name: str,
        cloud_link: Union[_models.CloudLink, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(cloud_link, (IOBase, bytes)):
            _content = cloud_link
        else:
            _content = json.dumps(cloud_link, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cloud_links_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cloud_link_name=cloud_link_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cloud_link_name: str,
        cloud_link: _models.CloudLink,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.CloudLink]:
        # pylint: disable=line-too-long
        """Create a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :param cloud_link: Resource create parameters. Required.
        :type cloud_link: ~azure.mgmt.avs.models.CloudLink
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns CloudLink. The CloudLink is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.CloudLink]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cloud_link = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cloud_link_name: str,
        cloud_link: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.CloudLink]:
        # pylint: disable=line-too-long
        """Create a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :param cloud_link: Resource create parameters. Required.
        :type cloud_link: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns CloudLink. The CloudLink is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.CloudLink]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cloud_link_name: str,
        cloud_link: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.CloudLink]:
        # pylint: disable=line-too-long
        """Create a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :param cloud_link: Resource create parameters. Required.
        :type cloud_link: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns CloudLink. The CloudLink is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.CloudLink]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cloud_link_name: str,
        cloud_link: Union[_models.CloudLink, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.CloudLink]:
        # pylint: disable=line-too-long
        """Create a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :param cloud_link: Resource create parameters. Is one of the following types: CloudLink, JSON,
         IO[bytes] Required.
        :type cloud_link: ~azure.mgmt.avs.models.CloudLink or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns CloudLink. The CloudLink is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.CloudLink]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cloud_link = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "linkedCloud": "str",  # Optional. Identifier of the other private
                          cloud participating in the link.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": "str"  # Optional. The state of the cloud link. Known
                          values are: "Active", "Building", "Deleting", "Failed", and "Disconnected".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CloudLink] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cloud_link_name=cloud_link_name,
                cloud_link=cloud_link,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.CloudLink, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.CloudLink].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.CloudLink](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, cloud_link_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cloud_links_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cloud_link_name=cloud_link_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, cloud_link_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a CloudLink.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cloud_link_name: Name of the cloud link. Required.
        :type cloud_link_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cloud_link_name=cloud_link_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AddonsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`addons` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, private_cloud_name: str, **kwargs: Any) -> AsyncIterable["_models.Addon"]:
        # pylint: disable=line-too-long
        """List Addon resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of Addon
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.Addon]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Addon]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_addons_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Addon], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, addon_name: str, **kwargs: Any
    ) -> _models.Addon:
        # pylint: disable=line-too-long
        """Get a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :return: Addon. The Addon is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.Addon
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Addon] = kwargs.pop("cls", None)

        _request = build_addons_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            addon_name=addon_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Addon, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        addon_name: str,
        addon: Union[_models.Addon, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(addon, (IOBase, bytes)):
            _content = addon
        else:
            _content = json.dumps(addon, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_addons_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            addon_name=addon_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        addon_name: str,
        addon: _models.Addon,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Addon]:
        # pylint: disable=line-too-long
        """Create a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :param addon: Resource create parameters. Required.
        :type addon: ~azure.mgmt.avs.models.Addon
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Addon. The Addon is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Addon]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template you can fill out and use as your body input.
                addon = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        addon_name: str,
        addon: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Addon]:
        # pylint: disable=line-too-long
        """Create a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :param addon: Resource create parameters. Required.
        :type addon: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Addon. The Addon is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Addon]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        addon_name: str,
        addon: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Addon]:
        # pylint: disable=line-too-long
        """Create a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :param addon: Resource create parameters. Required.
        :type addon: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Addon. The Addon is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Addon]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        addon_name: str,
        addon: Union[_models.Addon, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Addon]:
        # pylint: disable=line-too-long
        """Create a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :param addon: Resource create parameters. Is one of the following types: Addon, JSON, IO[bytes]
         Required.
        :type addon: ~azure.mgmt.avs.models.Addon or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Addon. The Addon is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.Addon]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template you can fill out and use as your body input.
                addon = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "addonType":

                # JSON input template for discriminator value "Arc":
                addon_properties = {
                    "addonType": "Arc",
                    "provisioningState": "str",  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                    "vCenter": "str"  # Optional. The VMware vCenter resource ID.
                }

                # JSON input template for discriminator value "HCX":
                addon_properties = {
                    "addonType": "HCX",
                    "offer": "str",  # The HCX offer, example VMware MaaS Cloud Provider
                      (Enterprise). Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "SRM":
                addon_properties = {
                    "addonType": "SRM",
                    "licenseKey": "str",  # Optional. The Site Recovery Manager (SRM) license.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # JSON input template for discriminator value "VR":
                addon_properties = {
                    "addonType": "VR",
                    "vrsCount": 0,  # The vSphere Replication Server (VRS) count. Required.
                    "provisioningState": "str"  # Optional. The state of the addon provisioning.
                      Known values are: "Succeeded", "Failed", "Canceled", "Cancelled", "Building",
                      "Deleting", and "Updating".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": addon_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Addon] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                addon_name=addon_name,
                addon=addon,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Addon, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Addon].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Addon](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, addon_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_addons_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            addon_name=addon_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, addon_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a Addon.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param addon_name: Name of the addon. Required.
        :type addon_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                addon_name=addon_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class VirtualMachinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`virtual_machines` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.VirtualMachine"]:
        # pylint: disable=line-too-long
        """List VirtualMachine resources by Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: An iterator like instance of VirtualMachine
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.VirtualMachine]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM.
                        "folderPath": "str",  # Optional. Path to virtual machine's folder
                          starting from datacenter virtual machine folder.
                        "moRefId": "str",  # Optional. Virtual machine managed object
                          reference id.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "restrictMovement": "str"  # Optional. Whether VM DRS-driven movement
                          is restricted (enabled) or not (disabled). Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualMachine]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machines_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    cluster_name=cluster_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualMachine], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        **kwargs: Any
    ) -> _models.VirtualMachine:
        # pylint: disable=line-too-long
        """Get a VirtualMachine.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :return: VirtualMachine. The VirtualMachine is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.VirtualMachine
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "displayName": "str",  # Optional. Display name of the VM.
                        "folderPath": "str",  # Optional. Path to virtual machine's folder
                          starting from datacenter virtual machine folder.
                        "moRefId": "str",  # Optional. Virtual machine managed object
                          reference id.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "restrictMovement": "str"  # Optional. Whether VM DRS-driven movement
                          is restricted (enabled) or not (disabled). Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VirtualMachine] = kwargs.pop("cls", None)

        _request = build_virtual_machines_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            virtual_machine_id=virtual_machine_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VirtualMachine, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _restrict_movement_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        restrict_movement: Union[_models.VirtualMachineRestrictMovement, JSON, IO[bytes]],
        **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(restrict_movement, (IOBase, bytes)):
            _content = restrict_movement
        else:
            _content = json.dumps(restrict_movement, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machines_restrict_movement_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            virtual_machine_id=virtual_machine_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    async def begin_restrict_movement(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        restrict_movement: _models.VirtualMachineRestrictMovement,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        # pylint: disable=line-too-long
        """Enable or disable DRS-driven VM movement restriction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :param restrict_movement: The body type of the operation request. Required.
        :type restrict_movement: ~azure.mgmt.avs.models.VirtualMachineRestrictMovement
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restrict_movement = {
                    "restrictMovement": "str"  # Optional. Whether VM DRS-driven movement is
                      restricted (enabled) or not (disabled). Known values are: "Enabled" and
                      "Disabled".
                }
        """

    @overload
    async def begin_restrict_movement(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        restrict_movement: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Enable or disable DRS-driven VM movement restriction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :param restrict_movement: The body type of the operation request. Required.
        :type restrict_movement: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_restrict_movement(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        restrict_movement: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Enable or disable DRS-driven VM movement restriction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :param restrict_movement: The body type of the operation request. Required.
        :type restrict_movement: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_restrict_movement(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        virtual_machine_id: str,
        restrict_movement: Union[_models.VirtualMachineRestrictMovement, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        # pylint: disable=line-too-long
        """Enable or disable DRS-driven VM movement restriction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param virtual_machine_id: ID of the virtual machine. Required.
        :type virtual_machine_id: str
        :param restrict_movement: The body type of the operation request. Is one of the following
         types: VirtualMachineRestrictMovement, JSON, IO[bytes] Required.
        :type restrict_movement: ~azure.mgmt.avs.models.VirtualMachineRestrictMovement or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restrict_movement = {
                    "restrictMovement": "str"  # Optional. Whether VM DRS-driven movement is
                      restricted (enabled) or not (disabled). Known values are: "Enabled" and
                      "Disabled".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._restrict_movement_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                virtual_machine_id=virtual_machine_id,
                restrict_movement=restrict_movement,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class PlacementPoliciesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`placement_policies` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, cluster_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.PlacementPolicy"]:
        # pylint: disable=line-too-long
        """List PlacementPolicy resources by Cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: An iterator like instance of PlacementPolicy
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.PlacementPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PlacementPolicy]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_placement_policies_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    cluster_name=cluster_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PlacementPolicy], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        **kwargs: Any
    ) -> _models.PlacementPolicy:
        # pylint: disable=line-too-long
        """Get a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :return: PlacementPolicy. The PlacementPolicy is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PlacementPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PlacementPolicy] = kwargs.pop("cls", None)

        _request = build_placement_policies_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            placement_policy_name=placement_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PlacementPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy: Union[_models.PlacementPolicy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(placement_policy, (IOBase, bytes)):
            _content = placement_policy
        else:
            _content = json.dumps(placement_policy, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_placement_policies_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            placement_policy_name=placement_policy_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy: _models.PlacementPolicy,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PlacementPolicy]:
        # pylint: disable=line-too-long
        """Create a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy: Resource create parameters. Required.
        :type placement_policy: ~azure.mgmt.avs.models.PlacementPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PlacementPolicy. The PlacementPolicy is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PlacementPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template you can fill out and use as your body input.
                placement_policy = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PlacementPolicy]:
        # pylint: disable=line-too-long
        """Create a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy: Resource create parameters. Required.
        :type placement_policy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PlacementPolicy. The PlacementPolicy is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PlacementPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PlacementPolicy]:
        # pylint: disable=line-too-long
        """Create a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy: Resource create parameters. Required.
        :type placement_policy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns PlacementPolicy. The PlacementPolicy is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PlacementPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy: Union[_models.PlacementPolicy, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.PlacementPolicy]:
        # pylint: disable=line-too-long
        """Create a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy: Resource create parameters. Is one of the following types:
         PlacementPolicy, JSON, IO[bytes] Required.
        :type placement_policy: ~azure.mgmt.avs.models.PlacementPolicy or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns PlacementPolicy. The PlacementPolicy is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.PlacementPolicy]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template you can fill out and use as your body input.
                placement_policy = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PlacementPolicy] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                placement_policy_name=placement_policy_name,
                placement_policy=placement_policy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.PlacementPolicy, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.PlacementPolicy].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.PlacementPolicy](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy_update: _models.PlacementPolicyUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PlacementPolicy:
        # pylint: disable=line-too-long
        """Update a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy_update: The placement policy properties to be updated. Required.
        :type placement_policy_update: ~azure.mgmt.avs.models.PlacementPolicyUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PlacementPolicy. The PlacementPolicy is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PlacementPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                placement_policy_update = {
                    "properties": {
                        "affinityStrength": "str",  # Optional. vm-host placement policy
                          affinity strength (should/must). Known values are: "Should" and "Must".
                        "azureHybridBenefitType": "str",  # Optional. placement policy azure
                          hybrid benefit opt-in type. Known values are: "SqlHost" and "None".
                        "hostMembers": [
                            "str"  # Optional. Host members list.
                        ],
                        "state": "str",  # Optional. Whether the placement policy is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "vmMembers": [
                            "str"  # Optional. Virtual machine members list.
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy_update: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PlacementPolicy:
        # pylint: disable=line-too-long
        """Update a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy_update: The placement policy properties to be updated. Required.
        :type placement_policy_update: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PlacementPolicy. The PlacementPolicy is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PlacementPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy_update: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PlacementPolicy:
        # pylint: disable=line-too-long
        """Update a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy_update: The placement policy properties to be updated. Required.
        :type placement_policy_update: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PlacementPolicy. The PlacementPolicy is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PlacementPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        placement_policy_update: Union[_models.PlacementPolicyUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PlacementPolicy:
        # pylint: disable=line-too-long
        """Update a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :param placement_policy_update: The placement policy properties to be updated. Is one of the
         following types: PlacementPolicyUpdate, JSON, IO[bytes] Required.
        :type placement_policy_update: ~azure.mgmt.avs.models.PlacementPolicyUpdate or JSON or
         IO[bytes]
        :return: PlacementPolicy. The PlacementPolicy is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.PlacementPolicy
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                placement_policy_update = {
                    "properties": {
                        "affinityStrength": "str",  # Optional. vm-host placement policy
                          affinity strength (should/must). Known values are: "Should" and "Must".
                        "azureHybridBenefitType": "str",  # Optional. placement policy azure
                          hybrid benefit opt-in type. Known values are: "SqlHost" and "None".
                        "hostMembers": [
                            "str"  # Optional. Host members list.
                        ],
                        "state": "str",  # Optional. Whether the placement policy is enabled
                          or disabled. Known values are: "Enabled" and "Disabled".
                        "vmMembers": [
                            "str"  # Optional. Virtual machine members list.
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "VmHost":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "hostMembers": [
                        "str"  # Host members list. Required.
                    ],
                    "type": "VmHost",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "affinityStrength": "str",  # Optional. vm-host placement policy affinity
                      strength (should/must). Known values are: "Should" and "Must".
                    "azureHybridBenefitType": "str",  # Optional. placement policy azure hybrid
                      benefit opt-in type. Known values are: "SqlHost" and "None".
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # JSON input template for discriminator value "VmVm":
                placement_policy_properties = {
                    "affinityType": "str",  # placement policy affinity type. Required. Known
                      values are: "Affinity" and "AntiAffinity".
                    "type": "VmVm",
                    "vmMembers": [
                        "str"  # Virtual machine members list. Required.
                    ],
                    "displayName": "str",  # Optional. Display name of the placement policy.
                    "provisioningState": "str",  # Optional. The provisioning state. Known values
                      are: "Succeeded", "Failed", "Canceled", "Building", "Deleting", and "Updating".
                    "state": "str"  # Optional. Whether the placement policy is enabled or
                      disabled. Known values are: "Enabled" and "Disabled".
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": placement_policy_properties,
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PlacementPolicy] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(placement_policy_update, (IOBase, bytes)):
            _content = placement_policy_update
        else:
            _content = json.dumps(placement_policy_update, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_placement_policies_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            placement_policy_name=placement_policy_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PlacementPolicy, response.json())

        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PlacementPolicy, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_placement_policies_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            cluster_name=cluster_name,
            placement_policy_name=placement_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        cluster_name: str,
        placement_policy_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a PlacementPolicy.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param placement_policy_name: Name of the placement policy. Required.
        :type placement_policy_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cluster_name=cluster_name,
                placement_policy_name=placement_policy_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ScriptPackagesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`script_packages` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.ScriptPackage"]:
        # pylint: disable=line-too-long
        """List ScriptPackage resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of ScriptPackage
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.ScriptPackage]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "company": "str",  # Optional. Company that created and supports the
                          package.
                        "description": "str",  # Optional. User friendly description of the
                          package.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "uri": "str",  # Optional. Link to support by the package vendor.
                        "version": "str"  # Optional. Module version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ScriptPackage]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_script_packages_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ScriptPackage], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, script_package_name: str, **kwargs: Any
    ) -> _models.ScriptPackage:
        # pylint: disable=line-too-long
        """Get a ScriptPackage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_package_name: Name of the script package. Required.
        :type script_package_name: str
        :return: ScriptPackage. The ScriptPackage is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptPackage
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "company": "str",  # Optional. Company that created and supports the
                          package.
                        "description": "str",  # Optional. User friendly description of the
                          package.
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "uri": "str",  # Optional. Link to support by the package vendor.
                        "version": "str"  # Optional. Module version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ScriptPackage] = kwargs.pop("cls", None)

        _request = build_script_packages_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_package_name=script_package_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ScriptPackage, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ScriptCmdletsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`script_cmdlets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, script_package_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.ScriptCmdlet"]:
        # pylint: disable=line-too-long
        """List ScriptCmdlet resources by ScriptPackage.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_package_name: Name of the script package. Required.
        :type script_package_name: str
        :return: An iterator like instance of ScriptCmdlet
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.ScriptCmdlet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "audience": "str",  # Optional. Specifies whether a script cmdlet is
                          intended to be invoked only through automation or visible to customers. Known
                          values are: "Automation" and "Any".
                        "description": "str",  # Optional. Description of the scripts
                          functionality.
                        "parameters": [
                            {
                                "description": "str",  # Optional. User friendly
                                  description of the parameter.
                                "name": "str",  # Optional. The parameter name that
                                  the script will expect a parameter value for.
                                "optional": "str",  # Optional. Is this parameter
                                  required or optional. Known values are: "Optional" and "Required".
                                "type": "str",  # Optional. The type of parameter the
                                  script is expecting. psCredential is a PSCredentialObject. Known
                                  values are: "String", "SecureString", "Credential", "Int", "Bool",
                                  and "Float".
                                "visibility": "str"  # Optional. Should this
                                  parameter be visible to arm and passed in the parameters argument
                                  when executing. Known values are: "Visible" and "Hidden".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "timeout": "str"  # Optional. Recommended time limit for execution.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ScriptCmdlet]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_script_cmdlets_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    script_package_name=script_package_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ScriptCmdlet], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_package_name: str,
        script_cmdlet_name: str,
        **kwargs: Any
    ) -> _models.ScriptCmdlet:
        # pylint: disable=line-too-long
        """Get a ScriptCmdlet.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_package_name: Name of the script package. Required.
        :type script_package_name: str
        :param script_cmdlet_name: Name of the script cmdlet. Required.
        :type script_cmdlet_name: str
        :return: ScriptCmdlet. The ScriptCmdlet is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptCmdlet
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "audience": "str",  # Optional. Specifies whether a script cmdlet is
                          intended to be invoked only through automation or visible to customers. Known
                          values are: "Automation" and "Any".
                        "description": "str",  # Optional. Description of the scripts
                          functionality.
                        "parameters": [
                            {
                                "description": "str",  # Optional. User friendly
                                  description of the parameter.
                                "name": "str",  # Optional. The parameter name that
                                  the script will expect a parameter value for.
                                "optional": "str",  # Optional. Is this parameter
                                  required or optional. Known values are: "Optional" and "Required".
                                "type": "str",  # Optional. The type of parameter the
                                  script is expecting. psCredential is a PSCredentialObject. Known
                                  values are: "String", "SecureString", "Credential", "Int", "Bool",
                                  and "Float".
                                "visibility": "str"  # Optional. Should this
                                  parameter be visible to arm and passed in the parameters argument
                                  when executing. Known values are: "Visible" and "Hidden".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the resource. Known values are: "Succeeded", "Failed", and "Canceled".
                        "timeout": "str"  # Optional. Recommended time limit for execution.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ScriptCmdlet] = kwargs.pop("cls", None)

        _request = build_script_cmdlets_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_package_name=script_package_name,
            script_cmdlet_name=script_cmdlet_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ScriptCmdlet, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ScriptExecutionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`script_executions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.ScriptExecution"]:
        # pylint: disable=line-too-long
        """List ScriptExecution resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of ScriptExecution
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.ScriptExecution]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ScriptExecution]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_script_executions_list_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ScriptExecution], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, private_cloud_name: str, script_execution_name: str, **kwargs: Any
    ) -> _models.ScriptExecution:
        # pylint: disable=line-too-long
        """Get a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :return: ScriptExecution. The ScriptExecution is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptExecution
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ScriptExecution] = kwargs.pop("cls", None)

        _request = build_script_executions_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_execution_name=script_execution_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ScriptExecution, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_execution: Union[_models.ScriptExecution, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(script_execution, (IOBase, bytes)):
            _content = script_execution
        else:
            _content = json.dumps(script_execution, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_script_executions_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_execution_name=script_execution_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_execution: _models.ScriptExecution,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ScriptExecution]:
        # pylint: disable=line-too-long
        """Create a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_execution: Resource create parameters. Required.
        :type script_execution: ~azure.mgmt.avs.models.ScriptExecution
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ScriptExecution. The ScriptExecution is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ScriptExecution]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                script_execution = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_execution: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ScriptExecution]:
        # pylint: disable=line-too-long
        """Create a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_execution: Resource create parameters. Required.
        :type script_execution: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ScriptExecution. The ScriptExecution is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ScriptExecution]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_execution: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ScriptExecution]:
        # pylint: disable=line-too-long
        """Create a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_execution: Resource create parameters. Required.
        :type script_execution: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns ScriptExecution. The ScriptExecution is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ScriptExecution]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_execution: Union[_models.ScriptExecution, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.ScriptExecution]:
        # pylint: disable=line-too-long
        """Create a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_execution: Resource create parameters. Is one of the following types:
         ScriptExecution, JSON, IO[bytes] Required.
        :type script_execution: ~azure.mgmt.avs.models.ScriptExecution or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns ScriptExecution. The ScriptExecution is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.ScriptExecution]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                script_execution = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ScriptExecution] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                script_execution_name=script_execution_name,
                script_execution=script_execution,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.ScriptExecution, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.ScriptExecution].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.ScriptExecution](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, script_execution_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_script_executions_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_execution_name=script_execution_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, script_execution_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a ScriptExecution.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                script_execution_name=script_execution_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    async def get_execution_logs(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_output_stream_type: Optional[List[Union[str, _models.ScriptOutputStreamType]]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ScriptExecution:
        # pylint: disable=line-too-long
        """Return the logs for a script execution resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_output_stream_type: Name of the desired output stream to return. If not provided,
         will return all. An empty array will return nothing. Default value is None.
        :type script_output_stream_type: list[str or ~azure.mgmt.avs.models.ScriptOutputStreamType]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScriptExecution. The ScriptExecution is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptExecution
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                script_output_stream_type = [
                    "str"  # Optional.
                ]

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def get_execution_logs(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_output_stream_type: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ScriptExecution:
        # pylint: disable=line-too-long
        """Return the logs for a script execution resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_output_stream_type: Name of the desired output stream to return. If not provided,
         will return all. An empty array will return nothing. Default value is None.
        :type script_output_stream_type: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScriptExecution. The ScriptExecution is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptExecution
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def get_execution_logs(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        script_execution_name: str,
        script_output_stream_type: Optional[Union[List[Union[str, _models.ScriptOutputStreamType]], IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.ScriptExecution:
        # pylint: disable=line-too-long
        """Return the logs for a script execution resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param script_execution_name: Name of the script cmdlet. Required.
        :type script_execution_name: str
        :param script_output_stream_type: Name of the desired output stream to return. If not provided,
         will return all. An empty array will return nothing. Is either a [Union[str,
         "_models.ScriptOutputStreamType"]] type or a IO[bytes] type. Default value is None.
        :type script_output_stream_type: list[str or ~azure.mgmt.avs.models.ScriptOutputStreamType] or
         IO[bytes]
        :return: ScriptExecution. The ScriptExecution is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.ScriptExecution
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "timeout": "str",  # Time limit for execution. Required.
                        "errors": [
                            "str"  # Optional. Standard error output stream from the
                              powershell execution.
                        ],
                        "failureReason": "str",  # Optional. Error message if the script was
                          able to run, but if the script itself had errors or powershell threw an
                          exception.
                        "finishedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was finished.
                        "hiddenParameters": [
                            script_execution_parameter
                        ],
                        "information": [
                            "str"  # Optional. Standard information out stream from the
                              powershell execution.
                        ],
                        "namedOutputs": {
                            "str": {}  # Optional. User-defined dictionary.
                        },
                        "output": [
                            "str"  # Optional. Standard output stream from the powershell
                              execution.
                        ],
                        "parameters": [
                            script_execution_parameter
                        ],
                        "provisioningState": "str",  # Optional. The state of the script
                          execution resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Pending", "Running", "Cancelling", "Cancelled", and "Deleting".
                        "retention": "str",  # Optional. Time to live for the resource. If
                          not provided, will be available for 60 days.
                        "scriptCmdletId": "str",  # Optional. A reference to the script
                          cmdlet resource if user is running a AVS script.
                        "startedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was started.
                        "submittedAt": "2020-02-20 00:00:00",  # Optional. Time the script
                          execution was submitted.
                        "warnings": [
                            "str"  # Optional. Standard warning out stream from the
                              powershell execution.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ScriptExecution] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(script_output_stream_type, (IOBase, bytes)):
            _content = script_output_stream_type
        else:
            if script_output_stream_type is not None:
                _content = json.dumps(script_output_stream_type, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_script_executions_get_execution_logs_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            script_execution_name=script_execution_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ScriptExecution, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IscsiPathsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.avs.aio.AVSClient`'s
        :attr:`iscsi_paths` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_private_cloud(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.IscsiPath"]:
        # pylint: disable=line-too-long
        """List IscsiPath resources by PrivateCloud.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An iterator like instance of IscsiPath
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.avs.models.IscsiPath]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IscsiPath]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_iscsi_paths_list_by_private_cloud_request(
                    resource_group_name=resource_group_name,
                    private_cloud_name=private_cloud_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.IscsiPath], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, private_cloud_name: str, **kwargs: Any) -> _models.IscsiPath:
        # pylint: disable=line-too-long
        """Get a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: IscsiPath. The IscsiPath is compatible with MutableMapping
        :rtype: ~azure.mgmt.avs.models.IscsiPath
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IscsiPath] = kwargs.pop("cls", None)

        _request = build_iscsi_paths_get_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IscsiPath, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        resource: Union[_models.IscsiPath, JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_iscsi_paths_create_or_update_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = _deserialize(JSON, response.json())

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        resource: _models.IscsiPath,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.IscsiPath]:
        # pylint: disable=line-too-long
        """Create a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.avs.models.IscsiPath
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns IscsiPath. The IscsiPath is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.IscsiPath]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.IscsiPath]:
        # pylint: disable=line-too-long
        """Create a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns IscsiPath. The IscsiPath is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.IscsiPath]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.IscsiPath]:
        # pylint: disable=line-too-long
        """Create a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns IscsiPath. The IscsiPath is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.IscsiPath]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        private_cloud_name: str,
        resource: Union[_models.IscsiPath, JSON, IO[bytes]],
        **kwargs: Any
    ) -> AsyncLROPoller[_models.IscsiPath]:
        # pylint: disable=line-too-long
        """Create a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :param resource: Resource create parameters. Is one of the following types: IscsiPath, JSON,
         IO[bytes] Required.
        :type resource: ~azure.mgmt.avs.models.IscsiPath or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns IscsiPath. The IscsiPath is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.avs.models.IscsiPath]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "networkBlock": "str",  # CIDR Block for iSCSI path. Required.
                        "provisioningState": "str"  # Optional. The state of the iSCSI path
                          provisioning. Known values are: "Succeeded", "Failed", "Canceled", "Pending",
                          "Building", "Deleting", and "Updating".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20",  # Optional. The type of identity that
                          created the resource.
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20",  # Optional. The timestamp of
                          resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IscsiPath] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.IscsiPath, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.IscsiPath].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.IscsiPath](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_iscsi_paths_delete_request(
            resource_group_name=resource_group_name,
            private_cloud_name=private_cloud_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, private_cloud_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a IscsiPath.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param private_cloud_name: Name of the private cloud. Required.
        :type private_cloud_name: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                private_cloud_name=private_cloud_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
