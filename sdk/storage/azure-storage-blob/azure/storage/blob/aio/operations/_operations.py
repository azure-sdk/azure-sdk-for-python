# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, AsyncIterator, Callable, Dict, List, Optional, TypeVar, Union
from xml.etree import ElementTree as ET

from azure.core import MatchConditions
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import _deserialize, _deserialize_xml, _failsafe_deserialize, _get_element
from ...operations._operations import (
    build_append_blob_append_block_from_url_request,
    build_append_blob_append_block_request,
    build_append_blob_create_request,
    build_append_blob_seal_request,
    build_blob_abort_copy_from_url_request,
    build_blob_acquire_lease_request,
    build_blob_break_lease_request,
    build_blob_change_lease_request,
    build_blob_copy_from_url_request,
    build_blob_create_snapshot_request,
    build_blob_delete_immutability_policy_request,
    build_blob_delete_request,
    build_blob_download_request,
    build_blob_get_account_info_request,
    build_blob_get_properties_request,
    build_blob_get_tags_request,
    build_blob_query_request,
    build_blob_release_lease_request,
    build_blob_renew_lease_request,
    build_blob_set_expiry_request,
    build_blob_set_http_headers_request,
    build_blob_set_immutability_policy_request,
    build_blob_set_legal_hold_request,
    build_blob_set_metadata_request,
    build_blob_set_tags_request,
    build_blob_set_tier_request,
    build_blob_start_copy_from_url_request,
    build_blob_undelete_request,
    build_block_blob_commit_block_list_request,
    build_block_blob_get_block_list_request,
    build_block_blob_put_blob_from_url_request,
    build_block_blob_stage_block_from_url_request,
    build_block_blob_stage_block_request,
    build_block_blob_upload_request,
    build_container_acquire_lease_request,
    build_container_break_lease_request,
    build_container_change_lease_request,
    build_container_create_request,
    build_container_delete_request,
    build_container_filter_blobs_request,
    build_container_get_access_policy_request,
    build_container_get_account_info_request,
    build_container_get_properties_request,
    build_container_list_blob_flat_segment_request,
    build_container_list_blob_hierarchy_segment_request,
    build_container_release_lease_request,
    build_container_rename_request,
    build_container_renew_lease_request,
    build_container_restore_request,
    build_container_set_access_policy_request,
    build_container_set_metadata_request,
    build_container_submit_batch_request,
    build_page_blob_clear_pages_request,
    build_page_blob_copy_incremental_request,
    build_page_blob_create_request,
    build_page_blob_get_page_ranges_diff_request,
    build_page_blob_get_page_ranges_request,
    build_page_blob_resize_request,
    build_page_blob_update_sequence_number_request,
    build_page_blob_upload_pages_from_url_request,
    build_page_blob_upload_pages_request,
    build_service_filter_blobs_request,
    build_service_get_account_info_request,
    build_service_get_properties_request,
    build_service_get_statistics_request,
    build_service_get_user_delegation_key_request,
    build_service_list_containers_segment_request,
    build_service_set_properties_request,
    build_service_submit_batch_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`service` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def set_properties(
        self,
        body: ET.Element = _Unset,
        *,
        timeout: Optional[int] = None,
        logging: Optional[_models.Logging] = None,
        hour_metrics: Optional[_models.Metrics] = None,
        minute_metrics: Optional[_models.Metrics] = None,
        cors: Optional[List[_models.CorsRule]] = None,
        default_service_version: Optional[str] = None,
        delete_retention_policy: Optional[_models.RetentionPolicy] = None,
        static_website: Optional[_models.StaticWebsite] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Sets properties for a storage account's Blob service endpoint, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param body: Required.
        :type body: ET.Element
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword logging: The logging properties. Default value is None.
        :paramtype logging: ~azure.storage.blob.models.Logging
        :keyword hour_metrics: The hour metrics properties. Default value is None.
        :paramtype hour_metrics: ~azure.storage.blob.models.Metrics
        :keyword minute_metrics: The minute metrics properties. Default value is None.
        :paramtype minute_metrics: ~azure.storage.blob.models.Metrics
        :keyword cors: The CORS properties. Default value is None.
        :paramtype cors: list[~azure.storage.blob.models.CorsRule]
        :keyword default_service_version: The default service version. Default value is None.
        :paramtype default_service_version: str
        :keyword delete_retention_policy: The delete retention policy. Default value is None.
        :paramtype delete_retention_policy: ~azure.storage.blob.models.RetentionPolicy
        :keyword static_website: The static website properties. Default value is None.
        :paramtype static_website: ~azure.storage.blob.models.StaticWebsite
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "cors": cors,
                "defaultServiceVersion": default_service_version,
                "deleteRetentionPolicy": delete_retention_policy,
                "hourMetrics": hour_metrics,
                "logging": logging,
                "minuteMetrics": minute_metrics,
                "staticWebsite": static_website,
            }
            body = {k: v for k, v in body.items() if v is not None}
        _content = _get_element(body)

        _request = build_service_set_properties_request(
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_properties(self, *, timeout: Optional[int] = None, **kwargs: Any) -> _models.StorageServiceProperties:
        # pylint: disable=line-too-long
        """Retrieves properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: StorageServiceProperties. The StorageServiceProperties is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.StorageServiceProperties
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.StorageServiceProperties] = kwargs.pop("cls", None)

        _request = build_service_get_properties_request(
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.StorageServiceProperties, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_statistics(self, *, timeout: Optional[int] = None, **kwargs: Any) -> _models.StorageServiceStats:
        # pylint: disable=line-too-long
        """Retrieves statistics related to replication for the Blob service. It is only available on the
        secondary location endpoint when read-access geo-redundant replication is enabled for the
        storage account.

        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: StorageServiceStats. The StorageServiceStats is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.StorageServiceStats
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.StorageServiceStats] = kwargs.pop("cls", None)

        _request = build_service_get_statistics_request(
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.StorageServiceStats, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_containers_segment(
        self,
        *,
        prefix: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        timeout: Optional[int] = None,
        include: Optional[List[Union[str, _models.ListContainersIncludeType]]] = None,
        **kwargs: Any
    ) -> _models.ListContainersSegmentResponse:
        # pylint: disable=line-too-long
        """The List Containers Segment operation returns a list of the containers under the specified
        account.

        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword include: Include this parameter to specify that the container's metadata be returned
         as part of the response body. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.ListContainersIncludeType]
        :return: ListContainersSegmentResponse. The ListContainersSegmentResponse is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.ListContainersSegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.ListContainersSegmentResponse] = kwargs.pop("cls", None)

        _request = build_service_list_containers_segment_request(
            prefix=prefix,
            marker=marker,
            maxresults=maxresults,
            timeout=timeout,
            include=include,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.ListContainersSegmentResponse, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_user_delegation_key(
        self,
        body: ET.Element = _Unset,
        *,
        start: str = _Unset,
        expiry: str = _Unset,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.UserDelegationKey:
        # pylint: disable=line-too-long
        """Retrieves a user delegation key for the Blob service. This is only a valid operation when using
        bearer token authentication.

        :param body: Required.
        :type body: ET.Element
        :keyword start: The date-time the key is active. Required.
        :paramtype start: str
        :keyword expiry: The date-time the key expires. Required.
        :paramtype expiry: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: UserDelegationKey. The UserDelegationKey is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.UserDelegationKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.UserDelegationKey] = kwargs.pop("cls", None)

        if body is _Unset:
            if start is _Unset:
                raise TypeError("missing required argument: start")
            if expiry is _Unset:
                raise TypeError("missing required argument: expiry")
            body = {"expiry": expiry, "start": start}
            body = {k: v for k, v in body.items() if v is not None}
        _content = _get_element(body)

        _request = build_service_get_user_delegation_key_request(
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.UserDelegationKey, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_account_info(self, *, timeout: Optional[int] = None, **kwargs: Any) -> None:
        # pylint: disable=line-too-long
        """Returns the sku name and account kind.

        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_service_get_account_info_request(
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-is-hns-enabled"] = self._deserialize("bool", response.headers.get("x-ms-is-hns-enabled"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def submit_batch(
        self, body: bytes, *, content_length: int, timeout: Optional[int] = None, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        # pylint: disable=line-too-long
        """The Batch operation allows multiple API calls to be embedded into a single HTTP request.

        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        multipart_content_type: str = kwargs.pop(
            "multipart_content_type", _headers.pop("Content-Type", "multipart/mixed")
        )
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _content = body

        _request = build_service_submit_batch_request(
            content_length=content_length,
            timeout=timeout,
            multipart_content_type=multipart_content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def filter_blobs(
        self,
        *,
        timeout: Optional[int] = None,
        where: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.FilterBlobsIncludeItem]]] = None,
        **kwargs: Any
    ) -> _models.FilterBlobSegment:
        # pylint: disable=line-too-long
        """The Filter Blobs operation enables callers to list blobs across all containers whose tags match
        a given search expression.

        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword where: Filters the results to return only to return only blobs whose tags match the
         specified expression. Default value is None.
        :paramtype where: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.FilterBlobsIncludeItem]
        :return: FilterBlobSegment. The FilterBlobSegment is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.FilterBlobSegment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.FilterBlobSegment] = kwargs.pop("cls", None)

        _request = build_service_filter_blobs_request(
            timeout=timeout,
            where=where,
            marker=marker,
            maxresults=maxresults,
            include=include,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.FilterBlobSegment, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ContainerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`container` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def create(
        self,
        container_name: str,
        *,
        timeout: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        access: Optional[Union[str, _models.PublicAccessType]] = None,
        default_encryption_scope: Optional[str] = None,
        prevent_encryption_scope_override: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Creates a new container under the specified account. If the container with the same name
        already exists, the operation fails.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword access: The public access setting for the container. Known values are: "blob" and
         "container". Default value is None.
        :paramtype access: str or ~azure.storage.blob.models.PublicAccessType
        :keyword default_encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the
         default encryption scope to set on the container and use for all future writes. Default value
         is None.
        :paramtype default_encryption_scope: str
        :keyword prevent_encryption_scope_override: If a blob has a lease and the lease is of infinite
         duration then the value of this header is set to true, otherwise it is set to false. Default
         value is None.
        :paramtype prevent_encryption_scope_override: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_create_request(
            container_name=container_name,
            timeout=timeout,
            metadata=metadata,
            access=access,
            default_encryption_scope=default_encryption_scope,
            prevent_encryption_scope_override=prevent_encryption_scope_override,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_properties(
        self, container_name: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """returns all user-defined metadata and system properties for the specified container. The data
        returned does not include the container's list of blobs.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_get_properties_request(
            container_name=container_name,
            timeout=timeout,
            lease_id=lease_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-meta"] = self._deserialize("{str}", response.headers.get("x-ms-meta"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-lease-duration"] = self._deserialize("int", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["x-ms-blob-public-access"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-public-access")
        )
        response_headers["x-ms-has-immutability-policy"] = self._deserialize(
            "bool", response.headers.get("x-ms-has-immutability-policy")
        )
        response_headers["x-ms-has-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-has-legal-hold"))
        response_headers["x-ms-default-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-default-encryption-scope")
        )
        response_headers["x-ms-deny-encryption-scope-override"] = self._deserialize(
            "bool", response.headers.get("x-ms-deny-encryption-scope-override")
        )
        response_headers["x-ms-immutable-storage-with-versioning-enabled"] = self._deserialize(
            "bool", response.headers.get("x-ms-immutable-storage-with-versioning-enabled")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def delete(
        self,
        container_name: str,
        *,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """operation marks the specified container for deletion. The container and any blobs contained
        within it are later deleted during garbage collection.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_delete_request(
            container_name=container_name,
            timeout=timeout,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_metadata(
        self,
        container_name: str,
        *,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        if_modified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """operation sets one or more user-defined name-value pairs for the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_set_metadata_request(
            container_name=container_name,
            timeout=timeout,
            lease_id=lease_id,
            metadata=metadata,
            if_modified_since=if_modified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_access_policy(
        self, container_name: str, *, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
    ) -> List[_models.SignedIdentifier]:
        # pylint: disable=line-too-long
        """gets the permissions for the specified container. The permissions indicate whether container
        data may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: SignedIdentifier
        :rtype: ~azure.storage.blob.models.SignedIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[List[_models.SignedIdentifier]] = kwargs.pop("cls", None)

        _request = build_container_get_access_policy_request(
            container_name=container_name,
            timeout=timeout,
            lease_id=lease_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-blob-public-access"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-public-access")
        )
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(List[_models.SignedIdentifier], response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def set_access_policy(
        self,
        container_name: str,
        container_acl: List[_models.SignedIdentifier],
        *,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        access: Optional[Union[str, _models.PublicAccessType]] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """sets the permissions for the specified container. The permissions indicate whether blobs in a
        container may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param container_acl: The access control list for the container. Required.
        :type container_acl: ~azure.storage.blob.models.SignedIdentifier
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword access: The public access setting for the container. Known values are: "blob" and
         "container". Default value is None.
        :paramtype access: str or ~azure.storage.blob.models.PublicAccessType
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = _get_element(container_acl)

        _request = build_container_set_access_policy_request(
            container_name=container_name,
            timeout=timeout,
            lease_id=lease_id,
            access=access,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def restore(
        self,
        container_name: str,
        *,
        deleted_container_name: Optional[str] = None,
        deleted_container_version: Optional[str] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Restores a previously-deleted container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword deleted_container_name: Optional.  Version 2019-12-12 and later.  Specifies the name
         of the deleted container to restore. Default value is None.
        :paramtype deleted_container_name: str
        :keyword deleted_container_version: Optional.  Version 2019-12-12 and later.  Specifies the
         version of the deleted container to restore. Default value is None.
        :paramtype deleted_container_version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_restore_request(
            container_name=container_name,
            deleted_container_name=deleted_container_name,
            deleted_container_version=deleted_container_version,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def rename(
        self,
        container_name: str,
        *,
        source_container_name: str,
        source_lease_id: Optional[str] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Renames an existing container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword source_container_name: Required.  Specifies the name of the container to rename.
         Required.
        :paramtype source_container_name: str
        :keyword source_lease_id: A lease ID for the source path. If specified, the source path must
         have an active lease and the lease ID must match. Default value is None.
        :paramtype source_lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_rename_request(
            container_name=container_name,
            source_container_name=source_container_name,
            source_lease_id=source_lease_id,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def submit_batch(
        self, container_name: str, body: bytes, *, content_length: int, timeout: Optional[int] = None, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        # pylint: disable=line-too-long
        """The Batch operation allows multiple API calls to be embedded into a single HTTP request.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        multipart_content_type: str = kwargs.pop(
            "multipart_content_type", _headers.pop("Content-Type", "multipart/mixed")
        )
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _content = body

        _request = build_container_submit_batch_request(
            container_name=container_name,
            content_length=content_length,
            timeout=timeout,
            multipart_content_type=multipart_content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def filter_blobs(
        self,
        container_name: str,
        *,
        timeout: Optional[int] = None,
        where: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.FilterBlobsIncludeItem]]] = None,
        **kwargs: Any
    ) -> _models.FilterBlobSegment:
        # pylint: disable=line-too-long
        """The Filter Blobs operation enables callers to list blobs in a container whose tags match a
        given search expression.  Filter blobs searches within the given container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword where: Filters the results to return only to return only blobs whose tags match the
         specified expression. Default value is None.
        :paramtype where: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.FilterBlobsIncludeItem]
        :return: FilterBlobSegment. The FilterBlobSegment is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.FilterBlobSegment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.FilterBlobSegment] = kwargs.pop("cls", None)

        _request = build_container_filter_blobs_request(
            container_name=container_name,
            timeout=timeout,
            where=where,
            marker=marker,
            maxresults=maxresults,
            include=include,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.FilterBlobSegment, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def acquire_lease(
        self,
        container_name: str,
        *,
        duration: Optional[int] = None,
        timeout: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change. Default value is None.
        :paramtype duration: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_acquire_lease_request(
            container_name=container_name,
            duration=duration,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def release_lease(
        self,
        container_name: str,
        *,
        lease_id: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_release_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def renew_lease(
        self,
        container_name: str,
        *,
        lease_id: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_renew_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def break_lease(
        self,
        container_name: str,
        *,
        timeout: Optional[int] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        break_period: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :keyword break_period: For a break operation, proposed duration the lease should continue
         before it is broken, in seconds, between 0 and 60. This break period is only used if it is
         shorter than the time remaining on the lease. If longer, the time remaining on the lease is
         used. A new lease will not be available before the break period has expired, but the lease may
         be held for longer than the break period. If this header does not appear with a break
         operation, a fixed-duration lease breaks after the remaining lease period elapses, and an
         infinite lease breaks immediately. Default value is None.
        :paramtype break_period: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_break_lease_request(
            container_name=container_name,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            break_period=break_period,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-time"] = self._deserialize("int", response.headers.get("x-ms-lease-time"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def change_lease(
        self,
        container_name: str,
        *,
        lease_id: str,
        proposed_lease_id: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[str] = None,
        if_unmodified_since: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword proposed_lease_id: Required.  The proposed lease ID for the container. Required.
        :paramtype proposed_lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: str
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_change_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            proposed_lease_id=proposed_lease_id,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def list_blob_flat_segment(
        self,
        container_name: str,
        *,
        prefix: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.ListBlobsIncludeItem]]] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.ListBlobsFlatSegmentResponse:
        # pylint: disable=line-too-long
        """[Update] The List Blobs operation returns a list of the blobs under the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.ListBlobsIncludeItem]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: ListBlobsFlatSegmentResponse. The ListBlobsFlatSegmentResponse is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.ListBlobsFlatSegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.ListBlobsFlatSegmentResponse] = kwargs.pop("cls", None)

        _request = build_container_list_blob_flat_segment_request(
            container_name=container_name,
            prefix=prefix,
            marker=marker,
            maxresults=maxresults,
            include=include,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.ListBlobsFlatSegmentResponse, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_blob_hierarchy_segment(
        self,
        container_name: str,
        *,
        delimiter: str,
        prefix: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.ListBlobsIncludeItem]]] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.ListBlobsHierarchySegmentResponse:
        # pylint: disable=line-too-long
        """[Update] The List Blobs operation returns a list of the blobs under the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword delimiter: When the request includes this parameter, the operation returns a
         BlobPrefix element in the response body that acts as a placeholder for all blobs whose names
         begin with the same substring up to the appearance of the delimiter character. The delimiter
         may be a single character or a string. Required.
        :paramtype delimiter: str
        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.ListBlobsIncludeItem]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: ListBlobsHierarchySegmentResponse. The ListBlobsHierarchySegmentResponse is compatible
         with MutableMapping
        :rtype: ~azure.storage.blob.models.ListBlobsHierarchySegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.ListBlobsHierarchySegmentResponse] = kwargs.pop("cls", None)

        _request = build_container_list_blob_hierarchy_segment_request(
            container_name=container_name,
            delimiter=delimiter,
            prefix=prefix,
            marker=marker,
            maxresults=maxresults,
            include=include,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.ListBlobsHierarchySegmentResponse, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_account_info(self, container_name: str, *, timeout: Optional[int] = None, **kwargs: Any) -> None:
        # pylint: disable=line-too-long
        """Returns the sku name and account kind.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_get_account_info_request(
            container_name=container_name,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-is-hns-enabled"] = self._deserialize("bool", response.headers.get("x-ms-is-hns-enabled"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class BlobOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`blob` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def download(
        self,
        container_name: str,
        blob: str,
        *,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        range_get_content_md5: Optional[bool] = None,
        range_get_content_crc64: Optional[bool] = None,
        structured_body_type: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        if_tags: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        # pylint: disable=line-too-long
        """The Download operation reads or downloads a blob from the system, including its metadata and
        properties. You can also call Download to read a snapshot.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword range_get_content_md5: When set to true and specified together with the Range, the
         service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB
         in size. Default value is None.
        :paramtype range_get_content_md5: bool
        :keyword range_get_content_crc64: Optional.  When this header is set to true and specified
         together with the Range header, the service returns the CRC64 hash for the range, as long as
         the range is less than or equal to 4 MB in size. Default value is None.
        :paramtype range_get_content_crc64: bool
        :keyword structured_body_type: Specifies the response content should be returned as a
         structured message and specifies the message schema version and properties. Default value is
         None.
        :paramtype structured_body_type: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_blob_download_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            version_id=version_id,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            range_get_content_md5=range_get_content_md5,
            range_get_content_crc64=range_get_content_crc64,
            structured_body_type=structured_body_type,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_tags=if_tags,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            etag=etag,
            match_condition=match_condition,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["x-ms-meta"] = self._deserialize("{str}", response.headers.get("x-ms-meta"))
            response_headers["x-ms-or"] = self._deserialize("{str}", response.headers.get("x-ms-or"))
            response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
            response_headers["x-ms-creation-time"] = self._deserialize(
                "str", response.headers.get("x-ms-creation-time")
            )
            response_headers["x-ms-or-policy-id"] = self._deserialize("str", response.headers.get("x-ms-or-policy-id"))
            response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
            response_headers["Content-Range"] = self._deserialize("str", response.headers.get("Content-Range"))
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
            response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
            response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
            response_headers["Content-Disposition"] = self._deserialize(
                "str", response.headers.get("Content-Disposition")
            )
            response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
            response_headers["x-ms-blob-sequence-number"] = self._deserialize(
                "int", response.headers.get("x-ms-blob-sequence-number")
            )
            response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
            response_headers["x-ms-copy-completion-time"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-completion-time")
            )
            response_headers["x-ms-copy-status-description"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-status-description")
            )
            response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
            response_headers["x-ms-copy-progress"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-progress")
            )
            response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
            response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
            response_headers["x-ms-lease-duration"] = self._deserialize(
                "int", response.headers.get("x-ms-lease-duration")
            )
            response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
            response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
            response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
            response_headers["x-ms-is-current-version"] = self._deserialize(
                "bool", response.headers.get("x-ms-is-current-version")
            )
            response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
            response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
            response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
                "int", response.headers.get("x-ms-blob-committed-block-count")
            )
            response_headers["x-ms-request-server-encrypted"] = self._deserialize(
                "bool", response.headers.get("x-ms-request-server-encrypted")
            )
            response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
                "str", response.headers.get("x-ms-encryption-key-sha256")
            )
            response_headers["x-ms-encryption-scope"] = self._deserialize(
                "str", response.headers.get("x-ms-encryption-scope")
            )
            response_headers["x-ms-blob-content-md5"] = self._deserialize(
                "bytearray", response.headers.get("x-ms-blob-content-md5")
            )
            response_headers["x-ms-tag-count"] = self._deserialize("int", response.headers.get("x-ms-tag-count"))
            response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
            response_headers["x-ms-last-access-time"] = self._deserialize(
                "str", response.headers.get("x-ms-last-access-time")
            )
            response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
                "str", response.headers.get("x-ms-immutability-policy-until-date")
            )
            response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
                "str", response.headers.get("x-ms-immutability-policy-mode")
            )
            response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
            response_headers["x-ms-structured-body"] = self._deserialize(
                "str", response.headers.get("x-ms-structured-body")
            )
            response_headers["x-ms-structured-content-length"] = self._deserialize(
                "int", response.headers.get("x-ms-structured-content-length")
            )
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if response.status_code == 206:
            response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
            response_headers["x-ms-client-request-id"] = self._deserialize(
                "str", response.headers.get("x-ms-client-request-id")
            )
            response_headers["x-ms-meta"] = self._deserialize("{str}", response.headers.get("x-ms-meta"))
            response_headers["x-ms-or"] = self._deserialize("{str}", response.headers.get("x-ms-or"))
            response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
            response_headers["x-ms-creation-time"] = self._deserialize(
                "str", response.headers.get("x-ms-creation-time")
            )
            response_headers["x-ms-or-policy-id"] = self._deserialize("str", response.headers.get("x-ms-or-policy-id"))
            response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
            response_headers["Content-Range"] = self._deserialize("str", response.headers.get("Content-Range"))
            response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
            response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
            response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
            response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
            response_headers["Content-Disposition"] = self._deserialize(
                "str", response.headers.get("Content-Disposition")
            )
            response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
            response_headers["x-ms-blob-sequence-number"] = self._deserialize(
                "int", response.headers.get("x-ms-blob-sequence-number")
            )
            response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
            response_headers["x-ms-content-crc64"] = self._deserialize(
                "str", response.headers.get("x-ms-content-crc64")
            )
            response_headers["x-ms-copy-completion-time"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-completion-time")
            )
            response_headers["x-ms-copy-status-description"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-status-description")
            )
            response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
            response_headers["x-ms-copy-progress"] = self._deserialize(
                "str", response.headers.get("x-ms-copy-progress")
            )
            response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
            response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
            response_headers["x-ms-lease-duration"] = self._deserialize(
                "int", response.headers.get("x-ms-lease-duration")
            )
            response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
            response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
            response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
            response_headers["x-ms-is-current-version"] = self._deserialize(
                "bool", response.headers.get("x-ms-is-current-version")
            )
            response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
            response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
            response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
                "int", response.headers.get("x-ms-blob-committed-block-count")
            )
            response_headers["x-ms-request-server-encrypted"] = self._deserialize(
                "bool", response.headers.get("x-ms-request-server-encrypted")
            )
            response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
                "str", response.headers.get("x-ms-encryption-key-sha256")
            )
            response_headers["x-ms-encryption-scope"] = self._deserialize(
                "str", response.headers.get("x-ms-encryption-scope")
            )
            response_headers["x-ms-blob-content-md5"] = self._deserialize(
                "bytearray", response.headers.get("x-ms-blob-content-md5")
            )
            response_headers["x-ms-tag-count"] = self._deserialize("int", response.headers.get("x-ms-tag-count"))
            response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
            response_headers["x-ms-last-access-time"] = self._deserialize(
                "str", response.headers.get("x-ms-last-access-time")
            )
            response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
                "str", response.headers.get("x-ms-immutability-policy-until-date")
            )
            response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
                "str", response.headers.get("x-ms-immutability-policy-mode")
            )
            response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
            response_headers["x-ms-structured-body"] = self._deserialize(
                "str", response.headers.get("x-ms-structured-body")
            )
            response_headers["x-ms-structured-content-length"] = self._deserialize(
                "int", response.headers.get("x-ms-structured-content-length")
            )
            response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_properties(
        self,
        container_name: str,
        blob: str,
        *,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bool:
        # pylint: disable=line-too-long
        """The Get Properties operation returns all user-defined metadata, standard HTTP properties, and
        system properties for the blob. It does not return the content of the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_get_properties_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            version_id=version_id,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-meta"] = self._deserialize("{str}", response.headers.get("x-ms-meta"))
        response_headers["x-ms-or"] = self._deserialize("{str}", response.headers.get("x-ms-or"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-creation-time"] = self._deserialize("str", response.headers.get("x-ms-creation-time"))
        response_headers["x-ms-or-policy-id"] = self._deserialize("str", response.headers.get("x-ms-or-policy-id"))
        response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
        response_headers["x-ms-copy-completion-time"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-completion-time")
        )
        response_headers["x-ms-copy-status-description"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-status-description")
        )
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-progress"] = self._deserialize("str", response.headers.get("x-ms-copy-progress"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
        response_headers["x-ms-incremental-copy"] = self._deserialize(
            "bool", response.headers.get("x-ms-incremental-copy")
        )
        response_headers["x-ms-copy-destination-snapshot"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-destination-snapshot")
        )
        response_headers["x-ms-lease-duration"] = self._deserialize("int", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
        response_headers["Content-Disposition"] = self._deserialize("str", response.headers.get("Content-Disposition"))
        response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
        response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-access-tier"] = self._deserialize("str", response.headers.get("x-ms-access-tier"))
        response_headers["x-ms-access-tier-inferred"] = self._deserialize(
            "bool", response.headers.get("x-ms-access-tier-inferred")
        )
        response_headers["x-ms-archive-status"] = self._deserialize("str", response.headers.get("x-ms-archive-status"))
        response_headers["x-ms-access-tier-change-time"] = self._deserialize(
            "str", response.headers.get("x-ms-access-tier-change-time")
        )
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["x-ms-is-current-version"] = self._deserialize(
            "bool", response.headers.get("x-ms-is-current-version")
        )
        response_headers["x-ms-tag-count"] = self._deserialize("int", response.headers.get("x-ms-tag-count"))
        response_headers["x-ms-expiry-time"] = self._deserialize("str", response.headers.get("x-ms-expiry-time"))
        response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
        response_headers["x-ms-rehydrate-priority"] = self._deserialize(
            "str", response.headers.get("x-ms-rehydrate-priority")
        )
        response_headers["x-ms-last-access-time"] = self._deserialize(
            "str", response.headers.get("x-ms-last-access-time")
        )
        response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-until-date")
        )
        response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-mode")
        )
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore
        return 200 <= response.status_code <= 299

    @distributed_trace_async
    async def delete(
        self,
        container_name: str,
        blob: str,
        *,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_delete_type: Optional[Union[str, _models.BlobDeleteType]] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
        permanently removed from the storage account. If the storage account's soft delete feature is
        enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
        immediately. However, the blob service retains the blob or snapshot for the number of days
        specified by the DeleteRetentionPolicy section of [Storage service properties]
        (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's
        data is permanently removed from the storage account. Note that you continue to be charged for
        the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and
        specify the \\"include=deleted\\" query parameter to discover which blobs and snapshots have
        been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All
        other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status
        code of 404 (ResourceNotFound).

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword delete_snapshots: Required if the blob has associated snapshots. Specify one of the
         following two options: include: Delete the base blob and all of its snapshots. only: Delete
         only the blob's snapshots and not the blob itself. Known values are: "only" and "include".
         Default value is None.
        :paramtype delete_snapshots: str or ~azure.storage.blob.models.DeleteSnapshotsOptionType
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_delete_type: Optional.  Only possible value is 'permanent', which specifies to
         permanently delete a blob if blob soft delete is enabled. "Permanent" Default value is None.
        :paramtype blob_delete_type: str or ~azure.storage.blob.models.BlobDeleteType
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_delete_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            version_id=version_id,
            timeout=timeout,
            lease_id=lease_id,
            delete_snapshots=delete_snapshots,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_delete_type=blob_delete_type,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def undelete(self, container_name: str, blob: str, *, timeout: Optional[int] = None, **kwargs: Any) -> None:
        # pylint: disable=line-too-long
        """Undelete a blob that was previously soft deleted.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_undelete_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_expiry(
        self,
        container_name: str,
        blob: str,
        *,
        expiry_options: Union[str, _models.BlobExpiryOptions],
        timeout: Optional[int] = None,
        expires_on: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Set the expiration time of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword expiry_options: Required. Indicates mode of the expiry time. Known values are:
         "NeverExpire", "RelativeToCreation", "RelativeToNow", and "Absolute". Required.
        :paramtype expiry_options: str or ~azure.storage.blob.models.BlobExpiryOptions
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword expires_on: The time this blob will expire. Default value is None.
        :paramtype expires_on: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_expiry_request(
            container_name=container_name,
            blob=blob,
            expiry_options=expiry_options,
            timeout=timeout,
            expires_on=expires_on,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_http_headers(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set HTTP Headers operation sets system properties on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_http_headers_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            blob_cache_control=blob_cache_control,
            blob_content_type=blob_content_type,
            blob_content_md5=blob_content_md5,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_immutability_policy(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        if_unmodified_since: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Set the immutability policy of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_immutability_policy_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            if_unmodified_since=if_unmodified_since,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            snapshot=snapshot,
            version_id=version_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-until-date")
        )
        response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-mode")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def delete_immutability_policy(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Delete Immutability Policy operation deletes the immutability policy on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_delete_immutability_policy_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            snapshot=snapshot,
            version_id=version_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_legal_hold(
        self,
        container_name: str,
        blob: str,
        *,
        legal_hold: bool,
        timeout: Optional[int] = None,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Legal Hold operation sets a legal hold on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword legal_hold: Required.  Specifies the legal hold status to set on the blob. Required.
        :paramtype legal_hold: bool
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_legal_hold_request(
            container_name=container_name,
            blob=blob,
            legal_hold=legal_hold,
            timeout=timeout,
            snapshot=snapshot,
            version_id=version_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_metadata(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Metadata operation sets user-defined metadata for the specified blob as one or more
        name-value pairs.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_metadata_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            metadata=metadata,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def acquire_lease(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        duration: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change. Default value is None.
        :paramtype duration: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_acquire_lease_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            duration=duration,
            proposed_lease_id=proposed_lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def release_lease(
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        timeout: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_release_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            timeout=timeout,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def renew_lease(
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        timeout: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_renew_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            timeout=timeout,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def change_lease(
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        timeout: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_change_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def break_lease(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        break_period: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword break_period: For a break operation, proposed duration the lease should continue
         before it is broken, in seconds, between 0 and 60. This break period is only used if it is
         shorter than the time remaining on the lease. If longer, the time remaining on the lease is
         used. A new lease will not be available before the break period has expired, but the lease may
         be held for longer than the break period. If this header does not appear with a break
         operation, a fixed-duration lease breaks after the remaining lease period elapses, and an
         infinite lease breaks immediately. Default value is None.
        :paramtype break_period: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_break_lease_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            break_period=break_period,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-lease-time"] = self._deserialize("int", response.headers.get("x-ms-lease-time"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def create_snapshot(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create Snapshot operation creates a read-only snapshot of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_create_snapshot_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            metadata=metadata,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-snapshot"] = self._deserialize("str", response.headers.get("x-ms-snapshot"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def start_copy_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        timeout: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        source_if_tags: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        seal_blob: Optional[bool] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Start Copy From URL operation copies a blob or an internet resource to a new blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword tier: The tier to be set on the blob. Known values are: "P4", "P6", "P10", "P15",
         "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium", and
         "Cold". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword rehydrate_priority: If an object is in rehydrate pending state then this header is
         returned with priority of rehydrate. Valid values are High and Standard. Known values are:
         "High" and "Standard". Default value is None.
        :paramtype rehydrate_priority: str or ~azure.storage.blob.models.RehydratePriority
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword source_if_tags: Specify a SQL where clause on blob tags to operate only on blobs with
         a matching value. Default value is None.
        :paramtype source_if_tags: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword seal_blob: Overrides the sealed state of the destination blob.  Service version
         2019-12-12 and newer. Default value is None.
        :paramtype seal_blob: bool
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_start_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            timeout=timeout,
            metadata=metadata,
            tier=tier,
            rehydrate_priority=rehydrate_priority,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            source_if_tags=source_if_tags,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            blob_tags_string=blob_tags_string,
            seal_blob=seal_blob,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def copy_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        timeout: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        copy_source_authorization: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        copy_source_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Copy From URL operation copies a blob or an internet resource to a new blob. It will not
        return a response until the copy is complete.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword tier: The tier to be set on the blob. Known values are: "P4", "P6", "P10", "P15",
         "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium", and
         "Cold". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword copy_source_tags: Optional, default 'replace'.  Indicates if source tags should be
         copied or replaced with the tags specified by x-ms-tags. Default value is None.
        :paramtype copy_source_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            timeout=timeout,
            metadata=metadata,
            tier=tier,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            source_content_md5=source_content_md5,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            copy_source_authorization=copy_source_authorization,
            encryption_scope=encryption_scope,
            copy_source_tags=copy_source_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def abort_copy_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        copy_id: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a
        destination blob with zero length and full metadata.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_id: The copy identifier provided in the x-ms-copy-id header of the original Copy
         Blob operation. Required.
        :paramtype copy_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_abort_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_id=copy_id,
            timeout=timeout,
            lease_id=lease_id,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def set_tier(
        self,
        container_name: str,
        blob: str,
        *,
        tier: Union[str, _models.AccessTier],
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        timeout: Optional[int] = None,
        rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tier operation sets the tier on a block blob. The operation is allowed on a page blob
        or block blob, but not on an append blob. A block blob's tier determines Hot/Cool/Archive
        storage type. This operation does not update the blob's ETag.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword tier: Indicates the tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium",
         and "Cold". Required.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword rehydrate_priority: If an object is in rehydrate pending state then this header is
         returned with priority of rehydrate. Valid values are High and Standard. Known values are:
         "High" and "Standard". Default value is None.
        :paramtype rehydrate_priority: str or ~azure.storage.blob.models.RehydratePriority
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_tier_request(
            container_name=container_name,
            blob=blob,
            tier=tier,
            snapshot=snapshot,
            version_id=version_id,
            timeout=timeout,
            rehydrate_priority=rehydrate_priority,
            lease_id=lease_id,
            if_tags=if_tags,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_account_info(
        self, container_name: str, blob: str, *, timeout: Optional[int] = None, **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Returns the sku name and account kind.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_get_account_info_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-is-hns-enabled"] = self._deserialize("bool", response.headers.get("x-ms-is-hns-enabled"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        container_name: str,
        blob: str,
        query_request: _models.QueryRequest,
        *,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> AsyncIterator[bytes]:
        # pylint: disable=line-too-long
        """The Query operation enables users to select/project on blob data by providing simple query
        expressions.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param query_request: The query request. Required.
        :type query_request: ~azure.storage.blob.models.QueryRequest
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: AsyncIterator[bytes]
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _content = _get_element(query_request)

        _request = build_blob_query_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-meta"] = self._deserialize("{str}", response.headers.get("x-ms-meta"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
        response_headers["Content-Range"] = self._deserialize("str", response.headers.get("Content-Range"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
        response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
        response_headers["Content-Disposition"] = self._deserialize("str", response.headers.get("Content-Disposition"))
        response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-copy-completion-time"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-completion-time")
        )
        response_headers["x-ms-copy-status-description"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-status-description")
        )
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-progress"] = self._deserialize("str", response.headers.get("x-ms-copy-progress"))
        response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-lease-duration"] = self._deserialize("int", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-blob-content-md5"] = self._deserialize(
            "bytearray", response.headers.get("x-ms-blob-content-md5")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_tags(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        snapshot: Optional[str] = None,
        version_id: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BlobTags:
        # pylint: disable=line-too-long
        """The Get Blob Tags operation enables users to get tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: BlobTags. The BlobTags is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.BlobTags
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.BlobTags] = kwargs.pop("cls", None)

        _request = build_blob_get_tags_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            snapshot=snapshot,
            version_id=version_id,
            lease_id=lease_id,
            if_tags=if_tags,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.BlobTags, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def set_tags(
        self,
        container_name: str,
        blob: str,
        tags: _models.BlobTags,
        *,
        timeout: Optional[int] = None,
        version_id: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tags operation enables users to set tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param tags: The blob tags. Required.
        :type tags: ~azure.storage.blob.models.BlobTags
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Default value is None.
        :paramtype version_id: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = _get_element(tags)

        _request = build_blob_set_tags_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            version_id=version_id,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            if_tags=if_tags,
            lease_id=lease_id,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class PageBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`page_blob` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def create(
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        blob_content_length: int,
        metadata: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None,
        tier: Optional[Union[str, _models.PremiumPageBlobAccessTier]] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_sequence_number: Optional[int] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create operation creates a new page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword blob_content_length: This header specifies the maximum size for the page blob, up to 1
         TB. The page blob size must be aligned to a 512-byte boundary. Required.
        :paramtype blob_content_length: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword tier: Optional. Indicates the tier to be set on the page blob. Known values are: "P4",
         "P6", "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", and "P80". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.PremiumPageBlobAccessTier
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_sequence_number: Optional.  The sequence number is a user-controlled property
         that you can use to track requests. The value of the sequence number must be between 0 and 2^63
         - 1. The default value is 0. Default value is None.
        :paramtype blob_sequence_number: int
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_create_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            blob_content_length=blob_content_length,
            metadata=metadata,
            timeout=timeout,
            tier=tier,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_sequence_number=blob_sequence_number,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def upload_pages(
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        content_length: int,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        structured_body_type: Optional[str] = None,
        structured_content_length: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Pages operation writes a range of pages to a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword structured_body_type: Required if the request body is a structured message. Specifies
         the message schema version and properties. Default value is None.
        :paramtype structured_body_type: str
        :keyword structured_content_length: Required if the request body is a structured message.
         Specifies the length of the blob/file content inside the message body. Will always be smaller
         than Content-Length. Default value is None.
        :paramtype structured_content_length: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = body

        _request = build_page_blob_upload_pages_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            structured_body_type=structured_body_type,
            structured_content_length=structured_content_length,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-structured-body"] = self._deserialize(
            "str", response.headers.get("x-ms-structured-body")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def clear_pages(
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Clear Pages operation clears a range of pages from a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_clear_pages_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def upload_pages_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        source_url: str,
        source_range: str,
        content_length: int,
        range: str,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[bytes] = None,
        timeout: Optional[int] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Pages operation writes a range of pages to a page blob where the contents are read
        from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword source_range: Bytes of source data in the specified range. The length of this range
         should match the ContentLength header and x-ms-range/Range destination range header. Required.
        :paramtype source_range: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword range: Bytes of source data in the specified range. The length of this range should
         match the ContentLength header and x-ms-range/Range destination range header. Required.
        :paramtype range: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: bytes
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_upload_pages_from_url_request(
            container_name=container_name,
            blob=blob,
            source_url=source_url,
            source_range=source_range,
            content_length=content_length,
            range=range,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            timeout=timeout,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            lease_id=lease_id,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            copy_source_authorization=copy_source_authorization,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_page_ranges(
        self,
        container_name: str,
        blob: str,
        *,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.PageList:
        # pylint: disable=line-too-long
        """The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot
        of a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: PageList. The PageList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.PageList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.PageList] = kwargs.pop("cls", None)

        _request = build_page_blob_get_page_ranges_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            marker=marker,
            maxresults=maxresults,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.PageList, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_page_ranges_diff(
        self,
        container_name: str,
        blob: str,
        *,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        prevsnapshot: Optional[str] = None,
        prev_snapshot_url: Optional[str] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.PageList:
        # pylint: disable=line-too-long
        """The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob or
        snapshot of a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword prevsnapshot: Optional in version 2015-07-08 and newer. The prevsnapshot parameter is
         a DateTime value that specifies that the response will contain only pages that were changed
         between target blob and previous snapshot. Changed pages include both updated and cleared
         pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is
         the older of the two. Note that incremental snapshots are currently supported only for blobs
         created on or after January 1, 2016. Default value is None.
        :paramtype prevsnapshot: str
        :keyword prev_snapshot_url: Optional. This header is only supported in service versions
         2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The
         response will only contain pages that were changed between the target blob and its previous
         snapshot. Default value is None.
        :paramtype prev_snapshot_url: str
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: PageList. The PageList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.PageList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.PageList] = kwargs.pop("cls", None)

        _request = build_page_blob_get_page_ranges_diff_request(
            container_name=container_name,
            blob=blob,
            snapshot=snapshot,
            timeout=timeout,
            prevsnapshot=prevsnapshot,
            prev_snapshot_url=prev_snapshot_url,
            range=range,
            lease_id=lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            marker=marker,
            maxresults=maxresults,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.PageList, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def resize(
        self,
        container_name: str,
        blob: str,
        *,
        blob_content_length: int,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Resize operation increases the size of the page blob to the specified size.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword blob_content_length: This header specifies the maximum size for the page blob, up to 1
         TB. The page blob size must be aligned to a 512-byte boundary. Required.
        :paramtype blob_content_length: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_resize_request(
            container_name=container_name,
            blob=blob,
            blob_content_length=blob_content_length,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def update_sequence_number(
        self,
        container_name: str,
        blob: str,
        *,
        sequence_number_action: Union[str, _models.SequenceNumberActionType],
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_sequence_number: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Update Sequence Number operation sets the blob's sequence number. The operation will fail
        if the specified sequence number is less than the current sequence number of the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword sequence_number_action: Required if the x-ms-blob-sequence-number header is set for
         the request. This property applies to page blobs only. This property indicates how the service
         should modify the blob's sequence number. Known values are: "increment", "max", and "update".
         Required.
        :paramtype sequence_number_action: str or ~azure.storage.blob.models.SequenceNumberActionType
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_sequence_number: Set for page blobs only. The sequence number is a
         user-controlled value that you can use to track requests. The value of the sequence number must
         be between 0 and 2^63 - 1. Default value is None.
        :paramtype blob_sequence_number: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_update_sequence_number_request(
            container_name=container_name,
            blob=blob,
            sequence_number_action=sequence_number_action,
            timeout=timeout,
            lease_id=lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_sequence_number=blob_sequence_number,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def copy_incremental(
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        timeout: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Copy Incremental operation copies a snapshot of the source page blob to a destination page
        blob. The snapshot is copied such that only the differential changes between the previously
        copied snapshot are transferred to the destination. The copied snapshots are complete copies of
        the original snapshot and can be read or copied from as usual. This API is supported since REST
        version 2016-05-31.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_copy_incremental_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            timeout=timeout,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class AppendBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`append_blob` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def create(
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        metadata: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create operation creates a new append blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_create_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            metadata=metadata,
            timeout=timeout,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def append_block(
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        content_length: int,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        lease_id: Optional[str] = None,
        max_size: Optional[int] = None,
        append_position: Optional[int] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        structured_body_type: Optional[str] = None,
        structured_content_length: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Append Block operation commits a new block of data to the end of an append blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword max_size: Optional conditional header. The max length in bytes permitted for the
         append blob. If the Append Block operation would cause the blob to exceed that limit or if the
         blob size is already greater than the value specified in this header, the request will fail
         with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed). Default
         value is None.
        :paramtype max_size: int
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Default value
         is None.
        :paramtype append_position: int
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword structured_body_type: Required if the request body is a structured message. Specifies
         the message schema version and properties. Default value is None.
        :paramtype structured_body_type: str
        :keyword structured_content_length: Required if the request body is a structured message.
         Specifies the length of the blob/file content inside the message body. Will always be smaller
         than Content-Length. Default value is None.
        :paramtype structured_content_length: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = body

        _request = build_append_blob_append_block_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            lease_id=lease_id,
            max_size=max_size,
            append_position=append_position,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            structured_body_type=structured_body_type,
            structured_content_length=structured_content_length,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-blob-append-offset"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-append-offset")
        )
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-structured-body"] = self._deserialize(
            "str", response.headers.get("x-ms-structured-body")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def append_block_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        source_url: str,
        content_length: int,
        source_range: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[bytes] = None,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        lease_id: Optional[str] = None,
        max_size: Optional[int] = None,
        append_position: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Append Block From URL operation creates a new block to be committed as part of an append
        blob where the contents are read from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword source_range: Bytes of source data in the specified range. Default value is None.
        :paramtype source_range: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: bytes
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword max_size: Optional conditional header. The max length in bytes permitted for the
         append blob. If the Append Block operation would cause the blob to exceed that limit or if the
         blob size is already greater than the value specified in this header, the request will fail
         with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed). Default
         value is None.
        :paramtype max_size: int
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Default value
         is None.
        :paramtype append_position: int
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_append_block_from_url_request(
            container_name=container_name,
            blob=blob,
            source_url=source_url,
            content_length=content_length,
            source_range=source_range,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            lease_id=lease_id,
            max_size=max_size,
            append_position=append_position,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            copy_source_authorization=copy_source_authorization,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-blob-append-offset"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-append-offset")
        )
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def seal(
        self,
        container_name: str,
        blob: str,
        *,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        append_position: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Seal operation seals the Append Blob to make it read-only. Seal is supported only on
        version 2019-12-12 version or later.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Default value
         is None.
        :paramtype append_position: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_seal_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            lease_id=lease_id,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            append_position=append_position,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class BlockBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.aio.BlobClient`'s
        :attr:`block_blob` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def upload(
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        content_length: int,
        metadata: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        transactional_content_crc64: Optional[str] = None,
        structured_body_type: Optional[str] = None,
        structured_content_length: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Block Blob operation updates the content of an existing block blob. Updating an
        existing block blob overwrites any existing metadata on the blob. Partial updates are not
        supported with Put Blob; the content of the existing blob is overwritten with the content of
        the new blob. To perform a partial update of the content of a block blob, use the Put Block
        List operation.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: The tier to be set on the blob. Known values are: "P4", "P6", "P10", "P15",
         "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium", and
         "Cold". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword structured_body_type: Required if the request body is a structured message. Specifies
         the message schema version and properties. Default value is None.
        :paramtype structured_body_type: str
        :keyword structured_content_length: Required if the request body is a structured message.
         Specifies the length of the blob/file content inside the message body. Will always be smaller
         than Content-Length. Default value is None.
        :paramtype structured_content_length: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = body

        _request = build_block_blob_upload_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            metadata=metadata,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            transactional_content_crc64=transactional_content_crc64,
            structured_body_type=structured_body_type,
            structured_content_length=structured_content_length,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-structured-body"] = self._deserialize(
            "str", response.headers.get("x-ms-structured-body")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def put_blob_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        copy_source: str,
        metadata: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        source_if_tags: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        copy_source_blob_properties: Optional[bool] = None,
        copy_source_authorization: Optional[str] = None,
        copy_source_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Put Blob from URL operation creates a new Block Blob where the contents of the blob are
        read from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial
        updates are not supported with Put Blob from URL; the content of an existing blob is
        overwritten with the content of the new blob.  To perform partial updates to a block blobs
        contents using a source URL, use the Put Block from URL API in conjunction with Put Block List.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: The tier to be set on the blob. Known values are: "P4", "P6", "P10", "P15",
         "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium", and
         "Cold". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword source_if_tags: Specify a SQL where clause on blob tags to operate only on blobs with
         a matching value. Default value is None.
        :paramtype source_if_tags: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword copy_source_blob_properties: Optional, default is true.  Indicates if properties from
         the source blob should be copied. Default value is None.
        :paramtype copy_source_blob_properties: bool
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword copy_source_tags: Optional, default 'replace'.  Indicates if source tags should be
         copied or replaced with the tags specified by x-ms-tags. Default value is None.
        :paramtype copy_source_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_block_blob_put_blob_from_url_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            copy_source=copy_source,
            metadata=metadata,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            source_if_tags=source_if_tags,
            source_content_md5=source_content_md5,
            blob_tags_string=blob_tags_string,
            copy_source_blob_properties=copy_source_blob_properties,
            copy_source_authorization=copy_source_authorization,
            copy_source_tags=copy_source_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def stage_block(
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        block_id: str,
        content_length: int,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        structured_body_type: Optional[str] = None,
        structured_content_length: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Stage Block operation creates a new block to be committed as part of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword block_id: A valid Base64 string value that identifies the block. Prior to encoding,
         the string must be less than or equal to 64 bytes in size. For a given blob, the length of the
         value specified for the blockid parameter must be the same size for each block. Required.
        :paramtype block_id: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword structured_body_type: Required if the request body is a structured message. Specifies
         the message schema version and properties. Default value is None.
        :paramtype structured_body_type: str
        :keyword structured_content_length: Required if the request body is a structured message.
         Specifies the length of the blob/file content inside the message body. Will always be smaller
         than Content-Length. Default value is None.
        :paramtype structured_content_length: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = body

        _request = build_block_blob_stage_block_request(
            container_name=container_name,
            blob=blob,
            block_id=block_id,
            content_length=content_length,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            structured_body_type=structured_body_type,
            structured_content_length=structured_content_length,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-structured-body"] = self._deserialize(
            "str", response.headers.get("x-ms-structured-body")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def stage_block_from_url(
        self,
        container_name: str,
        blob: str,
        *,
        block_id: str,
        content_length: int,
        source_url: str,
        source_range: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[bytes] = None,
        timeout: Optional[int] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        lease_id: Optional[str] = None,
        source_if_modified_since: Optional[str] = None,
        source_if_unmodified_since: Optional[str] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Stage Block From URL operation creates a new block to be committed as part of a blob where
        the contents are read from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword block_id: A valid Base64 string value that identifies the block. Prior to encoding,
         the string must be less than or equal to 64 bytes in size. For a given blob, the length of the
         value specified for the blockid parameter must be the same size for each block. Required.
        :paramtype block_id: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword source_range: Bytes of source data in the specified range. Default value is None.
        :paramtype source_range: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: bytes
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: str
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: str
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_block_blob_stage_block_from_url_request(
            container_name=container_name,
            blob=blob,
            block_id=block_id,
            content_length=content_length,
            source_url=source_url,
            source_range=source_range,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            timeout=timeout,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            lease_id=lease_id,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            copy_source_authorization=copy_source_authorization,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def commit_block_list(
        self,
        container_name: str,
        blob: str,
        blocks: _models.BlockLookupList,
        *,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[bytes] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[Union[str, _models.EncryptionAlgorithmType]] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Commit Block List operation writes a blob by specifying the list of block IDs that make up
        the blob. In order to be written as part of a blob, a block must have been successfully written
        to the server in a prior Put Block operation. You can call Put Block List to update a blob by
        uploading only those blocks that have changed, then committing the new and existing blocks
        together. You can do this by specifying whether to commit a block from the committed block list
        or from the uncommitted block list, or to commit the most recently uploaded version of the
        block, whichever list it may belong to.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param blocks: Blob Blocks. Required.
        :type blocks: ~azure.storage.blob.models.BlockLookupList
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: bytes
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword metadata: The metadata headers. Default value is None.
        :paramtype metadata: dict[str, str]
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. "AES256" Default
         value is None.
        :paramtype encryption_algorithm: str or ~azure.storage.blob.models.EncryptionAlgorithmType
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: The tier to be set on the blob. Known values are: "P4", "P6", "P10", "P15",
         "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive", "Premium", and
         "Cold". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_unmodified_since: The request should only proceed if the entity was not modified
         after this time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_modified_since: The request should only proceed if the entity was modified after
         this time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = _get_element(blocks)

        _request = build_block_blob_commit_block_list_request(
            container_name=container_name,
            blob=blob,
            timeout=timeout,
            blob_cache_control=blob_cache_control,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            metadata=metadata,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_unmodified_since=if_unmodified_since,
            if_modified_since=if_modified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            version=self._config.version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_block_list(
        self,
        container_name: str,
        blob: str,
        *,
        list_type: Union[str, _models.BlockListType],
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BlockLookupList:
        # pylint: disable=line-too-long
        """The Get Block List operation retrieves the list of blocks that have been uploaded as part of a
        block blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword list_type: Specifies whether to return the list of committed blocks, the list of
         uncommitted blocks, or both lists together. Known values are: "committed", "uncommitted", and
         "all". Required.
        :paramtype list_type: str or ~azure.storage.blob.models.BlockListType
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: BlockLookupList. The BlockLookupList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.BlockLookupList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))
        cls: ClsType[_models.BlockLookupList] = kwargs.pop("cls", None)

        _request = build_block_blob_get_block_list_request(
            container_name=container_name,
            blob=blob,
            list_type=list_type,
            snapshot=snapshot,
            timeout=timeout,
            lease_id=lease_id,
            if_tags=if_tags,
            content_type=content_type,
            version=self._config.version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("str", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("str", response.headers.get("Date"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )
        response_headers["Content-Type"] = self._deserialize("str", response.headers.get("Content-Type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(_models.BlockLookupList, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
