# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core import MatchConditions
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer
from .._vendor import prep_if_match, prep_if_none_match

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_service_set_properties_request(*, version: str, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?restype=service&comp=properties"

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_get_properties_request(*, version: str, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?restype=service&comp=properties"

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_get_statistics_request(*, version: str, timeout: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?restype=service&comp=stats"

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_list_containers_segment_request(  # pylint: disable=name-too-long
    *,
    version: str,
    prefix: Optional[str] = None,
    timeout: Optional[int] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=list"

    # Construct parameters
    if prefix is not None:
        _params["prefix"] = _SERIALIZER.query("prefix", prefix, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_get_user_delegation_key_request(  # pylint: disable=name-too-long
    *, version: str, timeout: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?restype=service&comp=userdelegationkey"

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_get_account_info_request(*, version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?restype=account&comp=properties"

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_service_submit_batch_request(
    *, content_length: int, version: str, timeout: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=batch"

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_service_filter_blobs_request(
    *,
    version: str,
    where: Optional[str] = None,
    include: Optional[List[Union[str, _models.FilterBlobsIncludes]]] = None,
    timeout: Optional[int] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=blobs"

    # Construct parameters
    if where is not None:
        _params["where"] = _SERIALIZER.query("where", where, "str")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_create_request(
    container_name: str,
    *,
    version: str,
    access: Optional[Union[str, _models.PublicAccessType]] = None,
    default_encryption_scope: Optional[str] = None,
    deny_encryption_scope_override: Optional[bool] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if access is not None:
        _headers["x-ms-blob-public-access"] = _SERIALIZER.header("access", access, "str")
    if default_encryption_scope is not None:
        _headers["x-ms-default-encryption-scope"] = _SERIALIZER.header(
            "default_encryption_scope", default_encryption_scope, "str"
        )
    if deny_encryption_scope_override is not None:
        _headers["x-ms-deny-encryption-scope-override"] = _SERIALIZER.header(
            "deny_encryption_scope_override", deny_encryption_scope_override, "bool"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_get_properties_request(
    container_name: str, *, version: str, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_delete_request(
    container_name: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_set_metadata_request(
    container_name: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    lease_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=metadata"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_get_access_policy_request(  # pylint: disable=name-too-long
    container_name: str, *, version: str, timeout: Optional[int] = None, lease_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=acl"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_set_access_policy_request(  # pylint: disable=name-too-long
    container_name: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    lease_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=acl"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_undelete_request(
    container_name: str,
    *,
    version: str,
    deleted_container_name: Optional[str] = None,
    deleted_container_version: Optional[str] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=undelete"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if deleted_container_name is not None:
        _headers["x-ms-deleted-container-name"] = _SERIALIZER.header(
            "deleted_container_name", deleted_container_name, "str"
        )
    if deleted_container_version is not None:
        _headers["x-ms-deleted-container-version"] = _SERIALIZER.header(
            "deleted_container_version", deleted_container_version, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_rename_request(
    container_name: str,
    *,
    source_container_name: str,
    version: str,
    source_lease_id: Optional[str] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=rename"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-source-container-name"] = _SERIALIZER.header("source_container_name", source_container_name, "str")
    if source_lease_id is not None:
        _headers["x-ms-source-lease-id"] = _SERIALIZER.header("source_lease_id", source_lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_submit_batch_request(
    container_name: str, *, content_length: int, version: str, timeout: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=batch"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_filter_blobs_request(
    container_name: str,
    *,
    version: str,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    where: Optional[str] = None,
    include: Optional[List[Union[str, _models.FilterBlobsIncludes]]] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=blobs"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")
    if where is not None:
        _params["where"] = _SERIALIZER.query("where", where, "str")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_acquire_lease_request(
    container_name: str,
    *,
    duration: int,
    version: str,
    timeout: Optional[int] = None,
    proposed_lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?comp=lease&restype=container&acquire"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-duration"] = _SERIALIZER.header("duration", duration, "int")
    if proposed_lease_id is not None:
        _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_release_lease_request(
    container_name: str,
    *,
    lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?comp=lease&restype=container&release"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_renew_lease_request(
    container_name: str,
    *,
    lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?comp=lease&restype=container&renew"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_break_lease_request(
    container_name: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    break_period: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?comp=lease&restype=container&break"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if break_period is not None:
        _headers["x-ms-lease-break-period"] = _SERIALIZER.header("break_period", break_period, "int")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_change_lease_request(
    container_name: str,
    *,
    lease_id: str,
    proposed_lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?comp=lease&restype=container&change"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_list_blob_flat_segment_request(  # pylint: disable=name-too-long
    container_name: str,
    *,
    version: str,
    prefix: Optional[str] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    include: Optional[List[Union[str, _models.ListBlobsIncludes]]] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=list&flat"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if prefix is not None:
        _params["prefix"] = _SERIALIZER.query("prefix", prefix, "str")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_list_blob_hierarchy_segment_request(  # pylint: disable=name-too-long
    container_name: str,
    *,
    delimiter: str,
    version: str,
    prefix: Optional[str] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    include: Optional[List[Union[str, _models.ListBlobsIncludes]]] = None,
    timeout: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=container&comp=list&hierarchy"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["delimiter"] = _SERIALIZER.query("delimiter", delimiter, "str")
    if prefix is not None:
        _params["prefix"] = _SERIALIZER.query("prefix", prefix, "str")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_container_get_account_info_request(container_name: str, *, version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}?restype=account&comp=properties"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_blob_download_request(
    container_name: str,
    blob: str,
    *,
    version_id: str,
    version: str,
    snapshot: Optional[str] = None,
    timeout: Optional[int] = None,
    range: Optional[str] = None,
    lease_id: Optional[str] = None,
    range_content_md5: Optional[bool] = None,
    range_content_crc64: Optional[bool] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    if_tags: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["versionid"] = _SERIALIZER.header("version_id", version_id, "str")
    if range is not None:
        _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if range_content_md5 is not None:
        _headers["x-ms-range-get-content-md5"] = _SERIALIZER.header("range_content_md5", range_content_md5, "bool")
    if range_content_crc64 is not None:
        _headers["x-ms-range-get-content-crc64"] = _SERIALIZER.header(
            "range_content_crc64", range_content_crc64, "bool"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_get_properties_request(
    container_name: str,
    blob: str,
    *,
    version_id: str,
    version: str,
    snapshot: Optional[str] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")

    # Construct headers
    _headers["versionid"] = _SERIALIZER.header("version_id", version_id, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_delete_request(
    container_name: str,
    blob: str,
    *,
    version_id: str,
    version: str,
    snapshot: Optional[str] = None,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    blob_delete_type: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")
    if blob_delete_type is not None:
        _params["deletetype"] = _SERIALIZER.query("blob_delete_type", blob_delete_type, "str")

    # Construct headers
    _headers["versionid"] = _SERIALIZER.header("version_id", version_id, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if delete_snapshots is not None:
        _headers["x-ms-delete-snapshots"] = _SERIALIZER.header("delete_snapshots", delete_snapshots, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_undelete_request(container_name: str, blob: str, *, version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=undelete"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_blob_set_expiry_request(
    container_name: str,
    blob: str,
    *,
    expiry_options: Union[str, _models.BlobExpiryOptions],
    expires_on: str,
    version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=expiry"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["x-ms-expiry-option"] = _SERIALIZER.header("expiry_options", expiry_options, "str")
    _headers["x-ms-expiry-time"] = _SERIALIZER.header("expires_on", expires_on, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_blob_set_http_headers_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    blob_cache_control: Optional[str] = None,
    blob_content_type: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=properties&SetHTTPHeaders"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_set_immutability_policy_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=immutabilityPolicies"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_delete_immutability_policy_request(  # pylint: disable=name-too-long
    container_name: str, blob: str, *, version: str, timeout: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=immutabilityPolicies"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_set_legal_hold_request(
    container_name: str, blob: str, *, legal_hold: bool, version: str, timeout: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=legalhold"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_set_metadata_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=metadata"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_acquire_lease_request(
    container_name: str,
    blob: str,
    *,
    duration: int,
    version: str,
    timeout: Optional[int] = None,
    proposed_lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=lease&acquire"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-duration"] = _SERIALIZER.header("duration", duration, "int")
    if proposed_lease_id is not None:
        _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_release_lease_request(
    container_name: str,
    blob: str,
    *,
    lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=lease&release"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_renew_lease_request(
    container_name: str,
    blob: str,
    *,
    lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=lease&renew"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_change_lease_request(
    container_name: str,
    blob: str,
    *,
    lease_id: str,
    version: str,
    timeout: Optional[int] = None,
    proposed_lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=lease&change"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if proposed_lease_id is not None:
        _headers["x-ms-proposed-lease-id"] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_break_lease_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    break_period: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=lease&break"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if break_period is not None:
        _headers["x-ms-lease-break-period"] = _SERIALIZER.header("break_period", break_period, "int")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_create_snapshot_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=snapshot"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_start_copy_from_url_request(
    container_name: str,
    blob: str,
    *,
    copy_source: str,
    version: str,
    timeout: Optional[int] = None,
    tier: Optional[Union[str, _models.AccessTier]] = None,
    rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
    source_if_modified_since: Optional[datetime.datetime] = None,
    source_if_unmodified_since: Optional[datetime.datetime] = None,
    source_if_match: Optional[str] = None,
    source_if_none_match: Optional[str] = None,
    source_if_tags: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    seal_blob: Optional[bool] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    legal_hold: Optional[bool] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=copy"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if rehydrate_priority is not None:
        _headers["x-ms-rehydrate-priority"] = _SERIALIZER.header("rehydrate_priority", rehydrate_priority, "str")
    if source_if_modified_since is not None:
        _headers["x-ms-source-if-modified-since"] = _SERIALIZER.header(
            "source_if_modified_since", source_if_modified_since, "rfc-1123"
        )
    if source_if_unmodified_since is not None:
        _headers["x-ms-source-if-unmodified-since"] = _SERIALIZER.header(
            "source_if_unmodified_since", source_if_unmodified_since, "rfc-1123"
        )
    if source_if_match is not None:
        _headers["x-ms-source-if-match"] = _SERIALIZER.header("source_if_match", source_if_match, "str")
    if source_if_none_match is not None:
        _headers["x-ms-source-if-none-match"] = _SERIALIZER.header("source_if_none_match", source_if_none_match, "str")
    if source_if_tags is not None:
        _headers["x-ms-source-if-tags"] = _SERIALIZER.header("source_if_tags", source_if_tags, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-copy-source"] = _SERIALIZER.header("copy_source", copy_source, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if seal_blob is not None:
        _headers["x-ms-seal-blob"] = _SERIALIZER.header("seal_blob", seal_blob, "bool")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_copy_from_url_request(
    container_name: str,
    blob: str,
    *,
    copy_source: str,
    version: str,
    timeout: Optional[int] = None,
    tier: Optional[Union[str, _models.AccessTier]] = None,
    source_if_modified_since: Optional[datetime.datetime] = None,
    source_if_unmodified_since: Optional[datetime.datetime] = None,
    source_if_match: Optional[str] = None,
    source_if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    lease_id: Optional[str] = None,
    source_content_md5: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    legal_hold: Optional[bool] = None,
    copy_source_authorization: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    copy_source_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=copy&sync"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if source_if_modified_since is not None:
        _headers["x-ms-source-if-modified-since"] = _SERIALIZER.header(
            "source_if_modified_since", source_if_modified_since, "rfc-1123"
        )
    if source_if_unmodified_since is not None:
        _headers["x-ms-source-if-unmodified-since"] = _SERIALIZER.header(
            "source_if_unmodified_since", source_if_unmodified_since, "rfc-1123"
        )
    if source_if_match is not None:
        _headers["x-ms-source-if-match"] = _SERIALIZER.header("source_if_match", source_if_match, "str")
    if source_if_none_match is not None:
        _headers["x-ms-source-if-none-match"] = _SERIALIZER.header("source_if_none_match", source_if_none_match, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-copy-source"] = _SERIALIZER.header("copy_source", copy_source, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if source_content_md5 is not None:
        _headers["x-ms-source-content-md5"] = _SERIALIZER.header("source_content_md5", source_content_md5, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    if copy_source_authorization is not None:
        _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
            "copy_source_authorization", copy_source_authorization, "str"
        )
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if copy_source_tags is not None:
        _headers["x-ms-copy-source-tags"] = _SERIALIZER.header("copy_source_tags", copy_source_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_abort_copy_from_url_request(
    container_name: str,
    blob: str,
    *,
    copy_id: str,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=copy&copyid"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-copy-id"] = _SERIALIZER.header("copy_id", copy_id, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_set_tier_request(
    container_name: str,
    blob: str,
    *,
    access_tier: Union[str, _models.AccessTier],
    version: str,
    timeout: Optional[int] = None,
    rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
    lease_id: Optional[str] = None,
    if_tags: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?comp=tier"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["x-ms-access-tier"] = _SERIALIZER.header("access_tier", access_tier, "str")
    if rehydrate_priority is not None:
        _headers["x-ms-rehydrate-priority"] = _SERIALIZER.header("rehydrate_priority", rehydrate_priority, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_get_account_info_request(container_name: str, blob: str, *, version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/?restype=account&comp=properties"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_blob_query_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    snapshot: Optional[str] = None,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/{containerName}/{blob}?comp=query"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_get_tags_request(
    container_name: str,
    blob: str,
    *,
    version_id: str,
    version: str,
    timeout: Optional[int] = None,
    snapshot: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_tags: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/{containerName}/{blob}?comp=tags"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")

    # Construct headers
    _headers["versionid"] = _SERIALIZER.header("version_id", version_id, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_set_tags_request(
    container_name: str,
    blob: str,
    *,
    version_id: str,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    transactional_content_md5: Optional[str] = None,
    transactional_content_crc64: Optional[str] = None,
    if_tags: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}/{containerName}/{blob}?comp=tags"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["versionid"] = _SERIALIZER.header("version_id", version_id, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_create_request(
    container_name: str,
    blob: str,
    *,
    content_length: int,
    blob_content_length: int,
    version: str,
    timeout: Optional[int] = None,
    tier: Optional[Union[str, _models.PremiumPageBlobAccessTier]] = None,
    blob_content_type: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    blob_cache_control: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    blob_sequence_number: Optional[int] = None,
    blob_tags_string: Optional[str] = None,
    immutability_policy_expiry: Optional[str] = None,
    legal_hold: Optional[bool] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?PageBlob"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-blob-content-length"] = _SERIALIZER.header("blob_content_length", blob_content_length, "int")
    if blob_sequence_number is not None:
        _headers["x-ms-blob-sequence-number"] = _SERIALIZER.header("blob_sequence_number", blob_sequence_number, "int")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_upload_pages_request(
    container_name: str,
    blob: str,
    *,
    content_length: int,
    version: str,
    transactional_content_md5: Optional[str] = None,
    transactional_content_crc64: Optional[str] = None,
    timeout: Optional[int] = None,
    range: Optional[str] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_sequence_number_less_than_or_equal_to: Optional[int] = None,
    if_sequence_number_less_than: Optional[int] = None,
    if_sequence_number_equal_to: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=page&update"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    if range is not None:
        _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_sequence_number_less_than_or_equal_to is not None:
        _headers["x-ms-if-sequence-number-le"] = _SERIALIZER.header(
            "if_sequence_number_less_than_or_equal_to", if_sequence_number_less_than_or_equal_to, "int"
        )
    if if_sequence_number_less_than is not None:
        _headers["x-ms-if-sequence-number-lt"] = _SERIALIZER.header(
            "if_sequence_number_less_than", if_sequence_number_less_than, "int"
        )
    if if_sequence_number_equal_to is not None:
        _headers["x-ms-if-sequence-number-eq"] = _SERIALIZER.header(
            "if_sequence_number_equal_to", if_sequence_number_equal_to, "int"
        )
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_clear_pages_request(
    container_name: str,
    blob: str,
    *,
    content_length: int,
    version: str,
    timeout: Optional[int] = None,
    range: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_sequence_number_less_than_or_equal_to: Optional[int] = None,
    if_sequence_number_less_than: Optional[int] = None,
    if_sequence_number_equal_to: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=page&clear"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if range is not None:
        _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_sequence_number_less_than_or_equal_to is not None:
        _headers["x-ms-if-sequence-number-le"] = _SERIALIZER.header(
            "if_sequence_number_less_than_or_equal_to", if_sequence_number_less_than_or_equal_to, "int"
        )
    if if_sequence_number_less_than is not None:
        _headers["x-ms-if-sequence-number-lt"] = _SERIALIZER.header(
            "if_sequence_number_less_than", if_sequence_number_less_than, "int"
        )
    if if_sequence_number_equal_to is not None:
        _headers["x-ms-if-sequence-number-eq"] = _SERIALIZER.header(
            "if_sequence_number_equal_to", if_sequence_number_equal_to, "int"
        )
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_upload_pages_from_url_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    content_length: int,
    source_url: str,
    source_range: str,
    range: str,
    version: str,
    timeout: Optional[int] = None,
    source_content_md5: Optional[str] = None,
    source_content_crc64: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_sequence_number_less_than_or_equal_to: Optional[int] = None,
    if_sequence_number_less_than: Optional[int] = None,
    if_sequence_number_equal_to: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    source_if_modified_since: Optional[datetime.datetime] = None,
    source_if_unmodified_since: Optional[datetime.datetime] = None,
    source_if_match: Optional[str] = None,
    source_if_none_match: Optional[str] = None,
    copy_source_authorization: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=page&update&fromUrl"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    _headers["x-ms-source-url"] = _SERIALIZER.header("source_url", source_url, "str")
    _headers["x-ms-source-range"] = _SERIALIZER.header("source_range", source_range, "str")
    if source_content_md5 is not None:
        _headers["x-ms-source-content-md5"] = _SERIALIZER.header("source_content_md5", source_content_md5, "str")
    if source_content_crc64 is not None:
        _headers["x-ms-source-content-crc64"] = _SERIALIZER.header("source_content_crc64", source_content_crc64, "str")
    _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_sequence_number_less_than_or_equal_to is not None:
        _headers["x-ms-if-sequence-number-le"] = _SERIALIZER.header(
            "if_sequence_number_less_than_or_equal_to", if_sequence_number_less_than_or_equal_to, "int"
        )
    if if_sequence_number_less_than is not None:
        _headers["x-ms-if-sequence-number-lt"] = _SERIALIZER.header(
            "if_sequence_number_less_than", if_sequence_number_less_than, "int"
        )
    if if_sequence_number_equal_to is not None:
        _headers["x-ms-if-sequence-number-eq"] = _SERIALIZER.header(
            "if_sequence_number_equal_to", if_sequence_number_equal_to, "int"
        )
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if source_if_modified_since is not None:
        _headers["x-ms-source-if-modified-since"] = _SERIALIZER.header(
            "source_if_modified_since", source_if_modified_since, "rfc-1123"
        )
    if source_if_unmodified_since is not None:
        _headers["x-ms-source-if-unmodified-since"] = _SERIALIZER.header(
            "source_if_unmodified_since", source_if_unmodified_since, "rfc-1123"
        )
    if source_if_match is not None:
        _headers["x-ms-source-if-match"] = _SERIALIZER.header("source_if_match", source_if_match, "str")
    if source_if_none_match is not None:
        _headers["x-ms-source-if-none-match"] = _SERIALIZER.header("source_if_none_match", source_if_none_match, "str")
    if copy_source_authorization is not None:
        _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
            "copy_source_authorization", copy_source_authorization, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_get_page_ranges_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    snapshot: Optional[str] = None,
    range: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=pagelist"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")

    # Construct headers
    if range is not None:
        _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_get_page_ranges_diff_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    prevsnapshot: str,
    prev_snapshot_url: str,
    version: str,
    snapshot: Optional[str] = None,
    timeout: Optional[int] = None,
    range: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    marker: Optional[str] = None,
    maxresults: Optional[int] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=pagelist&diff"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")
    _params["prevsnapshot"] = _SERIALIZER.query("prevsnapshot", prevsnapshot, "str")
    if marker is not None:
        _params["marker"] = _SERIALIZER.query("marker", marker, "str")
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int")

    # Construct headers
    _headers["x-ms-previous-snapshot-url"] = _SERIALIZER.header("prev_snapshot_url", prev_snapshot_url, "str")
    if range is not None:
        _headers["x-ms-range"] = _SERIALIZER.header("range", range, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_resize_request(
    container_name: str,
    blob: str,
    *,
    blob_content_length: int,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=properties&Resize"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-blob-content-length"] = _SERIALIZER.header("blob_content_length", blob_content_length, "int")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_update_sequence_number_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    sequence_number_action: Union[str, _models.SequenceNumberActionType],
    blob_sequence_number: int,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=properties&UpdateSequenceNumber"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-sequence-number-action"] = _SERIALIZER.header(
        "sequence_number_action", sequence_number_action, "str"
    )
    _headers["x-ms-blob-sequence-number"] = _SERIALIZER.header("blob_sequence_number", blob_sequence_number, "int")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_page_blob_copy_incremental_request(
    container_name: str,
    blob: str,
    *,
    copy_source: str,
    version: str,
    timeout: Optional[int] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    lease_id: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=incrementalcopy"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-copy-source"] = _SERIALIZER.header("copy_source", copy_source, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_append_blob_create_request(
    container_name: str,
    blob: str,
    *,
    content_length: int,
    version: str,
    timeout: Optional[int] = None,
    blob_content_type: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    blob_cache_control: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    legal_hold: Optional[bool] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?AppendBlob"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_append_blob_append_block_request(
    container_name: str,
    blob: str,
    *,
    content_length: int,
    max_size: int,
    append_position: int,
    version: str,
    timeout: Optional[int] = None,
    transactional_content_md5: Optional[str] = None,
    transactional_content_crc64: Optional[str] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?AppendBlob/{containerName}/{blob}?comp=appendblock"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-blob-condition-maxsize"] = _SERIALIZER.header("max_size", max_size, "int")
    _headers["x-ms-blob-condition-appendpos"] = _SERIALIZER.header("append_position", append_position, "int")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_append_blob_append_block_from_url_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    content_length: int,
    source_url: str,
    source_range: str,
    max_size: int,
    append_position: int,
    version: str,
    timeout: Optional[int] = None,
    source_content_md5: Optional[str] = None,
    source_content_crc64: Optional[str] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    copy_source_authorization: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?AppendBlob/{containerName}/{blob}?comp=appendblock&fromUrl"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    _headers["x-ms-source-url"] = _SERIALIZER.header("source_url", source_url, "str")
    _headers["x-ms-source-range"] = _SERIALIZER.header("source_range", source_range, "str")
    if source_content_md5 is not None:
        _headers["x-ms-source-content-md5"] = _SERIALIZER.header("source_content_md5", source_content_md5, "str")
    if source_content_crc64 is not None:
        _headers["x-ms-source-content-crc64"] = _SERIALIZER.header("source_content_crc64", source_content_crc64, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-blob-condition-maxsize"] = _SERIALIZER.header("max_size", max_size, "int")
    _headers["x-ms-blob-condition-appendpos"] = _SERIALIZER.header("append_position", append_position, "int")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if copy_source_authorization is not None:
        _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
            "copy_source_authorization", copy_source_authorization, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_append_blob_seal_request(
    container_name: str,
    blob: str,
    *,
    append_position: int,
    version: str,
    timeout: Optional[int] = None,
    lease_id: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?AppendBlob/{containerName}/{blob}?comp=seal"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    _headers["x-ms-blob-condition-appendpos"] = _SERIALIZER.header("append_position", append_position, "int")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_upload_request(
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    transactional_content_md5: Optional[str] = None,
    blob_content_type: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    blob_cache_control: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    tier: Optional[Union[str, _models.AccessTier]] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    legal_hold: Optional[bool] = None,
    transactional_content_crc64: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?BlockBlob"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_put_blob_from_url_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    content_length: int,
    copy_source: str,
    version: str,
    timeout: Optional[int] = None,
    transactional_content_md5: Optional[str] = None,
    blob_content_type: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    blob_cache_control: Optional[str] = None,
    lease_id: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    tier: Optional[Union[str, _models.AccessTier]] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    source_if_modified_since: Optional[datetime.datetime] = None,
    source_if_match: Optional[str] = None,
    source_if_none_match: Optional[str] = None,
    source_if_tags: Optional[str] = None,
    source_content_md5: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    copy_source_blob_properties: Optional[bool] = None,
    copy_source_authorization: Optional[str] = None,
    copy_source_tags: Optional[str] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?BlockBlob&fromUrl"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if source_if_modified_since is not None:
        _headers["x-ms-source-if-modified-since"] = _SERIALIZER.header(
            "source_if_modified_since", source_if_modified_since, "rfc-1123"
        )
    if source_if_match is not None:
        _headers["x-ms-source-if-match"] = _SERIALIZER.header("source_if_match", source_if_match, "str")
    if source_if_none_match is not None:
        _headers["x-ms-source-if-none-match"] = _SERIALIZER.header("source_if_none_match", source_if_none_match, "str")
    if source_if_tags is not None:
        _headers["x-ms-source-if-tags"] = _SERIALIZER.header("source_if_tags", source_if_tags, "str")
    if source_content_md5 is not None:
        _headers["x-ms-source-content-md5"] = _SERIALIZER.header("source_content_md5", source_content_md5, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    _headers["x-ms-copy-source"] = _SERIALIZER.header("copy_source", copy_source, "str")
    if copy_source_blob_properties is not None:
        _headers["x-ms-copy-source-blob-properties"] = _SERIALIZER.header(
            "copy_source_blob_properties", copy_source_blob_properties, "bool"
        )
    if copy_source_authorization is not None:
        _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
            "copy_source_authorization", copy_source_authorization, "str"
        )
    if copy_source_tags is not None:
        _headers["x-ms-copy-source-tags"] = _SERIALIZER.header("copy_source_tags", copy_source_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_stage_block_request(
    container_name: str,
    blob: str,
    *,
    block_id: str,
    content_length: int,
    version: str,
    transactional_content_md5: Optional[str] = None,
    timeout: Optional[int] = None,
    transactional_content_crc64: Optional[str] = None,
    lease_id: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{containerName}/{blob}?comp=block"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["blockid"] = _SERIALIZER.query("block_id", block_id, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_stage_block_from_url_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    block_id: str,
    content_length: int,
    source_url: str,
    source_range: str,
    version: str,
    source_content_md5: Optional[str] = None,
    source_content_crc64: Optional[str] = None,
    timeout: Optional[int] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    lease_id: Optional[str] = None,
    source_if_modified_since: Optional[datetime.datetime] = None,
    source_if_unmodified_since: Optional[datetime.datetime] = None,
    source_if_match: Optional[str] = None,
    source_if_none_match: Optional[str] = None,
    copy_source_authorization: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=block&fromURL/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["blockid"] = _SERIALIZER.query("block_id", block_id, "str")
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    _headers["Content-Length"] = _SERIALIZER.header("content_length", content_length, "int")
    _headers["x-ms-source-url"] = _SERIALIZER.header("source_url", source_url, "str")
    _headers["x-ms-source-range"] = _SERIALIZER.header("source_range", source_range, "str")
    if source_content_md5 is not None:
        _headers["x-ms-source-content-md5"] = _SERIALIZER.header("source_content_md5", source_content_md5, "str")
    if source_content_crc64 is not None:
        _headers["x-ms-source-content-crc64"] = _SERIALIZER.header("source_content_crc64", source_content_crc64, "str")
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if source_if_modified_since is not None:
        _headers["x-ms-source-if-modified-since"] = _SERIALIZER.header(
            "source_if_modified_since", source_if_modified_since, "rfc-1123"
        )
    if source_if_unmodified_since is not None:
        _headers["x-ms-source-if-unmodified-since"] = _SERIALIZER.header(
            "source_if_unmodified_since", source_if_unmodified_since, "rfc-1123"
        )
    if source_if_match is not None:
        _headers["x-ms-source-if-match"] = _SERIALIZER.header("source_if_match", source_if_match, "str")
    if source_if_none_match is not None:
        _headers["x-ms-source-if-none-match"] = _SERIALIZER.header("source_if_none_match", source_if_none_match, "str")
    if copy_source_authorization is not None:
        _headers["x-ms-copy-source-authorization"] = _SERIALIZER.header(
            "copy_source_authorization", copy_source_authorization, "str"
        )
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_commit_block_list_request(  # pylint: disable=name-too-long
    container_name: str,
    blob: str,
    *,
    version: str,
    timeout: Optional[int] = None,
    blob_cache_control: Optional[str] = None,
    blob_content_type: Optional[str] = None,
    blob_content_encoding: Optional[str] = None,
    blob_content_language: Optional[str] = None,
    blob_content_md5: Optional[str] = None,
    transactional_content_md5: Optional[str] = None,
    transactional_content_crc64: Optional[str] = None,
    blob_content_disposition: Optional[str] = None,
    encryption_key: Optional[str] = None,
    encryption_key_sha256: Optional[str] = None,
    encryption_algorithm: Optional[str] = None,
    encryption_scope: Optional[str] = None,
    tier: Optional[Union[str, _models.AccessTier]] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    if_tags: Optional[str] = None,
    blob_tags_string: Optional[str] = None,
    immutability_policy_expiry: Optional[str] = None,
    immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
    legal_hold: Optional[bool] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=blocklist/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if timeout is not None:
        _params["timeout"] = _SERIALIZER.query("timeout", timeout, "int")

    # Construct headers
    if blob_cache_control is not None:
        _headers["x-ms-blob-cache-control"] = _SERIALIZER.header("blob_cache_control", blob_cache_control, "str")
    if blob_content_type is not None:
        _headers["x-ms-blob-content-type"] = _SERIALIZER.header("blob_content_type", blob_content_type, "str")
    if blob_content_encoding is not None:
        _headers["x-ms-blob-content-encoding"] = _SERIALIZER.header(
            "blob_content_encoding", blob_content_encoding, "str"
        )
    if blob_content_language is not None:
        _headers["x-ms-blob-content-language"] = _SERIALIZER.header(
            "blob_content_language", blob_content_language, "str"
        )
    if blob_content_md5 is not None:
        _headers["x-ms-blob-content-md5"] = _SERIALIZER.header("blob_content_md5", blob_content_md5, "str")
    if transactional_content_md5 is not None:
        _headers["Content-MD5"] = _SERIALIZER.header("transactional_content_md5", transactional_content_md5, "str")
    if transactional_content_crc64 is not None:
        _headers["x-ms-content-crc64"] = _SERIALIZER.header(
            "transactional_content_crc64", transactional_content_crc64, "str"
        )
    if blob_content_disposition is not None:
        _headers["x-ms-blob-content-disposition"] = _SERIALIZER.header(
            "blob_content_disposition", blob_content_disposition, "str"
        )
    if encryption_key is not None:
        _headers["x-ms-encryption-key"] = _SERIALIZER.header("encryption_key", encryption_key, "str")
    if encryption_key_sha256 is not None:
        _headers["x-ms-encryption-key-sha256"] = _SERIALIZER.header(
            "encryption_key_sha256", encryption_key_sha256, "str"
        )
    if encryption_algorithm is not None:
        _headers["x-ms-encryption-algorithm"] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, "str")
    if encryption_scope is not None:
        _headers["x-ms-encryption-scope"] = _SERIALIZER.header("encryption_scope", encryption_scope, "str")
    if tier is not None:
        _headers["x-ms-access-tier"] = _SERIALIZER.header("tier", tier, "str")
    if if_modified_since is not None:
        _headers["If-Modified-Since"] = _SERIALIZER.header("if_modified_since", if_modified_since, "rfc-1123")
    if if_unmodified_since is not None:
        _headers["If-Unmodified-Since"] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, "rfc-1123")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    if blob_tags_string is not None:
        _headers["x-ms-tags"] = _SERIALIZER.header("blob_tags_string", blob_tags_string, "str")
    if immutability_policy_expiry is not None:
        _headers["x-ms-immutability-policy-until-date"] = _SERIALIZER.header(
            "immutability_policy_expiry", immutability_policy_expiry, "str"
        )
    if immutability_policy_mode is not None:
        _headers["x-ms-immutability-policy-mode"] = _SERIALIZER.header(
            "immutability_policy_mode", immutability_policy_mode, "str"
        )
    if legal_hold is not None:
        _headers["x-ms-legal-hold"] = _SERIALIZER.header("legal_hold", legal_hold, "bool")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_block_blob_get_block_list_request(
    container_name: str,
    blob: str,
    *,
    list_type: Union[str, _models.BlockListType],
    version: str,
    snapshot: Optional[str] = None,
    lease_id: Optional[str] = None,
    if_tags: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/?comp=blocklist/{containerName}/{blob}"
    path_format_arguments = {
        "containerName": _SERIALIZER.url("container_name", container_name, "str"),
        "blob": _SERIALIZER.url("blob", blob, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if snapshot is not None:
        _params["snapshot"] = _SERIALIZER.query("snapshot", snapshot, "str")
    _params["blocklisttype"] = _SERIALIZER.query("list_type", list_type, "str")

    # Construct headers
    if lease_id is not None:
        _headers["x-ms-lease-id"] = _SERIALIZER.header("lease_id", lease_id, "str")
    if if_tags is not None:
        _headers["x-ms-if-tags"] = _SERIALIZER.header("if_tags", if_tags, "str")
    _headers["x-ms-version"] = _SERIALIZER.header("version", version, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class ServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`service` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def set_properties(
        self,
        body: _models.StorageServiceProperties,
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Get the properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param body: The storage service properties that specifies the analytics and CORS rules to set
         on the Blob service. Required.
        :type body: ~azure.storage.blob.models.StorageServiceProperties
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_properties(
        self,
        body: JSON,
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Get the properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param body: The storage service properties that specifies the analytics and CORS rules to set
         on the Blob service. Required.
        :type body: JSON
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_properties(
        self,
        body: IO[bytes],
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Get the properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param body: The storage service properties that specifies the analytics and CORS rules to set
         on the Blob service. Required.
        :type body: IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def set_properties(  # pylint: disable=inconsistent-return-statements
        self,
        body: Union[_models.StorageServiceProperties, JSON, IO[bytes]],
        *,
        version: str,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Get the properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param body: The storage service properties that specifies the analytics and CORS rules to set
         on the Blob service. Is one of the following types: StorageServiceProperties, JSON, IO[bytes]
         Required.
        :type body: ~azure.storage.blob.models.StorageServiceProperties or JSON or IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_service_set_properties_request(
            version=version,
            timeout=timeout,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_properties(
        self, *, version: str, timeout: Optional[int] = None, **kwargs: Any
    ) -> _models.StorageServiceProperties:
        # pylint: disable=line-too-long
        """Retrieves properties of a storage account's Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: StorageServiceProperties. The StorageServiceProperties is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.StorageServiceProperties
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StorageServiceProperties] = kwargs.pop("cls", None)

        _request = build_service_get_properties_request(
            version=version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StorageServiceProperties, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_statistics(
        self, *, version: str, timeout: Optional[int] = None, **kwargs: Any
    ) -> _models.StorageServiceStats:
        # pylint: disable=line-too-long
        """Retrieves statistics related to replication for the Blob service. It is only available on the
        secondary location endpoint when read-access geo-redundant replication is enabled for the
        storage account.

        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: StorageServiceStats. The StorageServiceStats is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.StorageServiceStats
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StorageServiceStats] = kwargs.pop("cls", None)

        _request = build_service_get_statistics_request(
            version=version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StorageServiceStats, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_containers_segment(
        self,
        *,
        version: str,
        prefix: Optional[str] = None,
        timeout: Optional[int] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        **kwargs: Any
    ) -> _models.ListContainersSegmentResponse:
        # pylint: disable=line-too-long
        """The List Containers Segment operation returns a list of the containers under the specified
        account.

        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :return: ListContainersSegmentResponse. The ListContainersSegmentResponse is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.ListContainersSegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListContainersSegmentResponse] = kwargs.pop("cls", None)

        _request = build_service_list_containers_segment_request(
            version=version,
            prefix=prefix,
            timeout=timeout,
            marker=marker,
            maxresults=maxresults,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListContainersSegmentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def get_user_delegation_key(
        self,
        body: _models.KeyInfo,
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UserDelegationKey:
        # pylint: disable=line-too-long
        """The Get User Delegation Key operation gets the user delegation key for the Blob service. This
        is only a valid operation when using User Delegation SAS. For more information, see <a
        href=\\"https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas\\">Create
        a user delegation SAS</a>.

        :param body: The user delegation key info. Required.
        :type body: ~azure.storage.blob.models.KeyInfo
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UserDelegationKey. The UserDelegationKey is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.UserDelegationKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_user_delegation_key(
        self,
        body: JSON,
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UserDelegationKey:
        # pylint: disable=line-too-long
        """The Get User Delegation Key operation gets the user delegation key for the Blob service. This
        is only a valid operation when using User Delegation SAS. For more information, see <a
        href=\\"https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas\\">Create
        a user delegation SAS</a>.

        :param body: The user delegation key info. Required.
        :type body: JSON
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UserDelegationKey. The UserDelegationKey is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.UserDelegationKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_user_delegation_key(
        self,
        body: IO[bytes],
        *,
        version: str,
        timeout: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UserDelegationKey:
        # pylint: disable=line-too-long
        """The Get User Delegation Key operation gets the user delegation key for the Blob service. This
        is only a valid operation when using User Delegation SAS. For more information, see <a
        href=\\"https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas\\">Create
        a user delegation SAS</a>.

        :param body: The user delegation key info. Required.
        :type body: IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UserDelegationKey. The UserDelegationKey is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.UserDelegationKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_user_delegation_key(
        self,
        body: Union[_models.KeyInfo, JSON, IO[bytes]],
        *,
        version: str,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.UserDelegationKey:
        # pylint: disable=line-too-long
        """The Get User Delegation Key operation gets the user delegation key for the Blob service. This
        is only a valid operation when using User Delegation SAS. For more information, see <a
        href=\\"https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas\\">Create
        a user delegation SAS</a>.

        :param body: The user delegation key info. Is one of the following types: KeyInfo, JSON,
         IO[bytes] Required.
        :type body: ~azure.storage.blob.models.KeyInfo or JSON or IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: UserDelegationKey. The UserDelegationKey is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.UserDelegationKey
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UserDelegationKey] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_service_get_user_delegation_key_request(
            version=version,
            timeout=timeout,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.UserDelegationKey, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_account_info(  # pylint: disable=inconsistent-return-statements
        self, *, version: str, **kwargs: Any
    ) -> None:
        """Returns the sku name and account kind.

        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_service_get_account_info_request(
            version=version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-is-hns-enabled"] = self._deserialize("bool", response.headers.get("x-ms-is-hns-enabled"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def submit_batch(  # pylint: disable=inconsistent-return-statements
        self, *, content_length: int, version: str, timeout: Optional[int] = None, **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Batch operation allows multiple API calls to be embedded into a single HTTP request.

        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_service_submit_batch_request(
            content_length=content_length,
            version=version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def filter_blobs(
        self,
        *,
        version: str,
        where: Optional[str] = None,
        include: Optional[List[Union[str, _models.FilterBlobsIncludes]]] = None,
        timeout: Optional[int] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FilterBlobSegment:
        # pylint: disable=line-too-long
        """The Filter Blobs operation enables callers to list blobs across all containers whose tags match
        a given search expression.

        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword where: Filters the results to return only to return only blobs whose tags match the
         specified expression. Default value is None.
        :paramtype where: str
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.FilterBlobsIncludes]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :return: FilterBlobSegment. The FilterBlobSegment is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.FilterBlobSegment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FilterBlobSegment] = kwargs.pop("cls", None)

        _request = build_service_filter_blobs_request(
            version=version,
            where=where,
            include=include,
            timeout=timeout,
            marker=marker,
            maxresults=maxresults,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FilterBlobSegment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ContainerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`container` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        access: Optional[Union[str, _models.PublicAccessType]] = None,
        default_encryption_scope: Optional[str] = None,
        deny_encryption_scope_override: Optional[bool] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Creates a new container under the specified account. If the container with the same name
        already exists, the operation fails.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword access: Specifies whether data in the container may be accessed publicly and the level
         of access. Possible values include: 'container', 'blob'. Known values are: "blob" and
         "container". Default value is None.
        :paramtype access: str or ~azure.storage.blob.models.PublicAccessType
        :keyword default_encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the
         default encryption scope to set on the container and use for all future writes. Default value
         is None.
        :paramtype default_encryption_scope: str
        :keyword deny_encryption_scope_override: Optional.  Version 2019-07-07 and later.  Specifies
         that the request will fail if the target container does not have the same encryption scope as
         the source container. Default value is None.
        :paramtype deny_encryption_scope_override: bool
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_create_request(
            container_name=container_name,
            version=version,
            access=access,
            default_encryption_scope=default_encryption_scope,
            deny_encryption_scope_override=deny_encryption_scope_override,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_properties(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """returns all user-defined metadata and system properties for the specified container. The data
        returned does not include the container's list of blobs.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_get_properties_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["x-ms-blob-public-access"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-public-access")
        )
        response_headers["x-ms-has-immutability-policy"] = self._deserialize(
            "bool", response.headers.get("x-ms-has-immutability-policy")
        )
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["x-ms-default-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-default-encryption-scope")
        )
        response_headers["x-ms-deny-encryption-scope-override"] = self._deserialize(
            "bool", response.headers.get("x-ms-deny-encryption-scope-override")
        )
        response_headers["x-ms-immutable-storage-with-versioning-enabled"] = self._deserialize(
            "bool", response.headers.get("x-ms-immutable-storage-with-versioning-enabled")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """operation marks the specified container for deletion. The container and any blobs contained
        within it are later deleted during garbage collection.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_delete_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """operation sets one or more user-defined name-value pairs for the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_set_metadata_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            lease_id=lease_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_access_policy(
        self,
        container_name: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.SignedIdentifier]:
        # pylint: disable=line-too-long
        """gets the permissions for the specified container. The permissions indicate whether container
        data may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: list of SignedIdentifier
        :rtype: list[~azure.storage.blob.models.SignedIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SignedIdentifier]] = kwargs.pop("cls", None)

        _request = build_container_get_access_policy_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-blob-public-access"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-public-access")
        )
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.SignedIdentifier], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def set_access_policy(
        self,
        container_name: str,
        acl: List[_models.SignedIdentifier],
        *,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        lease_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """sets the permissions for the specified container. The permissions indicate whether blobs in a
        container may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param acl: The access control list for the container. Required.
        :type acl: list[~azure.storage.blob.models.SignedIdentifier]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_access_policy(
        self,
        container_name: str,
        acl: IO[bytes],
        *,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        lease_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """sets the permissions for the specified container. The permissions indicate whether blobs in a
        container may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param acl: The access control list for the container. Required.
        :type acl: IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def set_access_policy(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        acl: Union[List[_models.SignedIdentifier], IO[bytes]],
        *,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """sets the permissions for the specified container. The permissions indicate whether blobs in a
        container may be accessed publicly.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param acl: The access control list for the container. Is either a [SignedIdentifier] type or a
         IO[bytes] type. Required.
        :type acl: list[~azure.storage.blob.models.SignedIdentifier] or IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(acl, (IOBase, bytes)):
            _content = acl
        else:
            _content = json.dumps(acl, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_container_set_access_policy_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            lease_id=lease_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def undelete(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        deleted_container_name: Optional[str] = None,
        deleted_container_version: Optional[str] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Restores a previously-deleted container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword deleted_container_name: Optional.  Version 2019-12-12 and later.  Specifies the name
         of the deleted container to restore. Default value is None.
        :paramtype deleted_container_name: str
        :keyword deleted_container_version: Optional.  Version 2019-12-12 and later.  Specifies the
         version of the deleted container to restore. Default value is None.
        :paramtype deleted_container_version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_undelete_request(
            container_name=container_name,
            version=version,
            deleted_container_name=deleted_container_name,
            deleted_container_version=deleted_container_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def rename(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        source_container_name: str,
        version: str,
        source_lease_id: Optional[str] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Renames an existing container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword source_container_name: Required.  Specifies the name of the container to rename.
         Required.
        :paramtype source_container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword source_lease_id: A lease ID for the source path. If specified, the source path must
         have an active lease and the lease ID must match. Default value is None.
        :paramtype source_lease_id: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_rename_request(
            container_name=container_name,
            source_container_name=source_container_name,
            version=version,
            source_lease_id=source_lease_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def submit_batch(
        self,
        container_name: str,
        body: bytes,
        *,
        content_length: int,
        version: str,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Batch operation allows multiple API calls to be embedded into a single HTTP request.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[bytes] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore

        _request = build_container_submit_batch_request(
            container_name=container_name,
            content_length=content_length,
            version=version,
            timeout=timeout,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def filter_blobs(
        self,
        container_name: str,
        *,
        version: str,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        where: Optional[str] = None,
        include: Optional[List[Union[str, _models.FilterBlobsIncludes]]] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.FilterBlobSegment:
        # pylint: disable=line-too-long
        """The Filter Blobs operation enables callers to list blobs in a container whose tags match a
        given search expression.  Filter blobs searches within the given container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword where: Filters the results to return only to return only blobs whose tags match the
         specified expression. Default value is None.
        :paramtype where: str
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.FilterBlobsIncludes]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: FilterBlobSegment. The FilterBlobSegment is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.FilterBlobSegment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FilterBlobSegment] = kwargs.pop("cls", None)

        _request = build_container_filter_blobs_request(
            container_name=container_name,
            version=version,
            marker=marker,
            maxresults=maxresults,
            where=where,
            include=include,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FilterBlobSegment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def acquire_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        duration: int,
        version: str,
        timeout: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change. Required.
        :paramtype duration: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_acquire_lease_request(
            container_name=container_name,
            duration=duration,
            version=version,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def release_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_release_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def renew_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_renew_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def break_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        break_period: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword break_period: For a break operation, proposed duration the lease should continue
         before it is broken, in seconds, between 0 and 60. This break period is only used if it is
         shorter than the time remaining on the lease. If longer, the time remaining on the lease is
         used. A new lease will not be available before the break period has expired, but the lease may
         be held for longer than the break period. If this header does not appear with a break
         operation, a fixed-duration lease breaks after the remaining lease period elapses, and an
         infinite lease breaks immediately. Default value is None.
        :paramtype break_period: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_break_lease_request(
            container_name=container_name,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            break_period=break_period,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-time"] = self._deserialize("int", response.headers.get("x-ms-lease-time"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def change_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        *,
        lease_id: str,
        proposed_lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] establishes and manages a lock on a container for delete operations. The lock duration
        can be 15 to 60 seconds, or can be infinite.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword proposed_lease_id: Required.  The proposed lease ID for the container. Required.
        :paramtype proposed_lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_change_lease_request(
            container_name=container_name,
            lease_id=lease_id,
            proposed_lease_id=proposed_lease_id,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-lease-time"] = self._deserialize("int", response.headers.get("x-ms-lease-time"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def list_blob_flat_segment(
        self,
        container_name: str,
        *,
        version: str,
        prefix: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.ListBlobsIncludes]]] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.ListBlobsFlatSegmentResponse:
        # pylint: disable=line-too-long
        """[Update] The List Blobs operation returns a list of the blobs under the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.ListBlobsIncludes]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: ListBlobsFlatSegmentResponse. The ListBlobsFlatSegmentResponse is compatible with
         MutableMapping
        :rtype: ~azure.storage.blob.models.ListBlobsFlatSegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListBlobsFlatSegmentResponse] = kwargs.pop("cls", None)

        _request = build_container_list_blob_flat_segment_request(
            container_name=container_name,
            version=version,
            prefix=prefix,
            marker=marker,
            maxresults=maxresults,
            include=include,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListBlobsFlatSegmentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_blob_hierarchy_segment(
        self,
        container_name: str,
        *,
        delimiter: str,
        version: str,
        prefix: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        include: Optional[List[Union[str, _models.ListBlobsIncludes]]] = None,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> _models.ListBlobsHierarchySegmentResponse:
        # pylint: disable=line-too-long
        """[Update] The List Blobs operation returns a list of the blobs under the specified container.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword delimiter: When the request includes this parameter, the operation returns a
         BlobPrefix element in the response body that acts as a placeholder for all blobs whose names
         begin with the same substring up to the appearance of the delimiter character. The delimiter
         may be a single character or a string. Required.
        :paramtype delimiter: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword prefix: Filters the results to return only containers whose name begins with the
         specified prefix. Default value is None.
        :paramtype prefix: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword include: Include this parameter to specify one or more datasets to include in the
         response. Default value is None.
        :paramtype include: list[str or ~azure.storage.blob.models.ListBlobsIncludes]
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: ListBlobsHierarchySegmentResponse. The ListBlobsHierarchySegmentResponse is compatible
         with MutableMapping
        :rtype: ~azure.storage.blob.models.ListBlobsHierarchySegmentResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListBlobsHierarchySegmentResponse] = kwargs.pop("cls", None)

        _request = build_container_list_blob_hierarchy_segment_request(
            container_name=container_name,
            delimiter=delimiter,
            version=version,
            prefix=prefix,
            marker=marker,
            maxresults=maxresults,
            include=include,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListBlobsHierarchySegmentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_account_info(  # pylint: disable=inconsistent-return-statements
        self, container_name: str, *, version: str, **kwargs: Any
    ) -> None:
        """Returns the sku name and account kind.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_container_get_account_info_request(
            container_name=container_name,
            version=version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class BlobOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`blob` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def download(
        self,
        container_name: str,
        blob: str,
        *,
        version_id: str,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        range_content_md5: Optional[bool] = None,
        range_content_crc64: Optional[bool] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_tags: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Download operation reads or downloads a blob from the system, including its metadata and
        properties. You can also call Download to read a snapshot.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword range_content_md5: Optional.  When this header is set to true and specified together
         with the Range header, the service returns the MD5 hash for the range, as long as the range is
         less than or equal to 4 MB in size. Default value is None.
        :paramtype range_content_md5: bool
        :keyword range_content_crc64: Optional.  When this header is set to true and specified together
         with the Range header, the service returns the CRC64 hash for the range, as long as the range
         is less than or equal to 4 MB in size. Default value is None.
        :paramtype range_content_crc64: bool
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop("cls", None)

        _request = build_blob_download_request(
            container_name=container_name,
            blob=blob,
            version_id=version_id,
            version=version,
            snapshot=snapshot,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            range_content_md5=range_content_md5,
            range_content_crc64=range_content_crc64,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_tags=if_tags,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-creation-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-creation-time")
        )
        response_headers["x-ms-or-policy-id"] = self._deserialize("str", response.headers.get("x-ms-or-policy-id"))
        response_headers["Content-Range"] = self._deserialize("str", response.headers.get("Content-Range"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
        response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
        response_headers["Content-Disposition"] = self._deserialize("str", response.headers.get("Content-Disposition"))
        response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
        response_headers["x-ms-copy-completion-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-copy-completion-time")
        )
        response_headers["x-ms-copy-status-description"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-status-description")
        )
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-progress"] = self._deserialize("str", response.headers.get("x-ms-copy-progress"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
        response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["x-ms-is-current-version"] = self._deserialize(
            "bool", response.headers.get("x-ms-is-current-version")
        )
        response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-tag-count"] = self._deserialize("int", response.headers.get("x-ms-tag-count"))
        response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
        response_headers["x-ms-last-access-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-last-access-time")
        )
        response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-immutability-policy-until-date")
        )
        response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-mode")
        )
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_properties(
        self,
        container_name: str,
        blob: str,
        *,
        version_id: str,
        version: str,
        snapshot: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bool:
        # pylint: disable=line-too-long
        """The Get Properties operation returns all user-defined metadata, standard HTTP properties, and
        system properties for the blob. It does not return the content of the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_get_properties_request(
            container_name=container_name,
            blob=blob,
            version_id=version_id,
            version=version,
            snapshot=snapshot,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-creation-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-creation-time")
        )
        response_headers["x-ms-or-policy-id"] = self._deserialize("str", response.headers.get("x-ms-or-policy-id"))
        response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
        response_headers["x-ms-copy-completion-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-copy-completion-time")
        )
        response_headers["x-ms-copy-status-description"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-status-description")
        )
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-progress"] = self._deserialize("str", response.headers.get("x-ms-copy-progress"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
        response_headers["x-ms-incremental-copy"] = self._deserialize(
            "bool", response.headers.get("x-ms-incremental-copy")
        )
        response_headers["x-ms-copy-destination-snapshot"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-destination-snapshot")
        )
        response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
        response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
        response_headers["Content-Disposition"] = self._deserialize("str", response.headers.get("Content-Disposition"))
        response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-access-tier"] = self._deserialize("str", response.headers.get("x-ms-access-tier"))
        response_headers["x-ms-access-tier-inferred"] = self._deserialize(
            "bool", response.headers.get("x-ms-access-tier-inferred")
        )
        response_headers["x-ms-archive-status"] = self._deserialize("str", response.headers.get("x-ms-archive-status"))
        response_headers["x-ms-access-tier-change-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-access-tier-change-time")
        )
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["x-ms-is-current-version"] = self._deserialize(
            "bool", response.headers.get("x-ms-is-current-version")
        )
        response_headers["x-ms-tag-count"] = self._deserialize("int", response.headers.get("x-ms-tag-count"))
        response_headers["x-ms-expiry-time"] = self._deserialize("rfc-1123", response.headers.get("x-ms-expiry-time"))
        response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
        response_headers["x-ms-rehydrate-priority"] = self._deserialize(
            "str", response.headers.get("x-ms-rehydrate-priority")
        )
        response_headers["x-ms-last-access-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-last-access-time")
        )
        response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-immutability-policy-until-date")
        )
        response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-mode")
        )
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore
        return 200 <= response.status_code <= 299

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version_id: str,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        delete_snapshots: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_delete_type: Optional[Union[str, _models.DeleteSnapshotsOptionType]] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
        permanently removed from the storage account. If the storage account's soft delete feature is
        enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
        immediately. However, the blob service retains the blob or snapshot for the number of days
        specified by the DeleteRetentionPolicy section of [Storage service properties]
        (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's
        data is permanently removed from the storage account. Note that you continue to be charged for
        the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and
        specify the \\"include=deleted\\" query parameter to discover which blobs and snapshots have
        been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All
        other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status
        code of 404 (ResourceNotFound).

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword delete_snapshots: Required if the blob has associated snapshots. Specify one of the
         following two options: include: Delete the base blob and all of its snapshots. only: Delete
         only the blob's snapshots and not the blob itself. Known values are: "none" and "include".
         Default value is None.
        :paramtype delete_snapshots: str or ~azure.storage.blob.models.DeleteSnapshotsOptionType
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_delete_type: Optional.  Only possible value is 'permanent', which specifies to
         permanently delete a blob if blob soft delete is enabled. Known values are: "none" and
         "include". Default value is None.
        :paramtype blob_delete_type: str or ~azure.storage.blob.models.DeleteSnapshotsOptionType
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_delete_request(
            container_name=container_name,
            blob=blob,
            version_id=version_id,
            version=version,
            snapshot=snapshot,
            timeout=timeout,
            lease_id=lease_id,
            delete_snapshots=delete_snapshots,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            blob_delete_type=blob_delete_type,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def undelete(  # pylint: disable=inconsistent-return-statements
        self, container_name: str, blob: str, *, version: str, **kwargs: Any
    ) -> None:
        """ "Undelete a blob that was previously soft deleted".

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_undelete_request(
            container_name=container_name,
            blob=blob,
            version=version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_expiry(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        expiry_options: Union[str, _models.BlobExpiryOptions],
        expires_on: str,
        version: str,
        **kwargs: Any
    ) -> None:
        """ "Set the expiration time of a blob".

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword expiry_options: Required. Indicates mode of the expiry time. Known values are:
         "NeverExpire", "RelativeToCreation", "RelativeToNow", and "Absolute". Required.
        :paramtype expiry_options: str or ~azure.storage.blob.models.BlobExpiryOptions
        :keyword expires_on: The time to set the blob to expiry. Required.
        :paramtype expires_on: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_expiry_request(
            container_name=container_name,
            blob=blob,
            expiry_options=expiry_options,
            expires_on=expires_on,
            version=version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_http_headers(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set HTTP Headers operation sets system properties on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_http_headers_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            blob_cache_control=blob_cache_control,
            blob_content_type=blob_content_type,
            blob_content_md5=blob_content_md5,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_immutability_policy(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """ "Set the immutability policy of a blob".

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_immutability_policy_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            if_unmodified_since=if_unmodified_since,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-immutability-policy-until-date"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-immutability-policy-until-date")
        )
        response_headers["x-ms-immutability-policy-mode"] = self._deserialize(
            "str", response.headers.get("x-ms-immutability-policy-mode")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def delete_immutability_policy(  # pylint: disable=inconsistent-return-statements
        self, container_name: str, blob: str, *, version: str, timeout: Optional[int] = None, **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Delete Immutability Policy operation deletes the immutability policy on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_delete_immutability_policy_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_legal_hold(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        legal_hold: bool,
        version: str,
        timeout: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Legal Hold operation sets a legal hold on the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword legal_hold: Required.  Specifies the legal hold status to set on the blob. Required.
        :paramtype legal_hold: bool
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_legal_hold_request(
            container_name=container_name,
            blob=blob,
            legal_hold=legal_hold,
            version=version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-legal-hold"] = self._deserialize("bool", response.headers.get("x-ms-legal-hold"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Metadata operation sets user-defined metadata for the specified blob as one or more
        name-value pairs.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_metadata_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def acquire_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        duration: int,
        version: str,
        timeout: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change. Required.
        :paramtype duration: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_acquire_lease_request(
            container_name=container_name,
            blob=blob,
            duration=duration,
            version=version,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def release_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_release_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def renew_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_renew_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def change_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        lease_id: str,
        version: str,
        timeout: Optional[int] = None,
        proposed_lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword lease_id: Required.  A lease ID for the source path. If specified, the source path
         must have an active lease and the lease ID must match. Required.
        :paramtype lease_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword proposed_lease_id: Optional.  The proposed lease ID for the container. Default value
         is None.
        :paramtype proposed_lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_change_lease_request(
            container_name=container_name,
            blob=blob,
            lease_id=lease_id,
            version=version,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-lease-id"] = self._deserialize("str", response.headers.get("x-ms-lease-id"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def break_lease(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        break_period: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """[Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
        operations.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword break_period: For a break operation, proposed duration the lease should continue
         before it is broken, in seconds, between 0 and 60. This break period is only used if it is
         shorter than the time remaining on the lease. If longer, the time remaining on the lease is
         used. A new lease will not be available before the break period has expired, but the lease may
         be held for longer than the break period. If this header does not appear with a break
         operation, a fixed-duration lease breaks after the remaining lease period elapses, and an
         infinite lease breaks immediately. Default value is None.
        :paramtype break_period: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_break_lease_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            break_period=break_period,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-lease-time"] = self._deserialize("int", response.headers.get("x-ms-lease-time"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def create_snapshot(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create Snapshot operation creates a read-only snapshot of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_create_snapshot_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-snapshot"] = self._deserialize("str", response.headers.get("x-ms-snapshot"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def start_copy_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        version: str,
        timeout: Optional[int] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
        source_if_modified_since: Optional[datetime.datetime] = None,
        source_if_unmodified_since: Optional[datetime.datetime] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        source_if_tags: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        seal_blob: Optional[bool] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Start Copy From URL operation copies a blob or an internet resource to a new blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword rehydrate_priority: Optional: Indicates the priority with which to rehydrate an
         archived blob. Known values are: "High" and "Standard". Default value is None.
        :paramtype rehydrate_priority: str or ~azure.storage.blob.models.RehydratePriority
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: ~datetime.datetime
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: ~datetime.datetime
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword source_if_tags: Specify a SQL where clause on blob tags to operate only on blobs with
         a matching value. Default value is None.
        :paramtype source_if_tags: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword seal_blob: Overrides the sealed state of the destination blob.  Service version
         2019-12-12 and newer. Default value is None.
        :paramtype seal_blob: bool
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_start_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            version=version,
            timeout=timeout,
            tier=tier,
            rehydrate_priority=rehydrate_priority,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            source_if_tags=source_if_tags,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            blob_tags_string=blob_tags_string,
            seal_blob=seal_blob,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def copy_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        version: str,
        timeout: Optional[int] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        source_if_modified_since: Optional[datetime.datetime] = None,
        source_if_unmodified_since: Optional[datetime.datetime] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        copy_source_authorization: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        copy_source_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Copy From URL operation copies a blob or an internet resource to a new blob. It will not
        return a response until the copy is complete.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: ~datetime.datetime
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: ~datetime.datetime
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword copy_source_tags: Optional, default 'replace'.  Indicates if source tags should be
         copied or replaced with the tags specified by x-ms-tags. Default value is None.
        :paramtype copy_source_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            version=version,
            timeout=timeout,
            tier=tier,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            source_content_md5=source_content_md5,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            copy_source_authorization=copy_source_authorization,
            encryption_scope=encryption_scope,
            copy_source_tags=copy_source_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def abort_copy_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        copy_id: str,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a
        destination blob with zero length and full metadata.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_id: The copy identifier provided in the x-ms-copy-id header of the original Copy
         Blob operation. Required.
        :paramtype copy_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_abort_copy_from_url_request(
            container_name=container_name,
            blob=blob,
            copy_id=copy_id,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def set_tier(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        access_tier: Union[str, _models.AccessTier],
        version: str,
        timeout: Optional[int] = None,
        rehydrate_priority: Optional[Union[str, _models.RehydratePriority]] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tier operation sets the tier on a block blob. The operation is allowed on a page blob
        or block blob, but not on an append blob. A block blob's tier determines Hot/Cool/Archive
        storage type. This operation does not update the blob's ETag.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword access_tier: Indicates the tier to be set on the blob. Known values are: "P4", "P6",
         "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive".
         Required.
        :paramtype access_tier: str or ~azure.storage.blob.models.AccessTier
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword rehydrate_priority: Optional: Indicates the priority with which to rehydrate an
         archived blob. Known values are: "High" and "Standard". Default value is None.
        :paramtype rehydrate_priority: str or ~azure.storage.blob.models.RehydratePriority
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_set_tier_request(
            container_name=container_name,
            blob=blob,
            access_tier=access_tier,
            version=version,
            timeout=timeout,
            rehydrate_priority=rehydrate_priority,
            lease_id=lease_id,
            if_tags=if_tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_account_info(  # pylint: disable=inconsistent-return-statements
        self, container_name: str, blob: str, *, version: str, **kwargs: Any
    ) -> None:
        """Returns the sku name and account kind.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_blob_get_account_info_request(
            container_name=container_name,
            blob=blob,
            version=version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-account-kind"] = self._deserialize("str", response.headers.get("x-ms-account-kind"))
        response_headers["x-ms-sku-name"] = self._deserialize("str", response.headers.get("x-ms-sku-name"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    def query(
        self,
        container_name: str,
        blob: str,
        query_request: _models.QueryRequest,
        *,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Query operation enables users to select/project on blob data by providing simple query
        expressions.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param query_request: The query request. Required.
        :type query_request: ~azure.storage.blob.models.QueryRequest
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query(
        self,
        container_name: str,
        blob: str,
        query_request: JSON,
        *,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Query operation enables users to select/project on blob data by providing simple query
        expressions.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param query_request: The query request. Required.
        :type query_request: JSON
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query(
        self,
        container_name: str,
        blob: str,
        query_request: IO[bytes],
        *,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Query operation enables users to select/project on blob data by providing simple query
        expressions.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param query_request: The query request. Required.
        :type query_request: IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def query(
        self,
        container_name: str,
        blob: str,
        query_request: Union[_models.QueryRequest, JSON, IO[bytes]],
        *,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> bytes:
        # pylint: disable=line-too-long
        """The Query operation enables users to select/project on blob data by providing simple query
        expressions.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param query_request: The query request. Is one of the following types: QueryRequest, JSON,
         IO[bytes] Required.
        :type query_request: ~azure.storage.blob.models.QueryRequest or JSON or IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[bytes] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(query_request, (IOBase, bytes)):
            _content = query_request
        else:
            _content = json.dumps(query_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_blob_query_request(
            container_name=container_name,
            blob=blob,
            version=version,
            snapshot=snapshot,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-Length"] = self._deserialize("int", response.headers.get("Content-Length"))
        response_headers["Content-Range"] = self._deserialize("str", response.headers.get("Content-Range"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["Content-Encoding"] = self._deserialize("str", response.headers.get("Content-Encoding"))
        response_headers["Cache-Control"] = self._deserialize("str", response.headers.get("Cache-Control"))
        response_headers["Content-Language"] = self._deserialize("str", response.headers.get("Content-Language"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["x-ms-blob-type"] = self._deserialize("str", response.headers.get("x-ms-blob-type"))
        response_headers["x-ms-copy-completion-time"] = self._deserialize(
            "rfc-1123", response.headers.get("x-ms-copy-completion-time")
        )
        response_headers["x-ms-copy-status-description"] = self._deserialize(
            "str", response.headers.get("x-ms-copy-status-description")
        )
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-progress"] = self._deserialize("str", response.headers.get("x-ms-copy-progress"))
        response_headers["x-ms-copy-source"] = self._deserialize("str", response.headers.get("x-ms-copy-source"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-lease-duration"] = self._deserialize("str", response.headers.get("x-ms-lease-duration"))
        response_headers["x-ms-lease-state"] = self._deserialize("str", response.headers.get("x-ms-lease-state"))
        response_headers["x-ms-lease-status"] = self._deserialize("str", response.headers.get("x-ms-lease-status"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Accept-Ranges"] = self._deserialize("str", response.headers.get("Accept-Ranges"))
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-blob-content-md5"] = self._deserialize(
            "str", response.headers.get("x-ms-blob-content-md5")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_tags(
        self,
        container_name: str,
        blob: str,
        *,
        version_id: str,
        version: str,
        timeout: Optional[int] = None,
        snapshot: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BlobTags:
        # pylint: disable=line-too-long
        """The Get Blob Tags operation enables users to get tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: BlobTags. The BlobTags is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.BlobTags
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BlobTags] = kwargs.pop("cls", None)

        _request = build_blob_get_tags_request(
            container_name=container_name,
            blob=blob,
            version_id=version_id,
            version=version,
            timeout=timeout,
            snapshot=snapshot,
            lease_id=lease_id,
            if_tags=if_tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BlobTags, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def set_tags(
        self,
        container_name: str,
        blob: str,
        tags: _models.BlobTags,
        *,
        version_id: str,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tags operation enables users to set tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param tags: The blob tags. Required.
        :type tags: ~azure.storage.blob.models.BlobTags
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_tags(
        self,
        container_name: str,
        blob: str,
        tags: JSON,
        *,
        version_id: str,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tags operation enables users to set tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param tags: The blob tags. Required.
        :type tags: JSON
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_tags(
        self,
        container_name: str,
        blob: str,
        tags: IO[bytes],
        *,
        version_id: str,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        if_tags: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tags operation enables users to set tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param tags: The blob tags. Required.
        :type tags: IO[bytes]
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def set_tags(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        tags: Union[_models.BlobTags, JSON, IO[bytes]],
        *,
        version_id: str,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Set Tags operation enables users to set tags on a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param tags: The blob tags. Is one of the following types: BlobTags, JSON, IO[bytes] Required.
        :type tags: ~azure.storage.blob.models.BlobTags or JSON or IO[bytes]
        :keyword version_id: The version id parameter is an opaque DateTime value that, when present,
         specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.
         Required.
        :paramtype version_id: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(tags, (IOBase, bytes)):
            _content = tags
        else:
            _content = json.dumps(tags, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_blob_set_tags_request(
            container_name=container_name,
            blob=blob,
            version_id=version_id,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            if_tags=if_tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class PageBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`page_blob` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        blob_content_length: int,
        version: str,
        timeout: Optional[int] = None,
        tier: Optional[Union[str, _models.PremiumPageBlobAccessTier]] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_sequence_number: Optional[int] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create operation creates a new page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword blob_content_length: This header specifies the maximum size for the page blob, up to 1
         TB. The page blob size must be aligned to a 512-byte boundary. Required.
        :paramtype blob_content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword tier: Optional. Indicates the tier to be set on the page blob. Known values are: "P4",
         "P6", "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", and "P80". Default value is None.
        :paramtype tier: str or ~azure.storage.blob.models.PremiumPageBlobAccessTier
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_sequence_number: Optional.  The sequence number is a user-controlled property
         that you can use to track requests. The value of the sequence number must be between 0 and 2^63
         - 1. The default value is 0. Default value is None.
        :paramtype blob_sequence_number: int
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_create_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            blob_content_length=blob_content_length,
            version=version,
            timeout=timeout,
            tier=tier,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            blob_sequence_number=blob_sequence_number,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def upload_pages(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        content_length: int,
        version: str,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Pages operation writes a range of pages to a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore

        _request = build_page_blob_upload_pages_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            version=version,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def clear_pages(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        version: str,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Clear Pages operation clears a range of pages from a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_clear_pages_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            version=version,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def upload_pages_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        source_url: str,
        source_range: str,
        range: str,
        version: str,
        timeout: Optional[int] = None,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_sequence_number_less_than_or_equal_to: Optional[int] = None,
        if_sequence_number_less_than: Optional[int] = None,
        if_sequence_number_equal_to: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        source_if_modified_since: Optional[datetime.datetime] = None,
        source_if_unmodified_since: Optional[datetime.datetime] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Pages operation writes a range of pages to a page blob where the contents are read
        from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword source_range: Bytes of source data in the specified range. The length of this range
         should match the ContentLength header and x-ms-range/Range destination range header. Required.
        :paramtype source_range: str
        :keyword range: Bytes of source data in the specified range. The length of this range should
         match the ContentLength header and x-ms-range/Range destination range header. Required.
        :paramtype range: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on
         a blob if it has a sequence number less than or equal to the specified. Default value is None.
        :paramtype if_sequence_number_less_than_or_equal_to: int
        :keyword if_sequence_number_less_than: Specify this header value to operate only on a blob if
         it has a sequence number less than the specified. Default value is None.
        :paramtype if_sequence_number_less_than: int
        :keyword if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
         has the specified sequence number. Default value is None.
        :paramtype if_sequence_number_equal_to: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: ~datetime.datetime
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: ~datetime.datetime
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_upload_pages_from_url_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            source_url=source_url,
            source_range=source_range,
            range=range,
            version=version,
            timeout=timeout,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            lease_id=lease_id,
            if_sequence_number_less_than_or_equal_to=if_sequence_number_less_than_or_equal_to,
            if_sequence_number_less_than=if_sequence_number_less_than,
            if_sequence_number_equal_to=if_sequence_number_equal_to,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            copy_source_authorization=copy_source_authorization,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_page_ranges(
        self,
        container_name: str,
        blob: str,
        *,
        version: str,
        snapshot: Optional[str] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.PageList:
        # pylint: disable=line-too-long
        """The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot
        of a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: PageList. The PageList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.PageList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PageList] = kwargs.pop("cls", None)

        _request = build_page_blob_get_page_ranges_request(
            container_name=container_name,
            blob=blob,
            version=version,
            snapshot=snapshot,
            range=range,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            marker=marker,
            maxresults=maxresults,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PageList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_page_ranges_diff(
        self,
        container_name: str,
        blob: str,
        *,
        prevsnapshot: str,
        prev_snapshot_url: str,
        version: str,
        snapshot: Optional[str] = None,
        timeout: Optional[int] = None,
        range: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        marker: Optional[str] = None,
        maxresults: Optional[int] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.PageList:
        # pylint: disable=line-too-long
        """The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob or
        snapshot of a page blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword prevsnapshot: Optional in version 2015-07-08 and newer. The prevsnapshot parameter is
         a DateTime value that specifies that the response will contain only pages that were changed
         between target blob and previous snapshot. Changed pages include both updated and cleared
         pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is
         the older of the two. Note that incremental snapshots are currently supported only for blobs
         created on or after January 1, 2016. Required.
        :paramtype prevsnapshot: str
        :keyword prev_snapshot_url: Optional. This header is only supported in service versions
         2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The
         response will only contain pages that were changed between the target blob and its previous
         snapshot. Required.
        :paramtype prev_snapshot_url: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword range: Return only the bytes of the blob in the specified range. Default value is
         None.
        :paramtype range: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword marker: A string value that identifies the portion of the list of containers to be
         returned with the next listing operation. The operation returns the NextMarker value within the
         response body if the listing operation did not return all containers remaining to be listed
         with the current page. The NextMarker value can be used as the value for the marker parameter
         in a subsequent call to request the next page of list items. The marker value is opaque to the
         client. Default value is None.
        :paramtype marker: str
        :keyword maxresults: Specifies the maximum number of containers to return. If the request does
         not specify maxresults, or specifies a value greater than 5000, the server will return up to
         5000 items. Default value is None.
        :paramtype maxresults: int
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: PageList. The PageList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.PageList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PageList] = kwargs.pop("cls", None)

        _request = build_page_blob_get_page_ranges_diff_request(
            container_name=container_name,
            blob=blob,
            prevsnapshot=prevsnapshot,
            prev_snapshot_url=prev_snapshot_url,
            version=version,
            snapshot=snapshot,
            timeout=timeout,
            range=range,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            marker=marker,
            maxresults=maxresults,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PageList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def resize(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        blob_content_length: int,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Resize operation increases the size of the page blob to the specified size.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword blob_content_length: This header specifies the maximum size for the page blob, up to 1
         TB. The page blob size must be aligned to a 512-byte boundary. Required.
        :paramtype blob_content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_resize_request(
            container_name=container_name,
            blob=blob,
            blob_content_length=blob_content_length,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def update_sequence_number(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        sequence_number_action: Union[str, _models.SequenceNumberActionType],
        blob_sequence_number: int,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Update Sequence Number operation sets the blob's sequence number. The operation will fail
        if the specified sequence number is less than the current sequence number of the blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword sequence_number_action: Required if the x-ms-blob-sequence-number header is set for
         the request. This property applies to page blobs only. This property indicates how the service
         should modify the blob's sequence number. Known values are: "increment", "max", and "update".
         Required.
        :paramtype sequence_number_action: str or ~azure.storage.blob.models.SequenceNumberActionType
        :keyword blob_sequence_number: Set for page blobs only. The sequence number is a
         user-controlled value that you can use to track requests. The value of the sequence number must
         be between 0 and 2^63 - 1. Required.
        :paramtype blob_sequence_number: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_update_sequence_number_request(
            container_name=container_name,
            blob=blob,
            sequence_number_action=sequence_number_action,
            blob_sequence_number=blob_sequence_number,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def copy_incremental(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        copy_source: str,
        version: str,
        timeout: Optional[int] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        lease_id: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Copy Incremental operation copies a snapshot of the source page blob to a destination page
        blob. The snapshot is copied such that only the differential changes between the previously
        copied snapshot are transferred to the destination. The copied snapshots are complete copies of
        the original snapshot and can be read or copied from as usual. This API is supported since REST
        version 2016-05-31.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_page_blob_copy_incremental_request(
            container_name=container_name,
            blob=blob,
            copy_source=copy_source,
            version=version,
            timeout=timeout,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            lease_id=lease_id,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-copy-id"] = self._deserialize("str", response.headers.get("x-ms-copy-id"))
        response_headers["x-ms-copy-status"] = self._deserialize("str", response.headers.get("x-ms-copy-status"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class AppendBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`append_blob` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        version: str,
        timeout: Optional[int] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Create operation creates a new append blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_create_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            version=version,
            timeout=timeout,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def append_block(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        content_length: int,
        max_size: int,
        append_position: int,
        version: str,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Append Block operation commits a new block of data to the end of an append blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword max_size: Optional conditional header. The max length in bytes permitted for the
         append blob. If the Append Block operation would cause the blob to exceed that limit or if the
         blob size is already greater than the value specified in this header, the request will fail
         with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed). Required.
        :paramtype max_size: int
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Required.
        :paramtype append_position: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore

        _request = build_append_blob_append_block_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            max_size=max_size,
            append_position=append_position,
            version=version,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["x-ms-blob-sequence-number"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-sequence-number")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-append-offset"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-append-offset")
        )
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def append_block_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        source_url: str,
        source_range: str,
        max_size: int,
        append_position: int,
        version: str,
        timeout: Optional[int] = None,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Append Block From URL operation creates a new block to be committed as part of an append
        blob where the contents are read from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword source_range: Bytes of source data in the specified range. Required.
        :paramtype source_range: str
        :keyword max_size: Optional conditional header. The max length in bytes permitted for the
         append blob. If the Append Block operation would cause the blob to exceed that limit or if the
         blob size is already greater than the value specified in this header, the request will fail
         with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed). Required.
        :paramtype max_size: int
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Required.
        :paramtype append_position: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_append_block_from_url_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            source_url=source_url,
            source_range=source_range,
            max_size=max_size,
            append_position=append_position,
            version=version,
            timeout=timeout,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            copy_source_authorization=copy_source_authorization,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-blob-append-offset"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-append-offset")
        )
        response_headers["x-ms-blob-committed-block-count"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-committed-block-count")
        )
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def seal(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        append_position: int,
        version: str,
        timeout: Optional[int] = None,
        lease_id: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Seal operation seals the Append Blob to make it read-only. Seal is supported only on
        version 2019-12-12 version or later.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword append_position: Optional conditional header, used only for the Append Block
         operation. A number indicating the byte offset to compare. Append Block will succeed only if
         the append position is equal to this number. If it is not, the request will fail with the
         AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed). Required.
        :paramtype append_position: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_append_blob_seal_request(
            container_name=container_name,
            blob=blob,
            append_position=append_position,
            version=version,
            timeout=timeout,
            lease_id=lease_id,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-blob-sealed"] = self._deserialize("bool", response.headers.get("x-ms-blob-sealed"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class BlockBlobOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.blob.BlobClient`'s
        :attr:`block_blob` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def upload(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        version: str,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        transactional_content_crc64: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Upload Block Blob operation updates the content of an existing block blob. Updating an
        existing block blob overwrites any existing metadata on the blob. Partial updates are not
        supported with Put Blob; the content of the existing blob is overwritten with the content of
        the new blob. To perform a partial update of the content of a block blob, use the Put Block
        List operation.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore

        _request = build_block_blob_upload_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            transactional_content_crc64=transactional_content_crc64,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-version-id"] = self._deserialize("str", response.headers.get("x-ms-version-id"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def put_blob_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        content_length: int,
        copy_source: str,
        version: str,
        timeout: Optional[int] = None,
        transactional_content_md5: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        blob_cache_control: Optional[str] = None,
        lease_id: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        source_if_modified_since: Optional[datetime.datetime] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        source_if_tags: Optional[str] = None,
        source_content_md5: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        copy_source_blob_properties: Optional[bool] = None,
        copy_source_authorization: Optional[str] = None,
        copy_source_tags: Optional[str] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Put Blob from URL operation creates a new Block Blob where the contents of the blob are
        read from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial
        updates are not supported with Put Blob from URL; the content of an existing blob is
        overwritten with the content of the new blob.  To perform partial updates to a block blobs
        contents using a source URL, use the Put Block from URL API in conjunction with Put Block List.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword copy_source: Specifies the name of the source page blob snapshot. This value is a URL
         of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as
         it would appear in a request URI. The source blob must either be public or must be
         authenticated via a shared access signature. Required.
        :paramtype copy_source: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: ~datetime.datetime
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword source_if_tags: Specify a SQL where clause on blob tags to operate only on blobs with
         a matching value. Default value is None.
        :paramtype source_if_tags: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword copy_source_blob_properties: Optional, default is true.  Indicates if properties from
         the source blob should be copied. Default value is None.
        :paramtype copy_source_blob_properties: bool
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :keyword copy_source_tags: Optional, default 'replace'.  Indicates if source tags should be
         copied or replaced with the tags specified by x-ms-tags. Default value is None.
        :paramtype copy_source_tags: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_block_blob_put_blob_from_url_request(
            container_name=container_name,
            blob=blob,
            content_length=content_length,
            copy_source=copy_source,
            version=version,
            timeout=timeout,
            transactional_content_md5=transactional_content_md5,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            blob_cache_control=blob_cache_control,
            lease_id=lease_id,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            source_if_modified_since=source_if_modified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            source_if_tags=source_if_tags,
            source_content_md5=source_content_md5,
            blob_tags_string=blob_tags_string,
            copy_source_blob_properties=copy_source_blob_properties,
            copy_source_authorization=copy_source_authorization,
            copy_source_tags=copy_source_tags,
            etag=etag,
            match_condition=match_condition,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def stage_block(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        body: bytes,
        *,
        block_id: str,
        content_length: int,
        version: str,
        transactional_content_md5: Optional[str] = None,
        timeout: Optional[int] = None,
        transactional_content_crc64: Optional[str] = None,
        lease_id: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Stage Block operation creates a new block to be committed as part of a blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param body: The body of the request. Required.
        :type body: bytes
        :keyword block_id: A valid Base64 string value that identifies the block. Prior to encoding,
         the string must be less than or equal to 64 bytes in size. For a given blob, the length of the
         value specified for the blockid parameter must be the same size for each block. Required.
        :paramtype block_id: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore

        _request = build_block_blob_stage_block_request(
            container_name=container_name,
            blob=blob,
            block_id=block_id,
            content_length=content_length,
            version=version,
            transactional_content_md5=transactional_content_md5,
            timeout=timeout,
            transactional_content_crc64=transactional_content_crc64,
            lease_id=lease_id,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def stage_block_from_url(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        *,
        block_id: str,
        content_length: int,
        source_url: str,
        source_range: str,
        version: str,
        source_content_md5: Optional[str] = None,
        source_content_crc64: Optional[str] = None,
        timeout: Optional[int] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        lease_id: Optional[str] = None,
        source_if_modified_since: Optional[datetime.datetime] = None,
        source_if_unmodified_since: Optional[datetime.datetime] = None,
        source_if_match: Optional[str] = None,
        source_if_none_match: Optional[str] = None,
        copy_source_authorization: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Stage Block From URL operation creates a new block to be committed as part of a blob where
        the contents are read from a URL.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword block_id: A valid Base64 string value that identifies the block. Prior to encoding,
         the string must be less than or equal to 64 bytes in size. For a given blob, the length of the
         value specified for the blockid parameter must be the same size for each block. Required.
        :paramtype block_id: str
        :keyword content_length: The length of the request. Required.
        :paramtype content_length: int
        :keyword source_url: Specify a URL to the copy source. Required.
        :paramtype source_url: str
        :keyword source_range: Bytes of source data in the specified range. Required.
        :paramtype source_range: str
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword source_content_md5: Specify the md5 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_md5: str
        :keyword source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source. Default value is None.
        :paramtype source_content_crc64: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword source_if_modified_since: Specify this header value to operate only on a blob if it
         has been modified since the specified date/time. Default value is None.
        :paramtype source_if_modified_since: ~datetime.datetime
        :keyword source_if_unmodified_since: Specify this header value to operate only on a blob if it
         has not been modified since the specified date/time. Default value is None.
        :paramtype source_if_unmodified_since: ~datetime.datetime
        :keyword source_if_match: Specify an ETag value to operate only on blobs with a matching value.
         Default value is None.
        :paramtype source_if_match: str
        :keyword source_if_none_match: Specify this header value to operate only on a blob if it has
         been modified since the specified date/time. Default value is None.
        :paramtype source_if_none_match: str
        :keyword copy_source_authorization: Only Bearer type is supported. Credentials should be a
         valid OAuth access token to copy source. Default value is None.
        :paramtype copy_source_authorization: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_block_blob_stage_block_from_url_request(
            container_name=container_name,
            blob=blob,
            block_id=block_id,
            content_length=content_length,
            source_url=source_url,
            source_range=source_range,
            version=version,
            source_content_md5=source_content_md5,
            source_content_crc64=source_content_crc64,
            timeout=timeout,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            lease_id=lease_id,
            source_if_modified_since=source_if_modified_since,
            source_if_unmodified_since=source_if_unmodified_since,
            source_if_match=source_if_match,
            source_if_none_match=source_if_none_match,
            copy_source_authorization=copy_source_authorization,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    def commit_block_list(
        self,
        container_name: str,
        blob: str,
        blocks: _models.BlockLookupList,
        *,
        version: str,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Commit Block List operation writes a blob by specifying the list of block IDs that make up
        the blob. In order to be written as part of a blob, a block must have been successfully written
        to the server in a prior Put Block operation. You can call Put Block List to update a blob by
        uploading only those blocks that have changed, then committing the new and existing blocks
        together. You can do this by specifying whether to commit a block from the committed block list
        or from the uncommitted block list, or to commit the most recently uploaded version of the
        block, whichever list it may belong to.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param blocks: Blob Blocks. Required.
        :type blocks: ~azure.storage.blob.models.BlockLookupList
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def commit_block_list(
        self,
        container_name: str,
        blob: str,
        blocks: JSON,
        *,
        version: str,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Commit Block List operation writes a blob by specifying the list of block IDs that make up
        the blob. In order to be written as part of a blob, a block must have been successfully written
        to the server in a prior Put Block operation. You can call Put Block List to update a blob by
        uploading only those blocks that have changed, then committing the new and existing blocks
        together. You can do this by specifying whether to commit a block from the committed block list
        or from the uncommitted block list, or to commit the most recently uploaded version of the
        block, whichever list it may belong to.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param blocks: Blob Blocks. Required.
        :type blocks: JSON
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def commit_block_list(
        self,
        container_name: str,
        blob: str,
        blocks: IO[bytes],
        *,
        version: str,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Commit Block List operation writes a blob by specifying the list of block IDs that make up
        the blob. In order to be written as part of a blob, a block must have been successfully written
        to the server in a prior Put Block operation. You can call Put Block List to update a blob by
        uploading only those blocks that have changed, then committing the new and existing blocks
        together. You can do this by specifying whether to commit a block from the committed block list
        or from the uncommitted block list, or to commit the most recently uploaded version of the
        block, whichever list it may belong to.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param blocks: Blob Blocks. Required.
        :type blocks: IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def commit_block_list(  # pylint: disable=inconsistent-return-statements
        self,
        container_name: str,
        blob: str,
        blocks: Union[_models.BlockLookupList, JSON, IO[bytes]],
        *,
        version: str,
        timeout: Optional[int] = None,
        blob_cache_control: Optional[str] = None,
        blob_content_type: Optional[str] = None,
        blob_content_encoding: Optional[str] = None,
        blob_content_language: Optional[str] = None,
        blob_content_md5: Optional[str] = None,
        transactional_content_md5: Optional[str] = None,
        transactional_content_crc64: Optional[str] = None,
        blob_content_disposition: Optional[str] = None,
        encryption_key: Optional[str] = None,
        encryption_key_sha256: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
        encryption_scope: Optional[str] = None,
        tier: Optional[Union[str, _models.AccessTier]] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        if_tags: Optional[str] = None,
        blob_tags_string: Optional[str] = None,
        immutability_policy_expiry: Optional[str] = None,
        immutability_policy_mode: Optional[Union[str, _models.BlobImmutabilityPolicyMode]] = None,
        legal_hold: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The Commit Block List operation writes a blob by specifying the list of block IDs that make up
        the blob. In order to be written as part of a blob, a block must have been successfully written
        to the server in a prior Put Block operation. You can call Put Block List to update a blob by
        uploading only those blocks that have changed, then committing the new and existing blocks
        together. You can do this by specifying whether to commit a block from the committed block list
        or from the uncommitted block list, or to commit the most recently uploaded version of the
        block, whichever list it may belong to.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :param blocks: Blob Blocks. Is one of the following types: BlockLookupList, JSON, IO[bytes]
         Required.
        :type blocks: ~azure.storage.blob.models.BlockLookupList or JSON or IO[bytes]
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :paramtype timeout: int
        :keyword blob_cache_control: Optional. Sets the blob's cache control. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_cache_control: str
        :keyword blob_content_type: Optional. Sets the blob's content type. If specified, this property
         is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_type: str
        :keyword blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_encoding: str
        :keyword blob_content_language: Optional. Set the blob's content language. If specified, this
         property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_language: str
        :keyword blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is
         not validated, as the hashes for the individual blocks were validated when each was uploaded.
         Default value is None.
        :paramtype blob_content_md5: str
        :keyword transactional_content_md5: Optional. An MD5 hash of the blob content. Note that this
         hash is not validated, as the hashes for the individual blocks were validated when each was
         uploaded. Default value is None.
        :paramtype transactional_content_md5: str
        :keyword transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :paramtype transactional_content_crc64: str
        :keyword blob_content_disposition: Optional. Sets the blob's content disposition. If specified,
         this property is stored with the blob and returned with a read request. Default value is None.
        :paramtype blob_content_disposition: str
        :keyword encryption_key: Optional.  Version 2019-07-07 and later.  Specifies the encryption key
         to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_key: str
        :keyword encryption_key_sha256: Optional.  Version 2019-07-07 and later.  Specifies the SHA256
         hash of the encryption key used to encrypt the data provided in the request. This header is
         only used for encryption with a customer-provided key. If the request is authenticated with a
         client token, this header should be specified using the SHA256 hash of the encryption key.
         Default value is None.
        :paramtype encryption_key_sha256: str
        :keyword encryption_algorithm: Optional.  Version 2019-07-07 and later.  Specifies the
         algorithm to use for encryption. If not specified, the default is AES256. Default value is
         None.
        :paramtype encryption_algorithm: str
        :keyword encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the encryption
         scope to use to encrypt the data provided in the request. If not specified, the request will be
         encrypted with the root account key. Default value is None.
        :paramtype encryption_scope: str
        :keyword tier: Optional.  The tier to be set on the blob. Known values are: "P4", "P6", "P10",
         "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", and "Archive". Default
         value is None.
        :paramtype tier: str or ~azure.storage.blob.models.AccessTier
        :keyword if_modified_since: A date-time value. A request is made under the condition that the
         resource has been modified since the specified date-time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A date-time value. A request is made under the condition that the
         resource has not been modified since the specified date-time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :keyword blob_tags_string: Optional.  Used to set blob tags in various blob operations. Default
         value is None.
        :paramtype blob_tags_string: str
        :keyword immutability_policy_expiry: Specifies the date time when the blobs immutability policy
         is set to expire. Default value is None.
        :paramtype immutability_policy_expiry: str
        :keyword immutability_policy_mode: Specifies the immutability policy mode to set on the blob.
         Known values are: "Mutable", "Locked", and "Unlocked". Default value is None.
        :paramtype immutability_policy_mode: str or
         ~azure.storage.blob.models.BlobImmutabilityPolicyMode
        :keyword legal_hold: Specified if a legal hold should be set on the blob. Default value is
         None.
        :paramtype legal_hold: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(blocks, (IOBase, bytes)):
            _content = blocks
        else:
            _content = json.dumps(blocks, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_block_blob_commit_block_list_request(
            container_name=container_name,
            blob=blob,
            version=version,
            timeout=timeout,
            blob_cache_control=blob_cache_control,
            blob_content_type=blob_content_type,
            blob_content_encoding=blob_content_encoding,
            blob_content_language=blob_content_language,
            blob_content_md5=blob_content_md5,
            transactional_content_md5=transactional_content_md5,
            transactional_content_crc64=transactional_content_crc64,
            blob_content_disposition=blob_content_disposition,
            encryption_key=encryption_key,
            encryption_key_sha256=encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            encryption_scope=encryption_scope,
            tier=tier,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            if_tags=if_tags,
            blob_tags_string=blob_tags_string,
            immutability_policy_expiry=immutability_policy_expiry,
            immutability_policy_mode=immutability_policy_mode,
            legal_hold=legal_hold,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["Content-MD5"] = self._deserialize("str", response.headers.get("Content-MD5"))
        response_headers["x-ms-content-crc64"] = self._deserialize("str", response.headers.get("x-ms-content-crc64"))
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-request-server-encrypted"] = self._deserialize(
            "bool", response.headers.get("x-ms-request-server-encrypted")
        )
        response_headers["x-ms-encryption-key-sha256"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-key-sha256")
        )
        response_headers["x-ms-encryption-scope"] = self._deserialize(
            "str", response.headers.get("x-ms-encryption-scope")
        )
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def get_block_list(
        self,
        container_name: str,
        blob: str,
        *,
        list_type: Union[str, _models.BlockListType],
        version: str,
        snapshot: Optional[str] = None,
        lease_id: Optional[str] = None,
        if_tags: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BlockLookupList:
        # pylint: disable=line-too-long
        """The Get Block List operation retrieves the list of blocks that have been uploaded as part of a
        block blob.

        :param container_name: The name of the container. Required.
        :type container_name: str
        :param blob: The name of the blob. Required.
        :type blob: str
        :keyword list_type: Specifies whether to return the list of committed blocks, the list of
         uncommitted blocks, or both lists together. Known values are: "committed", "uncommitted", and
         "all". Required.
        :paramtype list_type: str or ~azure.storage.blob.models.BlockListType
        :keyword version: Specifies the version of the operation to use for this request. Required.
        :paramtype version: str
        :keyword snapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the blob snapshot to retrieve. For more information on working with blob snapshots,
         see :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating
         a Snapshot of a Blob.</a>`. Default value is None.
        :paramtype snapshot: str
        :keyword lease_id: If specified, the operation only succeeds if the resource's lease is active
         and matches this ID. Default value is None.
        :paramtype lease_id: str
        :keyword if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
         matching value. Default value is None.
        :paramtype if_tags: str
        :return: BlockLookupList. The BlockLookupList is compatible with MutableMapping
        :rtype: ~azure.storage.blob.models.BlockLookupList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BlockLookupList] = kwargs.pop("cls", None)

        _request = build_block_blob_get_block_list_request(
            container_name=container_name,
            blob=blob,
            list_type=list_type,
            version=version,
            snapshot=snapshot,
            lease_id=lease_id,
            if_tags=if_tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.StorageError, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Last-Modified"] = self._deserialize("rfc-1123", response.headers.get("Last-Modified"))
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))
        response_headers["x-ms-blob-content-length"] = self._deserialize(
            "int", response.headers.get("x-ms-blob-content-length")
        )
        response_headers["Date"] = self._deserialize("rfc-1123", response.headers.get("Date"))
        response_headers["x-ms-version"] = self._deserialize("str", response.headers.get("x-ms-version"))
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["x-ms-client-request-id"] = self._deserialize(
            "str", response.headers.get("x-ms-client-request-id")
        )

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BlockLookupList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
