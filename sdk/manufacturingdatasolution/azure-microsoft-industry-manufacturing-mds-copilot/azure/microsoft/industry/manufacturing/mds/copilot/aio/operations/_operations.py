# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, AsyncIterable, AsyncIterator, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ..._serialization import Deserializer, Serializer
from ...operations._operations import (
    build_aliases_service_client_create_or_replace_request,
    build_aliases_service_client_delete_request,
    build_aliases_service_client_get_request,
    build_aliases_service_client_list_request,
    build_heath_service_client_get_service_health_request,
    build_instructions_instruction_service_client_create_or_replace_request,
    build_instructions_instruction_service_client_create_request,
    build_instructions_instruction_service_client_delete_request,
    build_instructions_instruction_service_client_get_request,
    build_instructions_instruction_service_client_list_request,
    build_operation_service_client_get_operation_result_request,
    build_query_example_service_client_create_or_replace_request,
    build_query_example_service_client_delete_example_request,
    build_query_example_service_client_get_example_request,
    build_query_example_service_client_list_all_examples_request,
    build_query_service_client_query_execute_request,
    build_query_service_client_submit_feedback_request,
)
from .._configuration import CopilotServiceClientConfiguration

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`models` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class InstructionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`instructions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        self.instruction_service_client = InstructionsInstructionServiceClientOperations(
            self._client, self._config, self._serialize, self._deserialize
        )


class QueryServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`query_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def query_execute(
        self,
        request: _models.UserQueryRequest,
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: ~azure.microsoft.industry.manufacturing.mds.copilot.models.UserQueryRequest
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def query_execute(
        self,
        request: JSON,
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: JSON
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def query_execute(
        self,
        request: IO[bytes],
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: IO[bytes]
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def query_execute(
        self,
        request: Union[_models.UserQueryRequest, JSON, IO[bytes]],
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        **kwargs: Any
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Is one of the following types: UserQueryRequest, JSON, IO[bytes]
         Required.
        :type request: ~azure.microsoft.industry.manufacturing.mds.copilot.models.UserQueryRequest or
         JSON or IO[bytes]
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.QueryResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_service_client_query_execute_request(
            conversation_id=conversation_id,
            accept_language=accept_language,
            max_retry=max_retry,
            data_table_format=data_table_format,
            include_summary=include_summary,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.QueryResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def submit_feedback(
        self,
        *,
        feedback: Union[str, _models.FeedbackCategory],
        query_endpoint: Union[str, _models.QueryEndpoint],
        content_type: str = "application/json",
        conversation_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :keyword feedback: The feedback. Known values are: "Neutral", "ThumbUp", and "ThumbDown".
         Required.
        :paramtype feedback: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.FeedbackCategory
        :keyword query_endpoint: QueryEndpoint. Known values are: "V3" and "Assistant". Required.
        :paramtype query_endpoint: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryEndpoint
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def submit_feedback(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def submit_feedback(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def submit_feedback(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        feedback: Union[str, _models.FeedbackCategory] = _Unset,
        query_endpoint: Union[str, _models.QueryEndpoint] = _Unset,
        conversation_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword feedback: The feedback. Known values are: "Neutral", "ThumbUp", and "ThumbDown".
         Required.
        :paramtype feedback: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.FeedbackCategory
        :keyword query_endpoint: QueryEndpoint. Known values are: "V3" and "Assistant". Required.
        :paramtype query_endpoint: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryEndpoint
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SubmitFeedbackResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if feedback is _Unset:
                raise TypeError("missing required argument: feedback")
            if query_endpoint is _Unset:
                raise TypeError("missing required argument: query_endpoint")
            body = {"conversationId": conversation_id, "feedback": feedback, "queryEndpoint": query_endpoint}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_service_client_submit_feedback_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SubmitFeedbackResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class OperationServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`operation_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_operation_result(self, id: str, **kwargs: Any) -> _models.GetOperationResultResponse:
        """Get operation progress.

        :param id: The operation id. Required.
        :type id: str
        :return: GetOperationResultResponse. The GetOperationResultResponse is compatible with
         MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.GetOperationResultResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetOperationResultResponse] = kwargs.pop("cls", None)

        _request = build_operation_service_client_get_operation_result_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetOperationResultResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class QueryExampleServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`query_example_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_example(self, example_id: str, **kwargs: Any) -> _models.ExampleQueryRequest:
        """get the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExampleQueryRequest] = kwargs.pop("cls", None)

        _request = build_query_example_service_client_get_example_request(
            example_id=example_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExampleQueryRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_all_examples(
        self, *, instruction_id: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.ExampleQueryRequest"]:
        """get all example queries.

        :keyword instruction_id: Instruction id. Default value is None.
        :paramtype instruction_id: str
        :return: An iterator like instance of ExampleQueryRequest
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExampleQueryRequest]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_query_example_service_client_list_all_examples_request(
                    instruction_id=instruction_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExampleQueryRequest], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_replace(
        self,
        example_id: str,
        resource: _models.ExampleQueryRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_replace(
        self, example_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_replace(
        self, example_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_replace(
        self, example_id: str, resource: Union[_models.ExampleQueryRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Is one of the following types: ExampleQueryRequest,
         JSON, IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
         or JSON or IO[bytes]
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExampleQueryRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_example_service_client_create_or_replace_request(
            example_id=example_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExampleQueryRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_example(self, example_id: str, **kwargs: Any) -> None:
        """delete the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_query_example_service_client_delete_example_request(
            example_id=example_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class AliasesServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`aliases_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, id: str, **kwargs: Any) -> _models.GetResponse:
        """Get an alias by Id.

        :param id: Id for the alias. Required.
        :type id: str
        :return: GetResponse. The GetResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.GetResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetResponse] = kwargs.pop("cls", None)

        _request = build_aliases_service_client_get_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_replace_initial(
        self, id: str, resource: Union[_models.Alias, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_aliases_service_client_create_or_replace_request(
            id=id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: _models.Alias, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_replace(
        self, id: str, resource: Union[_models.Alias, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Is one of the following types: Alias, JSON, IO[bytes]
         Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias or JSON or
         IO[bytes]
        :return: An instance of AsyncLROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Alias] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_replace_initial(
                id=id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.Alias, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Alias].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Alias](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace_async
    async def delete(self, id: str, **kwargs: Any) -> None:
        """Delete an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_aliases_service_client_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Alias"]:
        """List all aliases.

        :return: An iterator like instance of Alias
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Alias]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_aliases_service_client_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Alias], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class HeathServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`heath_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_service_health(self, **kwargs: Any) -> _models.CopilotHealth:
        """Get the health status of the service.

        :return: CopilotHealth. The CopilotHealth is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.CopilotHealth
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CopilotHealth] = kwargs.pop("cls", None)

        _request = build_heath_service_client_get_service_health_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CopilotHealth, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class InstructionsInstructionServiceClientOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.aio.CopilotServiceClient`'s
        :attr:`instruction_service_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, id: str, **kwargs: Any) -> _models.Instruction:
        """Gets single instruction.

        :param id: Id for the instruction. Required.
        :type id: str
        :return: Instruction. The Instruction is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)

        _request = build_instructions_instruction_service_client_get_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Instruction, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, *, state: Union[str, _models.ResourceState], **kwargs: Any) -> AsyncIterable["_models.Instruction"]:
        """List Instruction resources.

        :keyword state: Get all active instructions by state. Known values are: "Active" and
         "Inactive". Required.
        :paramtype state: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.ResourceState
        :return: An iterator like instance of Instruction
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Instruction]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_instructions_instruction_service_client_list_request(
                    state=state,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Instruction], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _create_initial(
        self, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instructions_instruction_service_client_create_request(
            api_version=self._config.api_version,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create(
        self, resource: _models.Instruction, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create(
        self, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create(
        self, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Is one of the following types: Instruction, JSON,
         IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction or JSON
         or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_initial(
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["operation-location"] = self._deserialize(
                "str", response.headers.get("operation-location")
            )

            deserialized = _deserialize(_models.Instruction, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Instruction].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Instruction](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _create_or_replace_initial(
        self, id: str, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instructions_instruction_service_client_create_or_replace_request(
            id=id,
            api_version=self._config.api_version,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: _models.Instruction, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_replace(
        self, id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_replace(
        self, id: str, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Is one of the following types: Instruction, JSON,
         IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction or JSON
         or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Instruction. The Instruction is compatible
         with MutableMapping
        :rtype:
         ~azure.core.polling.AsyncLROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_replace_initial(
                id=id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.Instruction, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Instruction].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Instruction](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    async def _delete_initial(self, id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_instructions_instruction_service_client_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def begin_delete(self, id: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Delete instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._delete_initial(
                id=id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod,
                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
