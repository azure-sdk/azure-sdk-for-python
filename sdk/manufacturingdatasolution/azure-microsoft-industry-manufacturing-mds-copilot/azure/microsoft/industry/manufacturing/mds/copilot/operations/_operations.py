# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._configuration import CopilotServiceClientConfiguration
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Deserializer, Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_query_service_client_query_execute_request(  # pylint: disable=name-too-long
    *,
    conversation_id: Optional[str] = None,
    accept_language: Optional[str] = None,
    max_retry: Optional[int] = None,
    data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
    include_summary: Optional[Union[str, _models.Choice]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/query"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if max_retry is not None:
        _params["maxRetry"] = _SERIALIZER.query("max_retry", max_retry, "int")
    if data_table_format is not None:
        _params["dataTableFormat"] = _SERIALIZER.query("data_table_format", data_table_format, "str")
    if include_summary is not None:
        _params["includeSummary"] = _SERIALIZER.query("include_summary", include_summary, "str")

    # Construct headers
    if conversation_id is not None:
        _headers["conversation-id"] = _SERIALIZER.header("conversation_id", conversation_id, "str")
    if accept_language is not None:
        _headers["Accept-Language"] = _SERIALIZER.header("accept_language", accept_language, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_service_client_submit_feedback_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/query:submitFeedback"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_operation_service_client_get_operation_result_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/operation/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_example_service_client_get_example_request(  # pylint: disable=name-too-long
    example_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/queryExamples/{exampleId}"
    path_format_arguments = {
        "exampleId": _SERIALIZER.url("example_id", example_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_example_service_client_list_all_examples_request(  # pylint: disable=name-too-long
    *, instruction_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/queryExamples"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if instruction_id is not None:
        _params["instructionId"] = _SERIALIZER.query("instruction_id", instruction_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_example_service_client_create_or_replace_request(  # pylint: disable=name-too-long
    example_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/queryExamples/{exampleId}"
    path_format_arguments = {
        "exampleId": _SERIALIZER.url("example_id", example_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_example_service_client_delete_example_request(  # pylint: disable=name-too-long
    example_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/queryExamples/{exampleId}"
    path_format_arguments = {
        "exampleId": _SERIALIZER.url("example_id", example_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_aliases_service_client_get_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/aliases/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_aliases_service_client_create_or_replace_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/aliases/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_aliases_service_client_delete_request(id: str, **kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/aliases/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_aliases_service_client_list_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/aliases"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_heath_service_client_get_service_health_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/health"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instructions_instruction_service_client_get_request(  # pylint: disable=name-too-long
    id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/instructions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instructions_instruction_service_client_list_request(  # pylint: disable=name-too-long
    *, state: Union[str, _models.ResourceState], api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/instructions"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["state"] = _SERIALIZER.query("state", state, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instructions_instruction_service_client_create_request(  # pylint: disable=name-too-long
    *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/instructions"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_instructions_instruction_service_client_create_or_replace_request(  # pylint: disable=name-too-long
    id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/instructions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_instructions_instruction_service_client_delete_request(  # pylint: disable=name-too-long
    id: str, *, api_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/copilot/instructions/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class ModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`models` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class InstructionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`instructions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        self.instruction_service_client = InstructionsInstructionServiceClientOperations(
            self._client, self._config, self._serialize, self._deserialize
        )


class QueryServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`query_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def query_execute(
        self,
        request: _models.UserQueryRequest,
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: ~azure.microsoft.industry.manufacturing.mds.copilot.models.UserQueryRequest
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query_execute(
        self,
        request: JSON,
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: JSON
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query_execute(
        self,
        request: IO[bytes],
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Required.
        :type request: IO[bytes]
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def query_execute(
        self,
        request: Union[_models.UserQueryRequest, JSON, IO[bytes]],
        *,
        conversation_id: Optional[str] = None,
        accept_language: Optional[str] = None,
        max_retry: Optional[int] = None,
        data_table_format: Optional[Union[str, _models.DataTableFormat]] = None,
        include_summary: Optional[Union[str, _models.Choice]] = None,
        **kwargs: Any,
    ) -> _models.QueryResponse:
        """execute the query.

        :param request: request body. Is one of the following types: UserQueryRequest, JSON, IO[bytes]
         Required.
        :type request: ~azure.microsoft.industry.manufacturing.mds.copilot.models.UserQueryRequest or
         JSON or IO[bytes]
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :keyword accept_language: Accept-Language header. Default value is None.
        :paramtype accept_language: str
        :keyword max_retry: maximum number of retries. Default value is None.
        :paramtype max_retry: int
        :keyword data_table_format: Supported datatable format: Markdown, Json. Default is Json. Known
         values are: "Markdown" and "Json". Default value is None.
        :paramtype data_table_format: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.DataTableFormat
        :keyword include_summary: Include summary in the response. Known values are: "Yes" and "No".
         Default value is None.
        :paramtype include_summary: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.Choice
        :return: QueryResponse. The QueryResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.QueryResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_service_client_query_execute_request(
            conversation_id=conversation_id,
            accept_language=accept_language,
            max_retry=max_retry,
            data_table_format=data_table_format,
            include_summary=include_summary,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.QueryResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def submit_feedback(
        self,
        *,
        feedback: Union[str, _models.FeedbackCategory],
        query_endpoint: Union[str, _models.QueryEndpoint],
        content_type: str = "application/json",
        conversation_id: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :keyword feedback: The feedback. Known values are: "Neutral", "ThumbUp", and "ThumbDown".
         Required.
        :paramtype feedback: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.FeedbackCategory
        :keyword query_endpoint: QueryEndpoint. Known values are: "V3" and "Assistant". Required.
        :paramtype query_endpoint: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryEndpoint
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def submit_feedback(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def submit_feedback(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def submit_feedback(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        feedback: Union[str, _models.FeedbackCategory] = _Unset,
        query_endpoint: Union[str, _models.QueryEndpoint] = _Unset,
        conversation_id: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.SubmitFeedbackResponse:
        """Share feedback for the copilot's query response.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword feedback: The feedback. Known values are: "Neutral", "ThumbUp", and "ThumbDown".
         Required.
        :paramtype feedback: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.FeedbackCategory
        :keyword query_endpoint: QueryEndpoint. Known values are: "V3" and "Assistant". Required.
        :paramtype query_endpoint: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.QueryEndpoint
        :keyword conversation_id: conversation id. Default value is None.
        :paramtype conversation_id: str
        :return: SubmitFeedbackResponse. The SubmitFeedbackResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.SubmitFeedbackResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SubmitFeedbackResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if feedback is _Unset:
                raise TypeError("missing required argument: feedback")
            if query_endpoint is _Unset:
                raise TypeError("missing required argument: query_endpoint")
            body = {"conversationId": conversation_id, "feedback": feedback, "queryEndpoint": query_endpoint}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_service_client_submit_feedback_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SubmitFeedbackResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class OperationServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`operation_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_operation_result(self, id: str, **kwargs: Any) -> _models.GetOperationResultResponse:
        """Get operation progress.

        :param id: The operation id. Required.
        :type id: str
        :return: GetOperationResultResponse. The GetOperationResultResponse is compatible with
         MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.GetOperationResultResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetOperationResultResponse] = kwargs.pop("cls", None)

        _request = build_operation_service_client_get_operation_result_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetOperationResultResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class QueryExampleServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`query_example_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_example(self, example_id: str, **kwargs: Any) -> _models.ExampleQueryRequest:
        """get the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExampleQueryRequest] = kwargs.pop("cls", None)

        _request = build_query_example_service_client_get_example_request(
            example_id=example_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExampleQueryRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_all_examples(
        self, *, instruction_id: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ExampleQueryRequest"]:
        """get all example queries.

        :keyword instruction_id: Instruction id. Default value is None.
        :paramtype instruction_id: str
        :return: An iterator like instance of ExampleQueryRequest
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExampleQueryRequest]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_query_example_service_client_list_all_examples_request(
                    instruction_id=instruction_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ExampleQueryRequest], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_replace(
        self,
        example_id: str,
        resource: _models.ExampleQueryRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self, example_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self, example_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self, example_id: str, resource: Union[_models.ExampleQueryRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ExampleQueryRequest:
        """update the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :param resource: The resource instance. Is one of the following types: ExampleQueryRequest,
         JSON, IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
         or JSON or IO[bytes]
        :return: ExampleQueryRequest. The ExampleQueryRequest is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.ExampleQueryRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExampleQueryRequest] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_query_example_service_client_create_or_replace_request(
            example_id=example_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ExampleQueryRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_example(self, example_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete the example query.

        :param example_id: The ID of the example query. Required.
        :type example_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_query_example_service_client_delete_example_request(
            example_id=example_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class AliasesServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`aliases_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, id: str, **kwargs: Any) -> _models.GetResponse:
        """Get an alias by Id.

        :param id: Id for the alias. Required.
        :type id: str
        :return: GetResponse. The GetResponse is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.GetResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetResponse] = kwargs.pop("cls", None)

        _request = build_aliases_service_client_get_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, id: str, resource: Union[_models.Alias, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_aliases_service_client_create_or_replace_request(
            id=id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self, id: str, resource: _models.Alias, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, id: str, resource: Union[_models.Alias, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.Alias]:
        """Update an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :param resource: The resource instance. Is one of the following types: Alias, JSON, IO[bytes]
         Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias or JSON or
         IO[bytes]
        :return: An instance of LROPoller that returns Alias. The Alias is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Alias] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                id=id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.Alias, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Alias].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Alias](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def delete(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an alias.

        :param id: Id for the alias. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_aliases_service_client_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Alias"]:
        """List all aliases.

        :return: An iterator like instance of Alias
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.Alias]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Alias]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_aliases_service_client_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Alias], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class HeathServiceClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`heath_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_service_health(self, **kwargs: Any) -> _models.CopilotHealth:
        """Get the health status of the service.

        :return: CopilotHealth. The CopilotHealth is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.CopilotHealth
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CopilotHealth] = kwargs.pop("cls", None)

        _request = build_heath_service_client_get_service_health_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CopilotHealth, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class InstructionsInstructionServiceClientOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.microsoft.industry.manufacturing.mds.copilot.CopilotServiceClient`'s
        :attr:`instruction_service_client` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: CopilotServiceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, id: str, **kwargs: Any) -> _models.Instruction:
        """Gets single instruction.

        :param id: Id for the instruction. Required.
        :type id: str
        :return: Instruction. The Instruction is compatible with MutableMapping
        :rtype: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)

        _request = build_instructions_instruction_service_client_get_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Instruction, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, *, state: Union[str, _models.ResourceState], **kwargs: Any) -> Iterable["_models.Instruction"]:
        """List Instruction resources.

        :keyword state: Get all active instructions by state. Known values are: "Active" and
         "Inactive". Required.
        :paramtype state: str or
         ~azure.microsoft.industry.manufacturing.mds.copilot.models.ResourceState
        :return: An iterator like instance of Instruction
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Instruction]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_instructions_instruction_service_client_list_request(
                    state=state,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
                    "location": self._serialize.url("self._config.location", self._config.location, "str"),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Instruction], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_initial(self, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instructions_instruction_service_client_create_request(
            api_version=self._config.api_version,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create(
        self, resource: _models.Instruction, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(
        self, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(
        self, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create(
        self, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """Create an instruction.

        :param resource: The resource instance. Is one of the following types: Instruction, JSON,
         IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction or JSON
         or IO[bytes]
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["operation-location"] = self._deserialize(
                "str", response.headers.get("operation-location")
            )

            deserialized = _deserialize(_models.Instruction, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Instruction].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Instruction](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _create_or_replace_initial(
        self, id: str, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instructions_instruction_service_client_create_or_replace_request(
            id=id,
            api_version=self._config.api_version,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self, id: str, resource: _models.Instruction, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, id: str, resource: Union[_models.Instruction, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.Instruction]:
        """create Or Replace instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :param resource: The resource instance. Is one of the following types: Instruction, JSON,
         IO[bytes] Required.
        :type resource: ~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction or JSON
         or IO[bytes]
        :return: An instance of LROPoller that returns Instruction. The Instruction is compatible with
         MutableMapping
        :rtype:
         ~azure.core.polling.LROPoller[~azure.microsoft.industry.manufacturing.mds.copilot.models.Instruction]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Instruction] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                id=id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Operation-Location"] = self._deserialize(
                "str", response.headers.get("Operation-Location")
            )

            deserialized = _deserialize(_models.Instruction, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Instruction].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Instruction](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(self, id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_instructions_instruction_service_client_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Operation-Location"] = self._deserialize("str", response.headers.get("Operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(self, id: str, **kwargs: Any) -> LROPoller[None]:
        """Delete instructions.

        :param id: Id for the instruction. Required.
        :type id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(id=id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs)
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "mdsUniqueId": self._serialize.url("self._config.mds_unique_id", self._config.mds_unique_id, "str"),
            "location": self._serialize.url("self._config.location", self._config.location, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
