# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, TypeVar, Union, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_apply_update_for_resource_group_operation_group_list_request,
    build_apply_update_operation_group_create_or_update_or_cancel_request,
    build_apply_update_operation_group_get_request,
    build_apply_update_operation_group_list_request,
    build_apply_updates_get_parent_request,
    build_apply_updates_operation_group_create_or_update_parent_request,
    build_apply_updates_operation_group_create_or_update_request,
    build_configuration_assignment_for_resource_group_operation_group_list_request,
    build_configuration_assignment_operation_group_create_or_update_request,
    build_configuration_assignment_operation_group_delete_request,
    build_configuration_assignment_operation_group_get_request,
    build_configuration_assignments_create_or_update_parent_request,
    build_configuration_assignments_delete_parent_request,
    build_configuration_assignments_for_resource_group_create_or_update_request,
    build_configuration_assignments_for_resource_group_delete_request,
    build_configuration_assignments_for_resource_group_get_request,
    build_configuration_assignments_for_resource_group_update_request,
    build_configuration_assignments_for_subscriptions_create_or_update_request,
    build_configuration_assignments_for_subscriptions_delete_request,
    build_configuration_assignments_for_subscriptions_get_request,
    build_configuration_assignments_for_subscriptions_list_request,
    build_configuration_assignments_for_subscriptions_update_request,
    build_configuration_assignments_get_parent_request,
    build_configuration_assignments_list_parent_request,
    build_maintenance_configuration_operation_group_create_or_update_request,
    build_maintenance_configuration_operation_group_delete_request,
    build_maintenance_configuration_operation_group_get_request,
    build_maintenance_configuration_operation_group_list_request,
    build_maintenance_configuration_operation_group_maintenance_configurations_list_request,
    build_maintenance_configuration_operation_group_update_request,
    build_maintenance_configurations_get_request,
    build_maintenance_configurations_list_request,
    build_operations_list_request,
    build_scheduled_event_operation_group_acknowledge_request,
    build_updates_operation_group_list_parent_request,
    build_updates_operation_group_list_request,
)
from .._configuration import MaintenanceClientConfiguration

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
        """List available operations.

        List the operations for the provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class MaintenanceConfigurationOpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`maintenance_configuration_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class MaintenanceConfigurationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`maintenance_configurations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_name: str, **kwargs: Any) -> _models.MaintenanceConfiguration:
        """Get Public Maintenance Configuration record.

        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MaintenanceConfiguration] = kwargs.pop("cls", None)

        _request = build_maintenance_configurations_get_request(
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MaintenanceConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.MaintenanceConfiguration"]:
        """Get Public Maintenance Configuration records.

        :return: An iterator like instance of MaintenanceConfiguration
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.MaintenanceConfiguration]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MaintenanceConfiguration]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_maintenance_configurations_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.MaintenanceConfiguration], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class MaintenanceConfigurationOperationGroupOpsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`maintenance_configuration_operation_group_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class MaintenanceConfigurationOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`maintenance_configuration_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, resource_name: str, **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Get Configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MaintenanceConfiguration] = kwargs.pop("cls", None)

        _request = build_maintenance_configuration_operation_group_get_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MaintenanceConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: _models.MaintenanceConfiguration,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Create or Update configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Create or Update configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Create or Update configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: Union[_models.MaintenanceConfiguration, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Create or Update configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Is one of the following types:
         MaintenanceConfiguration, JSON, IO[bytes] Required.
        :type configuration: ~azure.mgmt.maintenance.models.MaintenanceConfiguration or JSON or
         IO[bytes]
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MaintenanceConfiguration] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration, (IOBase, bytes)):
            _content = configuration
        else:
            _content = json.dumps(configuration, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_maintenance_configuration_operation_group_create_or_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MaintenanceConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: _models.MaintenanceConfiguration,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Patch configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Patch configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Patch configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Required.
        :type configuration: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        resource_name: str,
        configuration: Union[_models.MaintenanceConfiguration, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.MaintenanceConfiguration:
        """Patch configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :param configuration: The configuration. Is one of the following types:
         MaintenanceConfiguration, JSON, IO[bytes] Required.
        :type configuration: ~azure.mgmt.maintenance.models.MaintenanceConfiguration or JSON or
         IO[bytes]
        :return: MaintenanceConfiguration. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MaintenanceConfiguration] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration, (IOBase, bytes)):
            _content = configuration
        else:
            _content = json.dumps(configuration, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_maintenance_configuration_operation_group_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MaintenanceConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self, resource_group_name: str, resource_name: str, **kwargs: Any
    ) -> Optional[_models.MaintenanceConfiguration]:
        """Delete Configuration record.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: The name of the MaintenanceConfiguration. Required.
        :type resource_name: str
        :return: MaintenanceConfiguration or None. The MaintenanceConfiguration is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.MaintenanceConfiguration or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.MaintenanceConfiguration]] = kwargs.pop("cls", None)

        _request = build_maintenance_configuration_operation_group_delete_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.MaintenanceConfiguration, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.MaintenanceConfiguration"]:
        """Get Configuration records within a subscription and resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of MaintenanceConfiguration
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.MaintenanceConfiguration]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MaintenanceConfiguration]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_maintenance_configuration_operation_group_list_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.MaintenanceConfiguration], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def maintenance_configurations_list(self, **kwargs: Any) -> AsyncIterable["_models.MaintenanceConfiguration"]:
        """Get Configuration records within a subscription.

        :return: An iterator like instance of MaintenanceConfiguration
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.MaintenanceConfiguration]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MaintenanceConfiguration]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_maintenance_configuration_operation_group_maintenance_configurations_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.MaintenanceConfiguration], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ApplyUpdateOpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_update_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ApplyUpdatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_updates` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Track maintenance updates to resource with parent.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApplyUpdate] = kwargs.pop("cls", None)

        _request = build_apply_updates_get_parent_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_parent_type=resource_parent_type,
            resource_parent_name=resource_parent_name,
            resource_type=resource_type,
            resource_name=resource_name,
            apply_update_name=apply_update_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApplyUpdate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ApplyUpdateOperationGroupOpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_update_operation_group_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ApplyUpdateOperationGroupOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_update_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Track maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApplyUpdate] = kwargs.pop("cls", None)

        _request = build_apply_update_operation_group_get_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            apply_update_name=apply_update_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApplyUpdate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_or_cancel(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        apply_update: _models.ApplyUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :param apply_update: The ApplyUpdate. Required.
        :type apply_update: ~azure.mgmt.maintenance.models.ApplyUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_or_cancel(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        apply_update: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :param apply_update: The ApplyUpdate. Required.
        :type apply_update: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_or_cancel(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        apply_update: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :param apply_update: The ApplyUpdate. Required.
        :type apply_update: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_or_cancel(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        apply_update_name: str,
        apply_update: Union[_models.ApplyUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param apply_update_name: The name of the ApplyUpdate. Required.
        :type apply_update_name: str
        :param apply_update: The ApplyUpdate. Is one of the following types: ApplyUpdate, JSON,
         IO[bytes] Required.
        :type apply_update: ~azure.mgmt.maintenance.models.ApplyUpdate or JSON or IO[bytes]
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ApplyUpdate] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(apply_update, (IOBase, bytes)):
            _content = apply_update
        else:
            _content = json.dumps(apply_update, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_apply_update_operation_group_create_or_update_or_cancel_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            apply_update_name=apply_update_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApplyUpdate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.ApplyUpdate"]:
        """Get Configuration records within a subscription.

        :return: An iterator like instance of ApplyUpdate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.ApplyUpdate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApplyUpdate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_apply_update_operation_group_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApplyUpdate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ConfigurationAssignmentOpsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignment_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ConfigurationAssignmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Get configuration assignment for resource..

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_get_parent_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_parent_type=resource_parent_type,
            resource_parent_name=resource_parent_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignments_create_or_update_parent_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_parent_type=resource_parent_type,
            resource_parent_name=resource_parent_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        **kwargs: Any
    ) -> Optional[_models.ConfigurationAssignment]:
        """Unregister configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment or None. The ConfigurationAssignment is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_delete_parent_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_parent_type=resource_parent_type,
            resource_parent_name=resource_parent_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        **kwargs: Any
    ) -> AsyncIterable["_models.ConfigurationAssignment"]:
        """List configurationAssignments for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent name. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource name. Required.
        :type resource_name: str
        :return: An iterator like instance of ConfigurationAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.ConfigurationAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_configuration_assignments_list_parent_request(
                    resource_group_name=resource_group_name,
                    provider_name=provider_name,
                    resource_parent_type=resource_parent_type,
                    resource_parent_name=resource_parent_name,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ConfigurationAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ConfigurationAssignmentOperationGroupOpsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignment_operation_group_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ConfigurationAssignmentOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignment_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Get configuration assignment for resource..

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        _request = build_configuration_assignment_operation_group_get_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignment_operation_group_create_or_update_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_type: str,
        resource_name: str,
        configuration_assignment_name: str,
        **kwargs: Any
    ) -> Optional[_models.ConfigurationAssignment]:
        """Unregister configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource parent type. Required.
        :type resource_type: str
        :param resource_name: Resource parent name. Required.
        :type resource_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment or None. The ConfigurationAssignment is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        _request = build_configuration_assignment_operation_group_delete_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ConfigurationAssignmentsForSubscriptionOpsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignments_for_subscription_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ConfigurationAssignmentsForSubscriptionsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignments_for_subscriptions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, configuration_assignment_name: str, **kwargs: Any) -> _models.ConfigurationAssignment:
        """Get configuration assignment for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_for_subscriptions_get_request(
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignments_for_subscriptions_create_or_update_request(
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignments_for_subscriptions_update_request(
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self, configuration_assignment_name: str, **kwargs: Any
    ) -> Optional[_models.ConfigurationAssignment]:
        """Unregister configuration for resource.

        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment or None. The ConfigurationAssignment is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_for_subscriptions_delete_request(
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.ConfigurationAssignment"]:
        """[UNSUPPORTED] Get configuration assignment within a subscription. This API is not implemented
        yet.

        :return: An iterator like instance of ConfigurationAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.ConfigurationAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_configuration_assignments_for_subscriptions_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ConfigurationAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ConfigurationAssignmentsForResourceGroupOpsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignments_for_resource_group_ops` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")


class ConfigurationAssignmentsForResourceGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignments_for_resource_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, configuration_assignment_name: str, **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Get configuration assignment for resource..

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_for_resource_group_get_request(
            resource_group_name=resource_group_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignments_for_resource_group_create_or_update_request(
            resource_group_name=resource_group_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: _models.ConfigurationAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Required.
        :type configuration_assignment: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        configuration_assignment_name: str,
        configuration_assignment: Union[_models.ConfigurationAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.ConfigurationAssignment:
        """Register configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :param configuration_assignment: The configurationAssignment. Is one of the following types:
         ConfigurationAssignment, JSON, IO[bytes] Required.
        :type configuration_assignment: ~azure.mgmt.maintenance.models.ConfigurationAssignment or JSON
         or IO[bytes]
        :return: ConfigurationAssignment. The ConfigurationAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConfigurationAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(configuration_assignment, (IOBase, bytes)):
            _content = configuration_assignment
        else:
            _content = json.dumps(configuration_assignment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_configuration_assignments_for_resource_group_update_request(
            resource_group_name=resource_group_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self, resource_group_name: str, configuration_assignment_name: str, **kwargs: Any
    ) -> Optional[_models.ConfigurationAssignment]:
        """Unregister configuration for resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param configuration_assignment_name: The name of the ConfigurationAssignment. Required.
        :type configuration_assignment_name: str
        :return: ConfigurationAssignment or None. The ConfigurationAssignment is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ConfigurationAssignment or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        _request = build_configuration_assignments_for_resource_group_delete_request(
            resource_group_name=resource_group_name,
            configuration_assignment_name=configuration_assignment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ConfigurationAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ScheduledEventOperationGroupOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`scheduled_event_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def acknowledge(
        self, resource_group_name: str, resource_type: str, resource_name: str, scheduled_event_id: str, **kwargs: Any
    ) -> _models.ScheduledEventApproveResponse:
        """Post Scheduled Event Acknowledgement.

        Post Scheduled Event Acknowledgement.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource Name. Required.
        :type resource_name: str
        :param scheduled_event_id: Scheduled Event Id. This is a GUID-formatted string (e.g.
         00000000-0000-0000-0000-000000000000). Required.
        :type scheduled_event_id: str
        :return: ScheduledEventApproveResponse. The ScheduledEventApproveResponse is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ScheduledEventApproveResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ScheduledEventApproveResponse] = kwargs.pop("cls", None)

        _request = build_scheduled_event_operation_group_acknowledge_request(
            resource_group_name=resource_group_name,
            resource_type=resource_type,
            resource_name=resource_name,
            scheduled_event_id=scheduled_event_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ScheduledEventApproveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ApplyUpdatesOperationGroupOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_updates_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def create_or_update_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply Updates to resource with parent.

        Apply maintenance updates to resource with parent.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent identifier. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource identifier. Required.
        :type resource_name: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApplyUpdate] = kwargs.pop("cls", None)

        _request = build_apply_updates_operation_group_create_or_update_parent_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_parent_type=resource_parent_type,
            resource_parent_name=resource_parent_name,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApplyUpdate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_or_update(
        self, resource_group_name: str, provider_name: str, resource_type: str, resource_name: str, **kwargs: Any
    ) -> _models.ApplyUpdate:
        """Apply Updates to resource.

        Apply maintenance updates to resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource identifier. Required.
        :type resource_name: str
        :return: ApplyUpdate. The ApplyUpdate is compatible with MutableMapping
        :rtype: ~azure.mgmt.maintenance.models.ApplyUpdate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ApplyUpdate] = kwargs.pop("cls", None)

        _request = build_apply_updates_operation_group_create_or_update_request(
            resource_group_name=resource_group_name,
            provider_name=provider_name,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(_models.MaintenanceError, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ApplyUpdate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ApplyUpdateForResourceGroupOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`apply_update_for_resource_group_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.ApplyUpdate"]:
        """Get Configuration records within a subscription and resource group.

        Get Configuration records within a subscription and resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of ApplyUpdate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.ApplyUpdate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ApplyUpdate]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_apply_update_for_resource_group_operation_group_list_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ApplyUpdate], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ConfigurationAssignmentForResourceGroupOperationGroupOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`configuration_assignment_for_resource_group_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, provider_name: str, resource_type: str, resource_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.ConfigurationAssignment"]:
        """Get Configuration records within a subscription and resource group.

        Get Configuration records within a subscription and resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource identifier. Required.
        :type resource_name: str
        :return: An iterator like instance of ConfigurationAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.ConfigurationAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ConfigurationAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_configuration_assignment_for_resource_group_operation_group_list_request(
                    resource_group_name=resource_group_name,
                    provider_name=provider_name,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.ConfigurationAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class UpdatesOperationGroupOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.maintenance.aio.MaintenanceClient`'s
        :attr:`updates_operation_group` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: MaintenanceClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_parent(
        self,
        resource_group_name: str,
        provider_name: str,
        resource_parent_type: str,
        resource_parent_name: str,
        resource_type: str,
        resource_name: str,
        **kwargs: Any
    ) -> AsyncIterable["_models.Update"]:
        """Get Updates to resource.

        Get updates to resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_parent_type: Resource parent type. Required.
        :type resource_parent_type: str
        :param resource_parent_name: Resource parent identifier. Required.
        :type resource_parent_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource identifier. Required.
        :type resource_name: str
        :return: An iterator like instance of Update
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.Update]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Update]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_updates_operation_group_list_parent_request(
                    resource_group_name=resource_group_name,
                    provider_name=provider_name,
                    resource_parent_type=resource_parent_type,
                    resource_parent_name=resource_parent_name,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Update], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(
        self, resource_group_name: str, provider_name: str, resource_type: str, resource_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.Update"]:
        """Get Updates to resource.

        Get updates to resources.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param provider_name: Resource provider name. Required.
        :type provider_name: str
        :param resource_type: Resource type. Required.
        :type resource_type: str
        :param resource_name: Resource identifier. Required.
        :type resource_name: str
        :return: An iterator like instance of Update
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.maintenance.models.Update]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Update]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_updates_operation_group_list_request(
                    resource_group_name=resource_group_name,
                    provider_name=provider_name,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Update], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(_models.MaintenanceError, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)
