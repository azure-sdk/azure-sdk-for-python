# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import pytest
from azure.mgmt.azurearcdata.aio import AzureArcDataManagementClient

from devtools_testutils import AzureMgmtRecordedTestCase, RandomNameResourceGroupPreparer
from devtools_testutils.aio import recorded_by_proxy_async

AZURE_LOCATION = "eastus"


@pytest.mark.skip("you may need to update the auto-generated test case before run it")
class TestAzureArcDataManagementSqlServerAvailabilityGroupsOperationsAsync(AzureMgmtRecordedTestCase):
    def setup_method(self, method):
        self.client = self.create_mgmt_client(AzureArcDataManagementClient, is_async=True)

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_create(self, resource_group):
        response = await self.client.sql_server_availability_groups.create(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            sql_server_availability_group_resource={
                "location": "str",
                "properties": {
                    "availabilityGroupId": "str",
                    "collectionTimestamp": "2020-02-20 00:00:00",
                    "databases": {
                        "nextLink": "str",
                        "value": [
                            {
                                "databaseName": "str",
                                "databaseStateDescription": "str",
                                "isCommitParticipant": bool,
                                "isLocal": bool,
                                "isPrimaryReplica": bool,
                                "isSuspended": bool,
                                "replicaName": "str",
                                "suspendReasonDescription": "str",
                                "synchronizationHealthDescription": "str",
                                "synchronizationStateDescription": "str",
                            }
                        ],
                    },
                    "info": {
                        "automatedBackupPreferenceDescription": "str",
                        "basicFeatures": bool,
                        "clusterTypeDescription": "str",
                        "dbFailover": bool,
                        "dtcSupport": bool,
                        "failureConditionLevel": 0,
                        "healthCheckTimeout": 0,
                        "isContained": bool,
                        "isDistributed": bool,
                        "listener": {
                            "dnsName": "str",
                            "ipV4AddressesAndMasks": [{"ipAddress": "str", "mask": "str"}],
                            "ipV6Addresses": ["str"],
                            "port": 0,
                        },
                        "primaryRecoveryHealthDescription": "str",
                        "primaryReplica": "str",
                        "replicationPartnerType": "str",
                        "requiredSynchronizedSecondariesToCommit": 0,
                        "secondaryRecoveryHealthDescription": "str",
                        "synchronizationHealthDescription": "str",
                        "version": 0,
                    },
                    "instanceName": "str",
                    "provisioningState": "str",
                    "replicas": {
                        "nextLink": "str",
                        "value": [
                            {
                                "configure": {
                                    "availabilityMode": "str",
                                    "availabilityModeDescription": "str",
                                    "backupPriority": 0,
                                    "certificateName": "str",
                                    "endpointAuthenticationMode": "str",
                                    "endpointConnectLogin": "str",
                                    "endpointName": "str",
                                    "endpointUrl": "str",
                                    "failoverMode": "str",
                                    "failoverModeDescription": "str",
                                    "primaryAllowConnections": "str",
                                    "primaryRoleAllowConnectionsDescription": "str",
                                    "readOnlyRoutingUrl": "str",
                                    "readWriteRoutingUrl": "str",
                                    "replicaCreateDate": "2020-02-20 00:00:00",
                                    "replicaModifyDate": "2020-02-20 00:00:00",
                                    "secondaryAllowConnections": "str",
                                    "secondaryRoleAllowConnectionsDescription": "str",
                                    "seedingMode": "str",
                                    "seedingModeDescription": "str",
                                    "sessionTimeout": 0,
                                },
                                "replicaId": "str",
                                "replicaName": "str",
                                "replicaResourceId": "str",
                                "state": {
                                    "availabilityGroupReplicaRole": "str",
                                    "connectedStateDescription": "str",
                                    "lastConnectErrorDescription": "str",
                                    "lastConnectErrorTimestamp": "2020-02-20 00:00:00",
                                    "operationalStateDescription": "str",
                                    "recoveryHealthDescription": "str",
                                    "synchronizationHealthDescription": "str",
                                },
                            }
                        ],
                    },
                    "serverName": "str",
                    "vmId": "str",
                },
                "id": "str",
                "name": "str",
                "systemData": {
                    "createdAt": "2020-02-20 00:00:00",
                    "createdBy": "str",
                    "createdByType": "str",
                    "lastModifiedAt": "2020-02-20 00:00:00",
                    "lastModifiedBy": "str",
                    "lastModifiedByType": "str",
                },
                "tags": {"str": "str"},
                "type": "str",
            },
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_delete(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_delete(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                availability_group_name="str",
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_get(self, resource_group):
        response = await self.client.sql_server_availability_groups.get(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_update(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_update(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                availability_group_name="str",
                sql_server_availability_group_update={
                    "properties": {
                        "availabilityGroupId": "str",
                        "collectionTimestamp": "2020-02-20 00:00:00",
                        "databases": {
                            "nextLink": "str",
                            "value": [
                                {
                                    "databaseName": "str",
                                    "databaseStateDescription": "str",
                                    "isCommitParticipant": bool,
                                    "isLocal": bool,
                                    "isPrimaryReplica": bool,
                                    "isSuspended": bool,
                                    "replicaName": "str",
                                    "suspendReasonDescription": "str",
                                    "synchronizationHealthDescription": "str",
                                    "synchronizationStateDescription": "str",
                                }
                            ],
                        },
                        "info": {
                            "automatedBackupPreferenceDescription": "str",
                            "basicFeatures": bool,
                            "clusterTypeDescription": "str",
                            "dbFailover": bool,
                            "dtcSupport": bool,
                            "failureConditionLevel": 0,
                            "healthCheckTimeout": 0,
                            "isContained": bool,
                            "isDistributed": bool,
                            "listener": {
                                "dnsName": "str",
                                "ipV4AddressesAndMasks": [{"ipAddress": "str", "mask": "str"}],
                                "ipV6Addresses": ["str"],
                                "port": 0,
                            },
                            "primaryRecoveryHealthDescription": "str",
                            "primaryReplica": "str",
                            "replicationPartnerType": "str",
                            "requiredSynchronizedSecondariesToCommit": 0,
                            "secondaryRecoveryHealthDescription": "str",
                            "synchronizationHealthDescription": "str",
                            "version": 0,
                        },
                        "instanceName": "str",
                        "provisioningState": "str",
                        "replicas": {
                            "nextLink": "str",
                            "value": [
                                {
                                    "configure": {
                                        "availabilityMode": "str",
                                        "availabilityModeDescription": "str",
                                        "backupPriority": 0,
                                        "certificateName": "str",
                                        "endpointAuthenticationMode": "str",
                                        "endpointConnectLogin": "str",
                                        "endpointName": "str",
                                        "endpointUrl": "str",
                                        "failoverMode": "str",
                                        "failoverModeDescription": "str",
                                        "primaryAllowConnections": "str",
                                        "primaryRoleAllowConnectionsDescription": "str",
                                        "readOnlyRoutingUrl": "str",
                                        "readWriteRoutingUrl": "str",
                                        "replicaCreateDate": "2020-02-20 00:00:00",
                                        "replicaModifyDate": "2020-02-20 00:00:00",
                                        "secondaryAllowConnections": "str",
                                        "secondaryRoleAllowConnectionsDescription": "str",
                                        "seedingMode": "str",
                                        "seedingModeDescription": "str",
                                        "sessionTimeout": 0,
                                    },
                                    "replicaId": "str",
                                    "replicaName": "str",
                                    "replicaResourceId": "str",
                                    "state": {
                                        "availabilityGroupReplicaRole": "str",
                                        "connectedStateDescription": "str",
                                        "lastConnectErrorDescription": "str",
                                        "lastConnectErrorTimestamp": "2020-02-20 00:00:00",
                                        "operationalStateDescription": "str",
                                        "recoveryHealthDescription": "str",
                                        "synchronizationHealthDescription": "str",
                                    },
                                }
                            ],
                        },
                        "serverName": "str",
                        "vmId": "str",
                    },
                    "tags": {"str": "str"},
                },
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_detail_view(self, resource_group):
        response = await self.client.sql_server_availability_groups.detail_view(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_failover(self, resource_group):
        response = await self.client.sql_server_availability_groups.failover(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_force_failover_allow_data_loss(self, resource_group):
        response = await self.client.sql_server_availability_groups.force_failover_allow_data_loss(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_create_availability_group(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_create_availability_group(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                create_ag_configuration={
                    "automatedBackupPreference": "str",
                    "availabilityGroupName": "str",
                    "clusterType": "str",
                    "databases": ["str"],
                    "dbFailover": "str",
                    "dtcSupport": "str",
                    "failureConditionLevel": 0,
                    "healthCheckTimeout": 0,
                    "listener": {
                        "dnsName": "str",
                        "ipV4AddressesAndMasks": [{"ipAddress": "str", "mask": "str"}],
                        "ipV6Addresses": ["str"],
                        "port": 0,
                    },
                    "replicas": [
                        {
                            "availabilityMode": "str",
                            "backupPriority": 0,
                            "certificateName": "str",
                            "endpointAuthenticationMode": "str",
                            "endpointConnectLogin": "str",
                            "endpointName": "str",
                            "endpointUrl": "str",
                            "failoverMode": "str",
                            "primaryRoleAllowConnections": "str",
                            "primaryRoleReadOnlyRoutingList": ["str"],
                            "secondaryRoleAllowConnections": "str",
                            "secondaryRoleReadOnlyRoutingUrl": "str",
                            "seedingMode": "str",
                            "serverInstance": "str",
                            "sessionTimeout": 0,
                        }
                    ],
                    "requiredSynchronizedSecondariesToCommit": 0,
                },
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_create_distributed_availability_group(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_create_distributed_availability_group(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                create_dag_configuration={
                    "availabilityGroupName": "str",
                    "primaryAvailabilityGroup": {
                        "availabilityGroup": "str",
                        "availabilityMode": "str",
                        "certificateConfiguration": {"certificateName": "str"},
                        "failoverMode": "str",
                        "listenerUrl": "str",
                        "seedingMode": "str",
                    },
                    "secondaryAvailabilityGroup": {
                        "availabilityGroup": "str",
                        "availabilityMode": "str",
                        "certificateConfiguration": {"certificateName": "str"},
                        "failoverMode": "str",
                        "listenerUrl": "str",
                        "seedingMode": "str",
                    },
                },
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_create_managed_instance_link(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_create_managed_instance_link(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                create_managed_instance_link_configuration={
                    "availabilityGroup": {
                        "automatedBackupPreference": "str",
                        "availabilityGroupName": "str",
                        "clusterType": "str",
                        "databases": ["str"],
                        "dbFailover": "str",
                        "dtcSupport": "str",
                        "failureConditionLevel": 0,
                        "healthCheckTimeout": 0,
                        "listener": {
                            "dnsName": "str",
                            "ipV4AddressesAndMasks": [{"ipAddress": "str", "mask": "str"}],
                            "ipV6Addresses": ["str"],
                            "port": 0,
                        },
                        "replicas": [
                            {
                                "availabilityMode": "str",
                                "backupPriority": 0,
                                "certificateName": "str",
                                "endpointAuthenticationMode": "str",
                                "endpointConnectLogin": "str",
                                "endpointName": "str",
                                "endpointUrl": "str",
                                "failoverMode": "str",
                                "primaryRoleAllowConnections": "str",
                                "primaryRoleReadOnlyRoutingList": ["str"],
                                "secondaryRoleAllowConnections": "str",
                                "secondaryRoleReadOnlyRoutingUrl": "str",
                                "seedingMode": "str",
                                "serverInstance": "str",
                                "sessionTimeout": 0,
                            }
                        ],
                        "requiredSynchronizedSecondariesToCommit": 0,
                    },
                    "distributedAvailabilityGroup": {
                        "availabilityGroupName": "str",
                        "primaryAvailabilityGroup": {
                            "availabilityGroup": "str",
                            "availabilityMode": "str",
                            "certificateConfiguration": {"certificateName": "str"},
                            "failoverMode": "str",
                            "listenerUrl": "str",
                            "seedingMode": "str",
                        },
                        "secondaryAvailabilityGroup": {
                            "availabilityGroup": "str",
                            "availabilityMode": "str",
                            "certificateConfiguration": {"certificateName": "str"},
                            "failoverMode": "str",
                            "listenerUrl": "str",
                            "seedingMode": "str",
                        },
                    },
                    "miLinkConfiguration": {"instanceAvailabilityGroupName": "str"},
                },
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_add_databases(self, resource_group):
        response = await self.client.sql_server_availability_groups.add_databases(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            databases={"values": ["str"]},
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_begin_failover_mi_link(self, resource_group):
        response = await (
            await self.client.sql_server_availability_groups.begin_failover_mi_link(
                resource_group_name=resource_group.name,
                sql_server_instance_name="str",
                availability_group_name="str",
                managed_instance_resource_id={"managedInstanceId": "str"},
                api_version="2025-03-01-preview",
            )
        ).result()  # call '.result()' to poll until service return final result

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_remove_databases(self, resource_group):
        response = await self.client.sql_server_availability_groups.remove_databases(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            availability_group_name="str",
            databases={"values": ["str"]},
            api_version="2025-03-01-preview",
        )

        # please add some check logic here by yourself
        # ...

    @RandomNameResourceGroupPreparer(location=AZURE_LOCATION)
    @recorded_by_proxy_async
    async def test_sql_server_availability_groups_list(self, resource_group):
        response = self.client.sql_server_availability_groups.list(
            resource_group_name=resource_group.name,
            sql_server_instance_name="str",
            api_version="2025-03-01-preview",
        )
        result = [r async for r in response]
        # please add some check logic here by yourself
        # ...
