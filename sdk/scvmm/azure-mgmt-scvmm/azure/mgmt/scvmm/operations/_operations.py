# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, Optional, Type, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.ScVmm/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_get_request(
    resource_group_name: str, vmm_server_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, vmm_server_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_update_request(
    resource_group_name: str, vmm_server_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_delete_request(
    resource_group_name: str,
    vmm_server_name: str,
    subscription_id: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vmm_servers_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/vmmServers"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_get_request(
    resource_group_name: str, cloud_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "cloudResourceName": _SERIALIZER.url("cloud_resource_name", cloud_resource_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_create_or_update_request(
    resource_group_name: str, cloud_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "cloudResourceName": _SERIALIZER.url("cloud_resource_name", cloud_resource_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_update_request(
    resource_group_name: str, cloud_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "cloudResourceName": _SERIALIZER.url("cloud_resource_name", cloud_resource_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_delete_request(
    resource_group_name: str,
    cloud_resource_name: str,
    subscription_id: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "cloudResourceName": _SERIALIZER.url("cloud_resource_name", cloud_resource_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clouds_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/clouds"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_get_request(
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_update_request(
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_delete_request(
    resource_group_name: str,
    virtual_network_name: str,
    subscription_id: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/virtualNetworks"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_get_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    virtual_machine_template_name: str,
    subscription_id: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/virtualMachineTemplates"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_get_request(
    resource_group_name: str, availability_set_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "availabilitySetResourceName": _SERIALIZER.url(
            "availability_set_resource_name", availability_set_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, availability_set_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "availabilitySetResourceName": _SERIALIZER.url(
            "availability_set_resource_name", availability_set_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_update_request(
    resource_group_name: str, availability_set_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "availabilitySetResourceName": _SERIALIZER.url(
            "availability_set_resource_name", availability_set_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_delete_request(
    resource_group_name: str,
    availability_set_resource_name: str,
    subscription_id: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "availabilitySetResourceName": _SERIALIZER.url(
            "availability_set_resource_name", availability_set_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_availability_sets_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/availabilitySets"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_get_request(
    resource_group_name: str,
    vmm_server_name: str,
    inventory_item_resource_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
        "inventoryItemResourceName": _SERIALIZER.url(
            "inventory_item_resource_name", inventory_item_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_create_request(
    resource_group_name: str,
    vmm_server_name: str,
    inventory_item_resource_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
        "inventoryItemResourceName": _SERIALIZER.url(
            "inventory_item_resource_name", inventory_item_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_delete_request(
    resource_group_name: str,
    vmm_server_name: str,
    inventory_item_resource_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
        "inventoryItemResourceName": _SERIALIZER.url(
            "inventory_item_resource_name", inventory_item_resource_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_list_by_vmm_server_request(  # pylint: disable=name-too-long
    resource_group_name: str, vmm_server_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vmmServerName": _SERIALIZER.url("vmm_server_name", vmm_server_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_get_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_create_or_update_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_update_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_delete_request(  # pylint: disable=name-too-long
    resource_uri: str,
    *,
    force: Optional[Union[str, _models.ForceDelete]] = None,
    delete_from_host: Optional[Union[str, _models.DeleteFromHost]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "str")
    if delete_from_host is not None:
        _params["deleteFromHost"] = _SERIALIZER.query("delete_from_host", delete_from_host, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_list_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_stop_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/stop"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_start_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/start"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_restart_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/restart"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_create_checkpoint_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/createCheckpoint"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_delete_checkpoint_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/deleteCheckpoint"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_restore_checkpoint_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/restoreCheckpoint"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_hybrid_identity_metadatas_get_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/hybridIdentityMetadata/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_hybrid_identity_metadatas_list_by_virtual_machine_instance_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/hybridIdentityMetadata"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_guest_agents_get_request(resource_uri: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/guestAgents/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_guest_agents_create_request(resource_uri: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/guestAgents/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_guest_agents_delete_request(resource_uri: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/guestAgents/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_guest_agents_list_by_virtual_machine_instance_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-07"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ScVmm/virtualMachineInstances/default/guestAgents"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
        """List the operations for the provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",
                    "display": {
                        "description": "str",
                        "operation": "str",
                        "provider": "str",
                        "resource": "str"
                    },
                    "isDataAction": bool,
                    "name": "str",
                    "origin": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VmmServersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`vmm_servers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, vmm_server_name: str, **kwargs: Any) -> _models.VmmServer:
        """Gets a VMMServer.

        Implements VmmServer GET method.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :return: VmmServer. The VmmServer is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.VmmServer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VmmServer] = kwargs.pop("cls", None)

        _request = build_vmm_servers_get_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VmmServer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        resource: Union[_models.VmmServer, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_vmm_servers_create_or_update_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        resource: _models.VmmServer,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PUT method.

        Onboards the SCVmm fabric as an Azure VmmServer resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.VmmServer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PUT method.

        Onboards the SCVmm fabric as an Azure VmmServer resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PUT method.

        Onboards the SCVmm fabric as an Azure VmmServer resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        resource: Union[_models.VmmServer, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PUT method.

        Onboards the SCVmm fabric as an Azure VmmServer resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param resource: Resource create parameters. Is one of the following types: VmmServer, JSON,
         IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.VmmServer or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VmmServer] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                vmm_server_name=vmm_server_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VmmServer, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VmmServer].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VmmServer](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        properties: Union[_models.VmmServerTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_vmm_servers_update_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        properties: _models.VmmServerTagsUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PATCH method.

        Updates the VmmServers resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.VmmServerTagsUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PATCH method.

        Updates the VmmServers resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PATCH method.

        Updates the VmmServers resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        properties: Union[_models.VmmServerTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VmmServer]:
        """Implements VmmServers PATCH method.

        Updates the VmmServers resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         VmmServerTagsUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.VmmServerTagsUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VmmServer. The VmmServer is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VmmServer] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                vmm_server_name=vmm_server_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VmmServer, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VmmServer].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VmmServer](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_vmm_servers_delete_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements VmmServers DELETE method.

        Removes the SCVmm fabric from Azure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                vmm_server_name=vmm_server_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.VmmServer"]:
        """Implements GET VmmServers in a resource group.

        List of VmmServers in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of VmmServer
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VmmServer]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vmm_servers_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VmmServer], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.VmmServer"]:
        """Implements GET VmmServers in a subscription.

        List of VmmServers in a subscription.

        :return: An iterator like instance of VmmServer
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VmmServer]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "fqdn": "str",
                        "connectionStatus": "str",
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "errorMessage": "str",
                        "port": 0,
                        "provisioningState": "str",
                        "uuid": "str",
                        "version": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VmmServer]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vmm_servers_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VmmServer], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class CloudsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`clouds` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, cloud_resource_name: str, **kwargs: Any) -> _models.Cloud:
        """Gets a Cloud.

        Implements Cloud GET method.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :return: Cloud. The Cloud is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.Cloud
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Cloud] = kwargs.pop("cls", None)

        _request = build_clouds_get_request(
            resource_group_name=resource_group_name,
            cloud_resource_name=cloud_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Cloud, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        resource: Union[_models.Cloud, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_clouds_create_or_update_request(
            resource_group_name=resource_group_name,
            cloud_resource_name=cloud_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        resource: _models.Cloud,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements Clouds PUT method.

        Onboards the ScVmm fabric cloud as an Azure cloud resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.Cloud
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements Clouds PUT method.

        Onboards the ScVmm fabric cloud as an Azure cloud resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements Clouds PUT method.

        Onboards the ScVmm fabric cloud as an Azure cloud resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        resource: Union[_models.Cloud, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements Clouds PUT method.

        Onboards the ScVmm fabric cloud as an Azure cloud resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param resource: Resource create parameters. Is one of the following types: Cloud, JSON,
         IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.Cloud or JSON or IO[bytes]
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Cloud] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                cloud_resource_name=cloud_resource_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Cloud, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Cloud].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Cloud](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        properties: Union[_models.CloudTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_clouds_update_request(
            resource_group_name=resource_group_name,
            cloud_resource_name=cloud_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        properties: _models.CloudTagsUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements the Clouds PATCH method.

        Updates the Clouds resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.CloudTagsUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements the Clouds PATCH method.

        Updates the Clouds resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements the Clouds PATCH method.

        Updates the Clouds resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        properties: Union[_models.CloudTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.Cloud]:
        """Implements the Clouds PATCH method.

        Updates the Clouds resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         CloudTagsUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.CloudTagsUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns Cloud. The Cloud is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Cloud] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                cloud_resource_name=cloud_resource_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Cloud, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Cloud].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Cloud](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_clouds_delete_request(
            resource_group_name=resource_group_name,
            cloud_resource_name=cloud_resource_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        cloud_resource_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements Cloud resource DELETE method.

        Deregisters the ScVmm fabric cloud from Azure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cloud_resource_name: Name of the Cloud. Required.
        :type cloud_resource_name: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                cloud_resource_name=cloud_resource_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Cloud"]:
        """Implements GET Clouds in a resource group.

        List of Clouds in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of Cloud
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Cloud]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_clouds_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Cloud], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.Cloud"]:
        """Implements GET Clouds in a subscription.

        List of Clouds in a subscription.

        :return: An iterator like instance of Cloud
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.Cloud]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "cloudCapacity": {
                            "cpuCount": 0,
                            "memoryMB": 0,
                            "vmCount": 0
                        },
                        "cloudName": "str",
                        "inventoryItemId": "str",
                        "provisioningState": "str",
                        "storageQoSPolicies": [
                            {
                                "bandwidthLimit": 0,
                                "id": "str",
                                "iopsMaximum": 0,
                                "iopsMinimum": 0,
                                "name": "str",
                                "policyId": "str"
                            }
                        ],
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Cloud]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_clouds_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Cloud], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualNetworksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`virtual_networks` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, virtual_network_name: str, **kwargs: Any) -> _models.VirtualNetwork:
        """Gets a VirtualNetwork.

        Implements VirtualNetwork GET method.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :return: VirtualNetwork. The VirtualNetwork is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.VirtualNetwork
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VirtualNetwork] = kwargs.pop("cls", None)

        _request = build_virtual_networks_get_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VirtualNetwork, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        resource: Union[_models.VirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_networks_create_or_update_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        resource: _models.VirtualNetwork,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements VirtualNetworks PUT method.

        Onboards the ScVmm virtual network as an Azure virtual network resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualNetwork
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements VirtualNetworks PUT method.

        Onboards the ScVmm virtual network as an Azure virtual network resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements VirtualNetworks PUT method.

        Onboards the ScVmm virtual network as an Azure virtual network resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        resource: Union[_models.VirtualNetwork, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements VirtualNetworks PUT method.

        Onboards the ScVmm virtual network as an Azure virtual network resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param resource: Resource create parameters. Is one of the following types: VirtualNetwork,
         JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualNetwork or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualNetwork] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                virtual_network_name=virtual_network_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualNetwork, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualNetwork].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualNetwork](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        properties: Union[_models.VirtualNetworkTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_networks_update_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        properties: _models.VirtualNetworkTagsUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements the VirtualNetworks PATCH method.

        Updates the VirtualNetworks resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualNetworkTagsUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements the VirtualNetworks PATCH method.

        Updates the VirtualNetworks resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements the VirtualNetworks PATCH method.

        Updates the VirtualNetworks resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        properties: Union[_models.VirtualNetworkTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VirtualNetwork]:
        """Implements the VirtualNetworks PATCH method.

        Updates the VirtualNetworks resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         VirtualNetworkTagsUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualNetworkTagsUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VirtualNetwork. The VirtualNetwork is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualNetwork] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                virtual_network_name=virtual_network_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualNetwork, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualNetwork].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualNetwork](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_virtual_networks_delete_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements VirtualNetwork DELETE method.

        Deregisters the ScVmm virtual network from Azure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the VirtualNetwork. Required.
        :type virtual_network_name: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                virtual_network_name=virtual_network_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.VirtualNetwork"]:
        """Implements GET VirtualNetworks in a resource group.

        List of VirtualNetworks in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of VirtualNetwork
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualNetwork]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_networks_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualNetwork], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.VirtualNetwork"]:
        """Implements GET VirtualNetworks in a subscription.

        List of VirtualNetworks in a subscription.

        :return: An iterator like instance of VirtualNetwork
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VirtualNetwork]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "inventoryItemId": "str",
                        "networkName": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualNetwork]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_networks_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualNetwork], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualMachineTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`virtual_machine_templates` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, resource_group_name: str, virtual_machine_template_name: str, **kwargs: Any
    ) -> _models.VirtualMachineTemplate:
        """Gets a VirtualMachineTemplate.

        Implements VirtualMachineTemplate GET method.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :return: VirtualMachineTemplate. The VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.VirtualMachineTemplate
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VirtualMachineTemplate] = kwargs.pop("cls", None)

        _request = build_virtual_machine_templates_get_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VirtualMachineTemplate, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        resource: Union[_models.VirtualMachineTemplate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_templates_create_or_update_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        resource: _models.VirtualMachineTemplate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements VirtualMachineTemplates PUT method.

        Onboards the ScVmm VM Template as an Azure VM Template resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualMachineTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements VirtualMachineTemplates PUT method.

        Onboards the ScVmm VM Template as an Azure VM Template resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements VirtualMachineTemplates PUT method.

        Onboards the ScVmm VM Template as an Azure VM Template resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        resource: Union[_models.VirtualMachineTemplate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements VirtualMachineTemplates PUT method.

        Onboards the ScVmm VM Template as an Azure VM Template resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param resource: Resource create parameters. Is one of the following types:
         VirtualMachineTemplate, JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualMachineTemplate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualMachineTemplate] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                virtual_machine_template_name=virtual_machine_template_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualMachineTemplate, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualMachineTemplate].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualMachineTemplate](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        properties: Union[_models.VirtualMachineTemplateTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_templates_update_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        properties: _models.VirtualMachineTemplateTagsUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements the VirtualMachineTemplate PATCH method.

        Updates the VirtualMachineTemplate resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualMachineTemplateTagsUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements the VirtualMachineTemplate PATCH method.

        Updates the VirtualMachineTemplate resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements the VirtualMachineTemplate PATCH method.

        Updates the VirtualMachineTemplate resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        properties: Union[_models.VirtualMachineTemplateTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineTemplate]:
        """Implements the VirtualMachineTemplate PATCH method.

        Updates the VirtualMachineTemplate resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         VirtualMachineTemplateTagsUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualMachineTemplateTagsUpdate or JSON or
         IO[bytes]
        :return: An instance of LROPoller that returns VirtualMachineTemplate. The
         VirtualMachineTemplate is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualMachineTemplate] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                virtual_machine_template_name=virtual_machine_template_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualMachineTemplate, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualMachineTemplate].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualMachineTemplate](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_virtual_machine_templates_delete_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements VirtualMachineTemplate DELETE method.

        Deregisters the ScVmm VM Template from Azure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the VirtualMachineTemplate. Required.
        :type virtual_machine_template_name: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                virtual_machine_template_name=virtual_machine_template_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, **kwargs: Any
    ) -> Iterable["_models.VirtualMachineTemplate"]:
        """Implements GET VirtualMachineTemplates in a resource group.

        List of VirtualMachineTemplates in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of VirtualMachineTemplate
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualMachineTemplate]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_templates_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualMachineTemplate], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.VirtualMachineTemplate"]:
        """Implements GET VirtualMachineTemplates in a subscription.

        List of VirtualMachineTemplates in a subscription.

        :return: An iterator like instance of VirtualMachineTemplate
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VirtualMachineTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "computerName": "str",
                        "cpuCount": 0,
                        "disks": [
                            {
                                "bus": 0,
                                "busType": "str",
                                "createDiffDisk": "str",
                                "diskId": "str",
                                "diskSizeGB": 0,
                                "displayName": "str",
                                "lun": 0,
                                "maxDiskSizeGB": 0,
                                "name": "str",
                                "storageQoSPolicy": {
                                    "id": "str",
                                    "name": "str"
                                },
                                "templateDiskId": "str",
                                "vhdFormatType": "str",
                                "vhdType": "str",
                                "volumeType": "str"
                            }
                        ],
                        "dynamicMemoryEnabled": "str",
                        "dynamicMemoryMaxMB": 0,
                        "dynamicMemoryMinMB": 0,
                        "generation": 0,
                        "inventoryItemId": "str",
                        "isCustomizable": "str",
                        "isHighlyAvailable": "str",
                        "limitCpuForMigration": "str",
                        "memoryMB": 0,
                        "networkInterfaces": [
                            {
                                "displayName": "str",
                                "ipv4AddressType": "str",
                                "ipv4Addresses": [
                                    "str"
                                ],
                                "ipv6AddressType": "str",
                                "ipv6Addresses": [
                                    "str"
                                ],
                                "macAddress": "str",
                                "macAddressType": "str",
                                "name": "str",
                                "networkName": "str",
                                "nicId": "str",
                                "virtualNetworkId": "str"
                            }
                        ],
                        "osName": "str",
                        "osType": "str",
                        "provisioningState": "str",
                        "uuid": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualMachineTemplate]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_templates_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualMachineTemplate], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AvailabilitySetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`availability_sets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, resource_group_name: str, availability_set_resource_name: str, **kwargs: Any
    ) -> _models.AvailabilitySet:
        """Gets an AvailabilitySet.

        Implements AvailabilitySet GET method.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :return: AvailabilitySet. The AvailabilitySet is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.AvailabilitySet
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AvailabilitySet] = kwargs.pop("cls", None)

        _request = build_availability_sets_get_request(
            resource_group_name=resource_group_name,
            availability_set_resource_name=availability_set_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AvailabilitySet, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        resource: Union[_models.AvailabilitySet, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_availability_sets_create_or_update_request(
            resource_group_name=resource_group_name,
            availability_set_resource_name=availability_set_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        resource: _models.AvailabilitySet,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements AvailabilitySets PUT method.

        Onboards the ScVmm availability set as an Azure resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.AvailabilitySet
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements AvailabilitySets PUT method.

        Onboards the ScVmm availability set as an Azure resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements AvailabilitySets PUT method.

        Onboards the ScVmm availability set as an Azure resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        resource: Union[_models.AvailabilitySet, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements AvailabilitySets PUT method.

        Onboards the ScVmm availability set as an Azure resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param resource: Resource create parameters. Is one of the following types: AvailabilitySet,
         JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.AvailabilitySet or JSON or IO[bytes]
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AvailabilitySet] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                availability_set_resource_name=availability_set_resource_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AvailabilitySet, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AvailabilitySet].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AvailabilitySet](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        properties: Union[_models.AvailabilitySetTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_availability_sets_update_request(
            resource_group_name=resource_group_name,
            availability_set_resource_name=availability_set_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        properties: _models.AvailabilitySetTagsUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements the AvailabilitySets PATCH method.

        Updates the AvailabilitySets resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.AvailabilitySetTagsUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements the AvailabilitySets PATCH method.

        Updates the AvailabilitySets resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements the AvailabilitySets PATCH method.

        Updates the AvailabilitySets resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        properties: Union[_models.AvailabilitySetTagsUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[_models.AvailabilitySet]:
        """Implements the AvailabilitySets PATCH method.

        Updates the AvailabilitySets resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :param properties: The resource properties to be updated. Is one of the following types:
         AvailabilitySetTagsUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.AvailabilitySetTagsUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns AvailabilitySet. The AvailabilitySet is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AvailabilitySet] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                availability_set_resource_name=availability_set_resource_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.AvailabilitySet, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AvailabilitySet].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AvailabilitySet](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_availability_sets_delete_request(
            resource_group_name=resource_group_name,
            availability_set_resource_name=availability_set_resource_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        availability_set_resource_name: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements AvailabilitySet DELETE method.

        Deregisters the ScVmm availability set from Azure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param availability_set_resource_name: Name of the AvailabilitySet. Required.
        :type availability_set_resource_name: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                availability_set_resource_name=availability_set_resource_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.AvailabilitySet"]:
        """Implements GET AvailabilitySets in a resource group.

        List of AvailabilitySets in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of AvailabilitySet
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AvailabilitySet]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_availability_sets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AvailabilitySet], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.AvailabilitySet"]:
        """Implements GET AvailabilitySets in a subscription.

        List of AvailabilitySets in a subscription.

        :return: An iterator like instance of AvailabilitySet
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.AvailabilitySet]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "location": "str",
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySetName": "str",
                        "provisioningState": "str",
                        "vmmServerId": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "tags": {
                        "str": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AvailabilitySet]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_availability_sets_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AvailabilitySet], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class InventoryItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`inventory_items` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, resource_group_name: str, vmm_server_name: str, inventory_item_resource_name: str, **kwargs: Any
    ) -> _models.InventoryItem:
        """Implements GET InventoryItem method.

        Shows an inventory item.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :return: InventoryItem. The InventoryItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.InventoryItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InventoryItem] = kwargs.pop("cls", None)

        _request = build_inventory_items_get_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            inventory_item_resource_name=inventory_item_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InventoryItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        inventory_item_resource_name: str,
        resource: _models.InventoryItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.InventoryItem:
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.InventoryItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InventoryItem. The InventoryItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.InventoryItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def create(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        inventory_item_resource_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.InventoryItem:
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InventoryItem. The InventoryItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.InventoryItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def create(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        inventory_item_resource_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.InventoryItem:
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InventoryItem. The InventoryItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.InventoryItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def create(
        self,
        resource_group_name: str,
        vmm_server_name: str,
        inventory_item_resource_name: str,
        resource: Union[_models.InventoryItem, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.InventoryItem:
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :param resource: Resource create parameters. Is one of the following types: InventoryItem,
         JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.InventoryItem or JSON or IO[bytes]
        :return: InventoryItem. The InventoryItem is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.InventoryItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InventoryItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inventory_items_create_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            inventory_item_resource_name=inventory_item_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.InventoryItem, response.json())

        if response.status_code == 201:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.InventoryItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, vmm_server_name: str, inventory_item_resource_name: str, **kwargs: Any
    ) -> None:
        """Implements inventoryItem DELETE method.

        Deletes an inventoryItem.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :param inventory_item_resource_name: Name of the inventoryItem. Required.
        :type inventory_item_resource_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_inventory_items_delete_request(
            resource_group_name=resource_group_name,
            vmm_server_name=vmm_server_name,
            inventory_item_resource_name=inventory_item_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_vmm_server(
        self, resource_group_name: str, vmm_server_name: str, **kwargs: Any
    ) -> Iterable["_models.InventoryItem"]:
        """Implements GET for the list of Inventory Items in the VMMServer.

        Returns the list of inventoryItems in the given VmmServer.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param vmm_server_name: Name of the VmmServer. Required.
        :type vmm_server_name: str
        :return: An iterator like instance of InventoryItem
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.InventoryItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cloud":
                inventory_item_properties = {
                    "inventoryType": "Cloud",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "biosGuid": "str",
                    "cloud": {
                        "inventoryItemId": "str",
                        "inventoryItemName": "str"
                    },
                    "inventoryItemName": "str",
                    "ipAddresses": [
                        "str"
                    ],
                    "managedMachineResourceId": "str",
                    "managedResourceId": "str",
                    "osName": "str",
                    "osType": "str",
                    "osVersion": "str",
                    "powerState": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualMachineTemplate":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachineTemplate",
                    "cpuCount": 0,
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "memoryMB": 0,
                    "osName": "str",
                    "osType": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # JSON input template for discriminator value "VirtualNetwork":
                inventory_item_properties = {
                    "inventoryType": "VirtualNetwork",
                    "inventoryItemName": "str",
                    "managedResourceId": "str",
                    "provisioningState": "str",
                    "uuid": "str"
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "kind": "str",
                    "name": "str",
                    "properties": inventory_item_properties,
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.InventoryItem]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_inventory_items_list_by_vmm_server_request(
                    resource_group_name=resource_group_name,
                    vmm_server_name=vmm_server_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.InventoryItem], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualMachineInstancesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`virtual_machine_instances` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> _models.VirtualMachineInstance:
        """Gets a virtual machine.

        Retrieves information about a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: VirtualMachineInstance. The VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.VirtualMachineInstance
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VirtualMachineInstance] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VirtualMachineInstance, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_update_initial(
        self, resource_uri: str, resource: Union[_models.VirtualMachineInstance, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_create_or_update_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_uri: str,
        resource: _models.VirtualMachineInstance,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualMachineInstance
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self, resource_uri: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create_or_update(
        self, resource_uri: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_uri: str, resource: Union[_models.VirtualMachineInstance, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Is one of the following types:
         VirtualMachineInstance, JSON, IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.VirtualMachineInstance or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualMachineInstance] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_uri=resource_uri,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualMachineInstance, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualMachineInstance].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualMachineInstance](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_initial(
        self, resource_uri: str, properties: Union[_models.VirtualMachineInstanceUpdate, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _content = json.dumps(properties, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_update_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        resource_uri: str,
        properties: _models.VirtualMachineInstanceUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param properties: The resource properties to be updated. Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualMachineInstanceUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "checkpointType": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "ipv4AddressType": "str",
                                    "ipv6AddressType": "str",
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "lun": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "vhdType": "str"
                                }
                            ]
                        }
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self, resource_uri: str, properties: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_update(
        self, resource_uri: str, properties: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_uri: str, properties: Union[_models.VirtualMachineInstanceUpdate, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.VirtualMachineInstance]:
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param properties: The resource properties to be updated. Is one of the following types:
         VirtualMachineInstanceUpdate, JSON, IO[bytes] Required.
        :type properties: ~azure.mgmt.scvmm.models.VirtualMachineInstanceUpdate or JSON or IO[bytes]
        :return: An instance of LROPoller that returns VirtualMachineInstance. The
         VirtualMachineInstance is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "checkpointType": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "ipv4AddressType": "str",
                                    "ipv6AddressType": "str",
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "lun": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "vhdType": "str"
                                }
                            ]
                        }
                    }
                }

                # response body for status code(s): 200, 202
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VirtualMachineInstance] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_uri=resource_uri,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.VirtualMachineInstance, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.VirtualMachineInstance].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.VirtualMachineInstance](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_initial(
        self,
        resource_uri: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        delete_from_host: Optional[Union[str, _models.DeleteFromHost]] = None,
        **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_delete_request(
            resource_uri=resource_uri,
            force=force,
            delete_from_host=delete_from_host,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if response.status_code == 204:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_uri: str,
        *,
        force: Optional[Union[str, _models.ForceDelete]] = None,
        delete_from_host: Optional[Union[str, _models.DeleteFromHost]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an virtual machine.

        The operation to delete a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :keyword force: Forces the resource to be deleted. Known values are: "true" and "false".
         Default value is None.
        :paramtype force: str or ~azure.mgmt.scvmm.models.ForceDelete
        :keyword delete_from_host: Whether to disable the VM from azure and also delete it from Vmm.
         Known values are: "true" and "false". Default value is None.
        :paramtype delete_from_host: str or ~azure.mgmt.scvmm.models.DeleteFromHost
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_uri=resource_uri,
                force=force,
                delete_from_host=delete_from_host,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, resource_uri: str, **kwargs: Any) -> Iterable["_models.VirtualMachineInstance"]:
        """Implements List virtual machine instances.

        Lists all of the virtual machine instances within the specified parent resource.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: An iterator like instance of VirtualMachineInstance
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VirtualMachineInstance]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",
                        "type": "str"
                    },
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "availabilitySets": [
                            {
                                "id": "str",
                                "name": "str"
                            }
                        ],
                        "hardwareProfile": {
                            "cpuCount": 0,
                            "dynamicMemoryEnabled": "str",
                            "dynamicMemoryMaxMB": 0,
                            "dynamicMemoryMinMB": 0,
                            "isHighlyAvailable": "str",
                            "limitCpuForMigration": "str",
                            "memoryMB": 0
                        },
                        "infrastructureProfile": {
                            "biosGuid": "str",
                            "checkpointType": "str",
                            "checkpoints": [
                                {
                                    "checkpointID": "str",
                                    "description": "str",
                                    "name": "str",
                                    "parentCheckpointID": "str"
                                }
                            ],
                            "cloudId": "str",
                            "generation": 0,
                            "inventoryItemId": "str",
                            "lastRestoredVMCheckpoint": {
                                "checkpointID": "str",
                                "description": "str",
                                "name": "str",
                                "parentCheckpointID": "str"
                            },
                            "templateId": "str",
                            "uuid": "str",
                            "vmName": "str",
                            "vmmServerId": "str"
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "displayName": "str",
                                    "ipv4AddressType": "str",
                                    "ipv4Addresses": [
                                        "str"
                                    ],
                                    "ipv6AddressType": "str",
                                    "ipv6Addresses": [
                                        "str"
                                    ],
                                    "macAddress": "str",
                                    "macAddressType": "str",
                                    "name": "str",
                                    "networkName": "str",
                                    "nicId": "str",
                                    "virtualNetworkId": "str"
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",
                            "computerName": "str",
                            "osSku": "str",
                            "osType": "str",
                            "osVersion": "str"
                        },
                        "powerState": "str",
                        "provisioningState": "str",
                        "storageProfile": {
                            "disks": [
                                {
                                    "bus": 0,
                                    "busType": "str",
                                    "createDiffDisk": "str",
                                    "diskId": "str",
                                    "diskSizeGB": 0,
                                    "displayName": "str",
                                    "lun": 0,
                                    "maxDiskSizeGB": 0,
                                    "name": "str",
                                    "storageQoSPolicy": {
                                        "id": "str",
                                        "name": "str"
                                    },
                                    "templateDiskId": "str",
                                    "vhdFormatType": "str",
                                    "vhdType": "str",
                                    "volumeType": "str"
                                }
                            ]
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VirtualMachineInstance]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_instances_list_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VirtualMachineInstance], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _stop_initial(
        self, resource_uri: str, body: Union[_models.StopVirtualMachineOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_stop_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_stop(
        self,
        resource_uri: str,
        body: _models.StopVirtualMachineOptions,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: ~azure.mgmt.scvmm.models.StopVirtualMachineOptions
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "skipShutdown": "str"
                }
        """

    @overload
    def begin_stop(
        self, resource_uri: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_stop(
        self, resource_uri: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_stop(
        self, resource_uri: str, body: Union[_models.StopVirtualMachineOptions, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Is one of the following types:
         StopVirtualMachineOptions, JSON, IO[bytes] Required.
        :type body: ~azure.mgmt.scvmm.models.StopVirtualMachineOptions or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "skipShutdown": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._stop_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _start_initial(self, resource_uri: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_start_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_start(self, resource_uri: str, **kwargs: Any) -> LROPoller[None]:
        """Implements the operation to start a virtual machine.

        The operation to start a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._start_initial(
                resource_uri=resource_uri, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _restart_initial(self, resource_uri: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_restart_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_restart(self, resource_uri: str, **kwargs: Any) -> LROPoller[None]:
        """Implements the operation to restart a virtual machine.

        The operation to restart a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._restart_initial(
                resource_uri=resource_uri, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _create_checkpoint_initial(
        self, resource_uri: str, body: Union[_models.VirtualMachineCreateCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_create_checkpoint_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_checkpoint(
        self,
        resource_uri: str,
        body: _models.VirtualMachineCreateCheckpoint,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to creates a checkpoint in a virtual machine instance.

        Creates a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineCreateCheckpoint
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "name": "str"
                }
        """

    @overload
    def begin_create_checkpoint(
        self, resource_uri: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to creates a checkpoint in a virtual machine instance.

        Creates a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_checkpoint(
        self, resource_uri: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to creates a checkpoint in a virtual machine instance.

        Creates a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_checkpoint(
        self, resource_uri: str, body: Union[_models.VirtualMachineCreateCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to creates a checkpoint in a virtual machine instance.

        Creates a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Is one of the following types:
         VirtualMachineCreateCheckpoint, JSON, IO[bytes] Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineCreateCheckpoint or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",
                    "name": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_checkpoint_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_checkpoint_initial(
        self, resource_uri: str, body: Union[_models.VirtualMachineDeleteCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_delete_checkpoint_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_delete_checkpoint(
        self,
        resource_uri: str,
        body: _models.VirtualMachineDeleteCheckpoint,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to delete a checkpoint in a virtual machine instance.

        Deletes a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineDeleteCheckpoint
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """

    @overload
    def begin_delete_checkpoint(
        self, resource_uri: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to delete a checkpoint in a virtual machine instance.

        Deletes a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_delete_checkpoint(
        self, resource_uri: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to delete a checkpoint in a virtual machine instance.

        Deletes a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_delete_checkpoint(
        self, resource_uri: str, body: Union[_models.VirtualMachineDeleteCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to delete a checkpoint in a virtual machine instance.

        Deletes a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Is one of the following types:
         VirtualMachineDeleteCheckpoint, JSON, IO[bytes] Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineDeleteCheckpoint or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_checkpoint_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _restore_checkpoint_initial(
        self, resource_uri: str, body: Union[_models.VirtualMachineRestoreCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_virtual_machine_instances_restore_checkpoint_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_restore_checkpoint(
        self,
        resource_uri: str,
        body: _models.VirtualMachineRestoreCheckpoint,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to restores to a checkpoint in a virtual machine instance.

        Restores to a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineRestoreCheckpoint
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """

    @overload
    def begin_restore_checkpoint(
        self, resource_uri: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to restores to a checkpoint in a virtual machine instance.

        Restores to a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_restore_checkpoint(
        self, resource_uri: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to restores to a checkpoint in a virtual machine instance.

        Restores to a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_restore_checkpoint(
        self, resource_uri: str, body: Union[_models.VirtualMachineRestoreCheckpoint, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to restores to a checkpoint in a virtual machine instance.

        Restores to a checkpoint in virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param body: The content of the action request. Is one of the following types:
         VirtualMachineRestoreCheckpoint, JSON, IO[bytes] Required.
        :type body: ~azure.mgmt.scvmm.models.VirtualMachineRestoreCheckpoint or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._restore_checkpoint_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class VmInstanceHybridIdentityMetadatasOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`vm_instance_hybrid_identity_metadatas` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> _models.VmInstanceHybridIdentityMetadata:
        """Gets HybridIdentityMetadata.

        Implements HybridIdentityMetadata GET method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: VmInstanceHybridIdentityMetadata. The VmInstanceHybridIdentityMetadata is compatible
         with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.VmInstanceHybridIdentityMetadata
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "provisioningState": "str",
                        "publicKey": "str",
                        "resourceUid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.VmInstanceHybridIdentityMetadata] = kwargs.pop("cls", None)

        _request = build_vm_instance_hybrid_identity_metadatas_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VmInstanceHybridIdentityMetadata, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_by_virtual_machine_instance(
        self, resource_uri: str, **kwargs: Any
    ) -> Iterable["_models.VmInstanceHybridIdentityMetadata"]:
        """Implements GET HybridIdentityMetadata in a vm.

        Returns the list of HybridIdentityMetadata of the given VM.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: An iterator like instance of VmInstanceHybridIdentityMetadata
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.VmInstanceHybridIdentityMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "provisioningState": "str",
                        "publicKey": "str",
                        "resourceUid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.VmInstanceHybridIdentityMetadata]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vm_instance_hybrid_identity_metadatas_list_by_virtual_machine_instance_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.VmInstanceHybridIdentityMetadata], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class GuestAgentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.scvmm.ScVmmMgmtClient`'s
        :attr:`guest_agents` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> _models.GuestAgent:
        """Gets GuestAgent.

        Implements GuestAgent GET method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: GuestAgent. The GuestAgent is compatible with MutableMapping
        :rtype: ~azure.mgmt.scvmm.models.GuestAgent
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GuestAgent] = kwargs.pop("cls", None)

        _request = build_guest_agents_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GuestAgent, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_initial(
        self, resource_uri: str, resource: Union[_models.GuestAgent, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_guest_agents_create_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create(
        self, resource_uri: str, resource: _models.GuestAgent, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.GuestAgent]:
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: ~azure.mgmt.scvmm.models.GuestAgent
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns GuestAgent. The GuestAgent is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.GuestAgent]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create(
        self, resource_uri: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.GuestAgent]:
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns GuestAgent. The GuestAgent is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.GuestAgent]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @overload
    def begin_create(
        self, resource_uri: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.GuestAgent]:
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns GuestAgent. The GuestAgent is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.GuestAgent]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_uri: str, resource: Union[_models.GuestAgent, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.GuestAgent]:
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :param resource: Resource create parameters. Is one of the following types: GuestAgent, JSON,
         IO[bytes] Required.
        :type resource: ~azure.mgmt.scvmm.models.GuestAgent or JSON or IO[bytes]
        :return: An instance of LROPoller that returns GuestAgent. The GuestAgent is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.scvmm.models.GuestAgent]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GuestAgent] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_uri=resource_uri,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.GuestAgent, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.GuestAgent].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.GuestAgent](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def delete(self, resource_uri: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a GuestAgent resource.

        Implements GuestAgent DELETE method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_guest_agents_delete_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_virtual_machine_instance(self, resource_uri: str, **kwargs: Any) -> Iterable["_models.GuestAgent"]:
        """Implements GET GuestAgent in a vm.

        Returns the list of GuestAgent of the given vm.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the resource.
         Required.
        :type resource_uri: str
        :return: An iterator like instance of GuestAgent
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.scvmm.models.GuestAgent]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",
                    "name": "str",
                    "properties": {
                        "credentials": {
                            "password": "str",
                            "username": "str"
                        },
                        "customResourceName": "str",
                        "httpProxyConfig": {
                            "httpsProxy": "str"
                        },
                        "provisioningAction": "str",
                        "provisioningState": "str",
                        "status": "str",
                        "uuid": "str"
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",
                        "createdBy": "str",
                        "createdByType": "str",
                        "lastModifiedAt": "2020-02-20 00:00:00",
                        "lastModifiedBy": "str",
                        "lastModifiedByType": "str"
                    },
                    "type": "str"
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.GuestAgent]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_guest_agents_list_by_virtual_machine_instance_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.GuestAgent], deserialized["value"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _deserialize(_models.ErrorResponse, response.json())
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
